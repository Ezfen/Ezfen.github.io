{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/about/index.html","path":"about/index.html","modified":0,"renderable":0},{"_id":"source/demo/index.html","path":"demo/index.html","modified":0,"renderable":0},{"_id":"source/demo/css/component.css","path":"demo/css/component.css","modified":0,"renderable":0},{"_id":"source/demo/css/demo.css","path":"demo/css/demo.css","modified":0,"renderable":0},{"_id":"source/demo/css/normalize.css","path":"demo/css/normalize.css","modified":0,"renderable":0},{"_id":"source/demo/css/init.css","path":"demo/css/init.css","modified":0,"renderable":0},{"_id":"source/demo/img/10.jpg","path":"demo/img/10.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/11.jpg","path":"demo/img/11.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/12.jpg","path":"demo/img/12.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/13.jpg","path":"demo/img/13.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/14.jpg","path":"demo/img/14.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/2.jpg","path":"demo/img/2.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/3.jpg","path":"demo/img/3.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/4.jpg","path":"demo/img/4.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/5.jpg","path":"demo/img/5.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/6.jpg","path":"demo/img/6.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/7.jpg","path":"demo/img/7.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/8.jpg","path":"demo/img/8.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/9.jpg","path":"demo/img/9.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/dummy.png","path":"demo/img/dummy.png","modified":0,"renderable":0},{"_id":"source/demo/img/Thumbs.db","path":"demo/img/Thumbs.db","modified":0,"renderable":0},{"_id":"source/demo/js/classie.js","path":"demo/js/classie.js","modified":0,"renderable":0},{"_id":"source/demo/js/colorfinder-1.1.js","path":"demo/js/colorfinder-1.1.js","modified":0,"renderable":0},{"_id":"source/demo/img/loading.gif","path":"demo/img/loading.gif","modified":0,"renderable":0},{"_id":"source/demo/js/imagesloaded.pkgd.min.js","path":"demo/js/imagesloaded.pkgd.min.js","modified":0,"renderable":0},{"_id":"source/demo/js/gridScrollFx.js","path":"demo/js/gridScrollFx.js","modified":0,"renderable":0},{"_id":"source/demo/js/masonry.pkgd.min.js","path":"demo/js/masonry.pkgd.min.js","modified":0,"renderable":0},{"_id":"source/demo/js/modernizr.custom.js","path":"demo/js/modernizr.custom.js","modified":0,"renderable":0},{"_id":"source/demo/img/1.jpg","path":"demo/img/1.jpg","modified":0,"renderable":0},{"_id":"themes/hollow/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/backtop.styl","path":"css/backtop.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/hollow/source/css/component.css","path":"css/component.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/content.css","path":"css/content.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/category.styl","path":"css/category.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/navigation.styl","path":"css/navigation.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/playball.css","path":"css/playball.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/default.cur","path":"images/default.cur","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/backtop.js","path":"js/backtop.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/pointer.cur","path":"images/pointer.cur","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/classie.js","path":"js/classie.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/modernizr.custom.js","path":"js/modernizr.custom.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/uiMorphingButton_fixed.js","path":"js/uiMorphingButton_fixed.js","modified":0,"renderable":1},{"_id":"source/demo/fonts/codropsicons/codropsicons.svg","path":"demo/fonts/codropsicons/codropsicons.svg","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.ttf","path":"demo/fonts/codropsicons/codropsicons.ttf","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.eot","path":"demo/fonts/codropsicons/codropsicons.eot","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.woff","path":"demo/fonts/codropsicons/codropsicons.woff","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/license.txt","path":"demo/fonts/codropsicons/license.txt","modified":0,"renderable":0},{"_id":"themes/hollow/source/images/background_1.jpg","path":"images/background_1.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/background_bak.png","path":"images/background_bak.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"486d7f3b56f8ae7beedc054731275ee0f4017e81","modified":1516690817561},{"_id":"source/README.md","hash":"7524890e386b2669e17015eef2a6b239525672e9","modified":1541748657993},{"_id":"source/.DS_Store","hash":"d7bd26bc1a52480485d139771c6985b6212baf77","modified":1522814220199},{"_id":"source/favicon.png","hash":"f19e255a25a7a47586074dee505d63c4db443438","modified":1508167532000},{"_id":"themes/hollow/.DS_Store","hash":"2abb4d41925a95c98c051344f2da8ac023dce75d","modified":1507558772000},{"_id":"themes/hollow/LICENSE","hash":"0aa093714c449e496e41093e55e939d19dd791d6","modified":1508167532000},{"_id":"themes/hollow/README.md","hash":"9fb701d6366348c1d676a4f06e15cc6e4713b6fb","modified":1508167532000},{"_id":"themes/hollow/_config.yml","hash":"6a3c1e7d66c12f0b60ea567899e248331caf5ccb","modified":1508167532000},{"_id":"source/apple-touch-icon.png","hash":"80f6acded913cc59552a76af528873603f15558e","modified":1508167532000},{"_id":"source/_posts/EZHeartForLike.md","hash":"0995bd4790fa341c85f187c00e580721af9cd0ab","modified":1541747704788},{"_id":"source/_posts/VSCode+SLSP.md","hash":"f6d55015c5f2ce436eaba2577478003a2d90dc73","modified":1542610716235},{"_id":"source/_posts/.DS_Store","hash":"993e36049897308cae34696176d7ccee84269d16","modified":1522294874734},{"_id":"source/_posts/Jenkins.md","hash":"231efc365f0ba88aab710724a6870934c6b4fa84","modified":1541508827938},{"_id":"source/_posts/autoresizingMask.md","hash":"48284d6341d78aeb10234fd574b3529c7be552af","modified":1541506998684},{"_id":"source/_posts/hello-world.md","hash":"fbfd115ac8ead5daddf9c9bc93976452f7b545e8","modified":1541507426373},{"_id":"source/_posts/iOS下重要的多线程GCD.md","hash":"5f9905cc9bbb0f3601c8e747733c2426ab81d656","modified":1541507709958},{"_id":"source/_posts/iOS-Event传递和响应链.md","hash":"e60e16bd6c7b5a0fe265fa9c9363836cadd3ce0b","modified":1541507699064},{"_id":"source/_posts/iOS脚本打包.md","hash":"a3bf491a793d87d97998daf32e3f483c26525f04","modified":1541508065600},{"_id":"source/_posts/使用MakeFile创建静态库.md","hash":"2885bd4c41a633ecc9e29b7485b72d2635e5b74d","modified":1541509417766},{"_id":"source/_posts/对线程的简单理解.md","hash":"0ae3574d8ac83392f9fac4f1d4d083ce7c52ffa5","modified":1541509656605},{"_id":"source/_posts/我有烦恼，你有答案.md","hash":"cc2bdfec50223976c7ca9e0459da70cabdab5309","modified":1520409977251},{"_id":"source/_posts/类方法Block内存泄漏.md","hash":"b5fecad6fb5380afb28b389b152f741a9f0d23b1","modified":1541747789550},{"_id":"source/_posts/简简单单说说PKIOniOS.md","hash":"429f844c47967f49a7e5cf584ab1bfc3e91512ac","modified":1541747767036},{"_id":"source/_posts/逆向修复软件的BUG.md","hash":"027b28bb7e63c923b7a0ca0533723e6f9e992af9","modified":1541743302154},{"_id":"source/_posts/阿澤君的独白.md","hash":"55661df7808c918837ad9bd6e3d2b7ca1712c5dc","modified":1520409140607},{"_id":"source/_posts/项目Beauty总结.md","hash":"356473766c4aa711f6d1894ab536caa3948579e5","modified":1521077547566},{"_id":"source/about/.DS_Store","hash":"0026a41cc0ca8ce050d7446082c78516c5633432","modified":1487513878000},{"_id":"source/about/index.html","hash":"7352f5d48164b8fad4133e47173e5f765da7531f","modified":1508771529000},{"_id":"source/demo/.DS_Store","hash":"49ecd8db5fa7aa0d33e9fa1902311d566c758061","modified":1487929005000},{"_id":"source/demo/index.html","hash":"3fc289d5180fc995f129436406047a150ad42d82","modified":1508167532000},{"_id":"source/tags/index.md","hash":"e4fcaa4a711ee1ed153ebf8cfdfb7eadc65365e4","modified":1508167532000},{"_id":"themes/hollow/languages/default.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1508167532000},{"_id":"themes/hollow/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1508167532000},{"_id":"themes/hollow/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1508167532000},{"_id":"themes/hollow/languages/zh-Hans.yml","hash":"053c45b0db64929e9fa2b1dbf271588d1118b911","modified":1508167532000},{"_id":"themes/hollow/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1508167532000},{"_id":"source/_posts/Xcode 10 新特性.md","hash":"34c3b85ceaa8f00f5dd8d219830f55f3a12535f1","modified":1541557419960},{"_id":"themes/hollow/layout/.DS_Store","hash":"09637d84eac56c0bbeb9416686b898ea4bcdde92","modified":1487315304000},{"_id":"themes/hollow/layout/index.ejs","hash":"5afc72ef49187e8d29aa656547552bddb0d926d1","modified":1541572541842},{"_id":"themes/hollow/layout/archive.ejs","hash":"7ad2499729da4ae5bdf1af5c5a2df926a93a553a","modified":1508167532000},{"_id":"themes/hollow/layout/page.ejs","hash":"d74a7a45bdc65ce5b049bc622170032bf9940b56","modified":1508167532000},{"_id":"themes/hollow/layout/layout.ejs","hash":"e4a187f9fde9e00c9bdd0246792ed54a65e76384","modified":1522829769177},{"_id":"themes/hollow/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1508167532000},{"_id":"themes/hollow/source/.DS_Store","hash":"2da78585b61381e662a783b363f0bbf080f83a95","modified":1503217620000},{"_id":"source/demo/css/component.css","hash":"3ee5f2a934986a74ab6fe1c24f2ffee8d9f0b40c","modified":1508167532000},{"_id":"source/demo/css/demo.css","hash":"5e610860218722103852254901ed4f561695bd38","modified":1508167532000},{"_id":"source/demo/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1508167532000},{"_id":"source/demo/css/init.css","hash":"19249942460483b83425fd9072329b6b4decc9d6","modified":1508167532000},{"_id":"source/demo/fonts/.DS_Store","hash":"f259329c67189902e9767884b6811df0ea138eb3","modified":1487298426000},{"_id":"source/demo/img/10.jpg","hash":"cf054dcda4fe76940264a2f7b45ace9a8f8788f2","modified":1508167532000},{"_id":"source/demo/img/11.jpg","hash":"9edc600344b745f9340fa041003254b6f60187ce","modified":1508167532000},{"_id":"source/demo/img/12.jpg","hash":"e9857d9321c7b35847c24efd55e81a7657e3fc2d","modified":1508167532000},{"_id":"source/demo/img/13.jpg","hash":"a5f476016a19effc9c588ba8938bf4c49414a089","modified":1508167532000},{"_id":"source/demo/img/14.jpg","hash":"99df3ffe7f7ce609402c27800ed758cddd8cd818","modified":1508167532000},{"_id":"source/demo/img/2.jpg","hash":"85d205dd455451e1235c33e27a1060ba5cf1b2c3","modified":1508167532000},{"_id":"source/demo/img/3.jpg","hash":"44945eec703223535155953fcf9c24c84e5b5056","modified":1508167532000},{"_id":"source/demo/img/4.jpg","hash":"769dbadadab1bd82b24b1a2cc4520a6713178120","modified":1508167532000},{"_id":"source/demo/img/5.jpg","hash":"4fff7c86ad034e7c5f7697b4f7b12f7525068c8f","modified":1508167532000},{"_id":"source/demo/img/6.jpg","hash":"688d59d3ddc43d117da60c2d86d4979d10b3e8f0","modified":1508167532000},{"_id":"source/demo/img/7.jpg","hash":"8069d3fc4a4737e3155799dcce2fedd4066d2bbb","modified":1508167532000},{"_id":"source/demo/img/8.jpg","hash":"5c1cc79f3c0dbab37493cb913f8f3a3b0ea38470","modified":1508167532000},{"_id":"source/demo/img/9.jpg","hash":"7c34266bb957f6b00a5d0bb5f5cedabd3a31fcf5","modified":1508167532000},{"_id":"source/demo/img/dummy.png","hash":"b7bed4edd54d4b0d8dde97d03a102530fc9f9d54","modified":1508167532000},{"_id":"source/demo/img/Thumbs.db","hash":"1f4318671088fdc6d057fa748a88f65519e721a8","modified":1508167532000},{"_id":"source/demo/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1508167532000},{"_id":"source/demo/js/colorfinder-1.1.js","hash":"fe47069f811272fcd33a7488642e30fd3f25d725","modified":1508167532000},{"_id":"source/demo/img/loading.gif","hash":"deedbc14742a4163d1fcce18211cfc76ba06505f","modified":1508167532000},{"_id":"source/demo/js/imagesloaded.pkgd.min.js","hash":"dea4f6ecff8935bba3323104fee273a173f1262e","modified":1508167532000},{"_id":"source/demo/js/gridScrollFx.js","hash":"eaf98cdf8b39384e04ae61b901e08ed32aa485db","modified":1508167532000},{"_id":"source/demo/js/masonry.pkgd.min.js","hash":"d87128d50e1c17e03ac7a2297dd0337158775301","modified":1508167532000},{"_id":"source/demo/js/modernizr.custom.js","hash":"897d01634e1728d281fa5c6e27f37d1d7652290c","modified":1508167532000},{"_id":"source/demo/img/1.jpg","hash":"2d1d841ae831bc8d88adbd95df9c1f3c331fb518","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/about.ejs","hash":"7f96c9e91e80c1628f9aa7f91eb5429103001a6e","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/all-tags-left.ejs","hash":"3247188df4892c281479662846b2e5e7ebac9189","modified":1521077721573},{"_id":"themes/hollow/layout/_partial/all-tags.ejs","hash":"97a73c5e7274d234ee1314fc952d54c614a07c36","modified":1518399583266},{"_id":"themes/hollow/layout/_partial/article-archive.ejs","hash":"d52b04f27427b0a4ff97522175bef8ec8e0a9130","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/.DS_Store","hash":"4bf4464ddc7b8b0e28b6d858fbb2a1b810bc96ac","modified":1486563700000},{"_id":"themes/hollow/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/article-full.ejs","hash":"862cb7a8cdb63667a2f56c7990e6e49e8381bcac","modified":1541560731674},{"_id":"themes/hollow/layout/_partial/article-index.ejs","hash":"d9ca79142cae43cabe7f4f3a83a2e66dba79fe7e","modified":1518229640302},{"_id":"themes/hollow/layout/_partial/article-tags.ejs","hash":"156eb953ad23071f789c3f0566748a6209dc586d","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/backhome.ejs","hash":"aa44bb3d5c3e902f9cb3aaab8b5cba24acacfe78","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/backtop.ejs","hash":"15e23a92e9ee7260384c55d9d4d10c36d7dbdb9f","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/demo.ejs","hash":"c6c7e88348b8c14136b2a3925234a4aa51b8bbaa","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/comment.ejs","hash":"cf942107e02af29c19bda11358942e7fd97a84fd","modified":1520397580952},{"_id":"themes/hollow/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/head.ejs","hash":"6c33017b90cd94db043cc92b9f7b00c3f42bbbf5","modified":1541506842244},{"_id":"themes/hollow/layout/_partial/pagination.ejs","hash":"9f086bd506077b121563ff66123cdae4ccfbed50","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/scripts.ejs","hash":"6425902cef0b764f733d23fdb0748d19d238cb48","modified":1541572787827},{"_id":"themes/hollow/layout/_partial/search.ejs","hash":"2495661fb06fff741dfeedf09df094545fb061d9","modified":1523152960249},{"_id":"themes/hollow/layout/_partial/searchfunc.ejs","hash":"7e03974af2e7d46bc5899cfa8065a9c72fede281","modified":1522831166661},{"_id":"themes/hollow/source/css/article.styl","hash":"cf8bfe76b59afb42522cdbae6f7d8fd5d40c858d","modified":1519907341467},{"_id":"themes/hollow/source/css/backtop.styl","hash":"ec3dd697a34ec51ec5db337a3d7b2b8eb2806b1c","modified":1541506360143},{"_id":"themes/hollow/source/css/base.styl","hash":"2599021e74948621598bf33c43afda682298ec5a","modified":1541563137078},{"_id":"themes/hollow/source/css/component.css","hash":"d1b9fedb2d82433c3af4205bd8392f6af671193c","modified":1522829242862},{"_id":"themes/hollow/source/css/main.styl","hash":"966b3fd9fc41cff36f39881f30701b19b07f07f2","modified":1541506408895},{"_id":"themes/hollow/source/css/content.css","hash":"698069e5c0d99d1ac021a9af29dc32a7db5c1c71","modified":1523154110479},{"_id":"themes/hollow/source/css/category.styl","hash":"14b5e8826307c026ae2bfd5472ac87db3cd94d55","modified":1520242936726},{"_id":"themes/hollow/source/css/mixins.styl","hash":"db65c8c99ad1afae4726b6dc24f69d3e606ab4ec","modified":1541506232427},{"_id":"themes/hollow/source/css/navigation.styl","hash":"f74cf3dacee4093e04da60ad72b5cd4ef81900c4","modified":1541506441614},{"_id":"themes/hollow/source/css/search.styl","hash":"b1c2708c391e7125ed9c288611f93ea816039cc9","modified":1541506471480},{"_id":"themes/hollow/source/css/style.styl","hash":"15ba84b537171dc16622dbbcb9870b8dfa045885","modified":1508167532000},{"_id":"themes/hollow/source/css/playball.css","hash":"49045d0cceae613d902d2e1b3fac268e8e555ae8","modified":1508167532000},{"_id":"themes/hollow/source/css/variables.styl","hash":"c7a5d7efcf67c7790915353230c157aa14d25afd","modified":1520242772622},{"_id":"themes/hollow/source/images/.DS_Store","hash":"4866bf27e45c38043503c610af24b78f3c330c51","modified":1508080808000},{"_id":"themes/hollow/source/images/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1520241091047},{"_id":"themes/hollow/source/js/backtop.js","hash":"9f1c5967e3585d3ee323bf97f412af290ee4404f","modified":1518424165773},{"_id":"themes/hollow/source/js/main.js","hash":"4e14f8cbfe3645876991a3541ba46f85a39b7252","modified":1508167532000},{"_id":"themes/hollow/source/images/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1520242292639},{"_id":"themes/hollow/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1523585218442},{"_id":"themes/hollow/source/js/search.js","hash":"c269b0f33cbf8791f43177d19dc8bbc05dd533ad","modified":1523154420973},{"_id":"themes/hollow/source/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1399708648000},{"_id":"themes/hollow/source/js/modernizr.custom.js","hash":"c36a15206943880cbb6a88016ab9f4b99a30570a","modified":1399485028000},{"_id":"themes/hollow/source/js/uiMorphingButton_fixed.js","hash":"7e45f9a7588328559ccc4446d19922227f2d378f","modified":1522828968594},{"_id":"source/demo/fonts/codropsicons/codropsicons.svg","hash":"0de9f0aaf1cdf27ef9931d45c5eab3374c7142f4","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.ttf","hash":"e670d3deb662651d71461be5a41add4a48b8998a","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.eot","hash":"d3bd1eb3823f094524ddf6070c154ccab81e6951","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.woff","hash":"7c0ba611c947ddb5a82fa47a87a1ce63ed8bcd7f","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/license.txt","hash":"d3d34d2a512acf27557ea82ac82a51058df43091","modified":1508167532000},{"_id":"themes/hollow/source/images/background_1.jpg","hash":"2dbf868225f7b454ca0c745c64a96ba948f00dc3","modified":1508167532000},{"_id":"themes/hollow/source/images/avatar.jpg","hash":"159a800376aebf291e959414f8b19da833a10648","modified":1508167532000},{"_id":"themes/hollow/source/images/background.jpg","hash":"b28817e6107175d793fcab7f48120926db2a6217","modified":1508167532000},{"_id":"themes/hollow/source/images/background_bak.png","hash":"dcccd29a5e8b71153c3ed3f139c3de31f6fefd90","modified":1508167532000},{"_id":"public/search.xml","hash":"eeff3e634ce54b3f95c5341ea4db5d0f3f33c729","modified":1542610758051},{"_id":"public/tags/index.html","hash":"ce81239486875835bd77f973a7a0e82f187cdfaf","modified":1542610758244},{"_id":"public/2017/08/08/使用MakeFile创建静态库/index.html","hash":"a4c4cfc2a3cde93c0e28cde65d0b3c29673f9d44","modified":1542610758324},{"_id":"public/2017/02/27/iOS-Event传递和响应链/index.html","hash":"419fcefab7d955a582af18571ef08cad55fbfbed","modified":1542610758327},{"_id":"public/2017/02/19/我有烦恼，你有答案/index.html","hash":"abec87989afe510eb160439fd6a7c321426b59c8","modified":1542610758327},{"_id":"public/2017/02/17/hello-world/index.html","hash":"3282541dc220359132fc4bd122409b93a8ccde0b","modified":1542610758327},{"_id":"public/2016/07/17/类方法Block内存泄漏/index.html","hash":"5951e32c822ad26a071261c8ad09d09fb9f22710","modified":1542610758327},{"_id":"public/2018/06/15/Xcode 10 新特性/index.html","hash":"51e5c1296b8dd7b032fa49b8dac9003e84b9daca","modified":1542610758327},{"_id":"public/2018/11/07/逆向修复软件的BUG/index.html","hash":"1fba9fb4c791439ebdc02e6013c450ffa29dac60","modified":1542610758327},{"_id":"public/2018/04/27/Jenkins/index.html","hash":"032d57deefddaa234899271d4e7ab9eaab8be857","modified":1542610758328},{"_id":"public/2017/03/23/iOS下重要的多线程GCD/index.html","hash":"6c9eefdb746a690b862f8726272c07c51aca602f","modified":1542610758328},{"_id":"public/2017/03/14/对线程的简单理解/index.html","hash":"3737dbfac87bf0f0205fc816da40b9d945bb1eb6","modified":1542610758328},{"_id":"public/2018/11/19/VSCode+SLSP/index.html","hash":"d3a2d064d1dfa57715b41aa956326a70fef6bc2e","modified":1542610758345},{"_id":"public/2016/05/21/EZHeartForLike/index.html","hash":"3c576fcd6acf21cbae4f6f91210673ff8e7265ea","modified":1542610758347},{"_id":"public/2016/04/02/阿澤君的独白/index.html","hash":"2f8be7e24f3556809021370984bb7f9e2786bdf3","modified":1542610758347},{"_id":"public/archives/index.html","hash":"e7d852aced6a93848274af9ca83e5297a69a034e","modified":1542610758347},{"_id":"public/archives/page/2/index.html","hash":"855509820494e8dc0e765590c1a183d1656d9642","modified":1542610758347},{"_id":"public/2016/03/19/autoresizingMask/index.html","hash":"fd2a911a9a8dde63ae863f8d5876971ff343076e","modified":1542610758347},{"_id":"public/archives/page/3/index.html","hash":"fa59ac31d1cba30392d2f582e3bb374703bbe608","modified":1542610758347},{"_id":"public/archives/page/4/index.html","hash":"38f5b360cada8a8f0397c71345b43a01d33912cf","modified":1542610758348},{"_id":"public/archives/2016/index.html","hash":"6a68ead1bdbe16b1ffd09b315444e3bf78203077","modified":1542610758348},{"_id":"public/archives/2016/05/index.html","hash":"765b47318321c4049f944757b8b61a3206840370","modified":1542610758348},{"_id":"public/archives/2016/03/index.html","hash":"70eb9152614767f07cbb48b44fecba9e22a1389e","modified":1542610758348},{"_id":"public/archives/2016/07/index.html","hash":"c93e2231cc81edf914f45ade6224a4775419f874","modified":1542610758348},{"_id":"public/archives/2017/index.html","hash":"5f20e42e0eefe0a76ab8c7a2154f2abbe4f3c4f5","modified":1542610758348},{"_id":"public/archives/2017/02/index.html","hash":"b440171029577f94028272ebded6722d0ffab498","modified":1542610758348},{"_id":"public/archives/2017/page/2/index.html","hash":"d43c11c0e9bfa4a520da6bf4480fde5c94217d59","modified":1542610758348},{"_id":"public/archives/2017/03/index.html","hash":"df51dc0e260fdd6cd03946d51504c529e8771c8f","modified":1542610758348},{"_id":"public/archives/2017/07/index.html","hash":"e339b44b0811c2c87cba4948c7eafbc9eb87ffaf","modified":1542610758348},{"_id":"public/archives/2018/index.html","hash":"c2314cbef2acd73d0ae33c34cf395f9f54859a79","modified":1542610758348},{"_id":"public/archives/2017/08/index.html","hash":"6e4405261ba568b0e5d7fe5f871eb4282ff0f3e3","modified":1542610758348},{"_id":"public/archives/2018/04/index.html","hash":"92aeb5e35dc3c0e687528540e00f5cfb9524076c","modified":1542610758348},{"_id":"public/archives/2016/04/index.html","hash":"b79fdb32133df7ffce46dcda6783281cb7421001","modified":1542610758348},{"_id":"public/archives/2018/11/index.html","hash":"3904535a43de77482b63ebdf31c3dbc7b7d04e6d","modified":1542610758348},{"_id":"public/archives/2018/06/index.html","hash":"65e8d9d3a8583eb11514d3ef9afc8a2322bb7391","modified":1542610758348},{"_id":"public/tags/CI/index.html","hash":"0beaff1aa2e4f8a95a658ebf4059b5ff673034de","modified":1542610758348},{"_id":"public/tags/UIView/index.html","hash":"53d174ee19e9e5451893b11d60cfbe27868ab4be","modified":1542610758348},{"_id":"public/tags/Mood/index.html","hash":"9ca9c19a090c113b89c6cd5747b6d28ba66a188e","modified":1542610758349},{"_id":"public/tags/Thread/index.html","hash":"81a54b29cb1819d31b9ad99b3551b5e93776882c","modified":1542610758349},{"_id":"public/tags/Distribution/index.html","hash":"6172b4f338d8f03b46219a2261638d9b922c3b8c","modified":1542610758349},{"_id":"public/tags/Library/index.html","hash":"2ca20f7b8fac56fc051b76ff73169abbd4a5b109","modified":1542610758349},{"_id":"public/tags/Block/index.html","hash":"55f2113c10667af771fcc86a10674cc561daef4c","modified":1542610758349},{"_id":"public/tags/Security/index.html","hash":"a54c981e4fa3289595a1cff1736edcd9465dedaf","modified":1542610758349},{"_id":"public/tags/Summary/index.html","hash":"8240089dcf9c148d080871d49858a58d3ba814ea","modified":1542610758349},{"_id":"public/index.html","hash":"d77362bf9be88760e053538d122879620c1057ce","modified":1542610758349},{"_id":"public/tags/WWDC2018/index.html","hash":"46439c052fa40a18835a465bcec173e66dfef4ef","modified":1542610758349},{"_id":"public/page/2/index.html","hash":"be497cfe2cb853eabd0a778cf693f67008082265","modified":1542610758349},{"_id":"public/page/3/index.html","hash":"fd5b83ff401496320d01fba95e2cebabd385d874","modified":1542610758349},{"_id":"public/page/4/index.html","hash":"c70fb93855c6e3c17e984fe3cf06318401efefd0","modified":1542610758349},{"_id":"public/tags/Animation/index.html","hash":"a0ea88b5a88334409f08829ddb6fa4fe3e4a95c1","modified":1542610758349},{"_id":"public/2017/07/17/项目Beauty总结/index.html","hash":"20ff40681974c717a89c57c8fe252b0d2f4207b0","modified":1542610758349},{"_id":"public/2016/04/09/简简单单说说PKIOniOS/index.html","hash":"3597d56879b3bc576eaefe224b72559d69885a53","modified":1542610758349},{"_id":"public/2018/04/02/iOS脚本打包/index.html","hash":"a0adbcbeb92b2742d9c906698d826fa37c12ab09","modified":1542610758349},{"_id":"public/tags/Swift/index.html","hash":"fa349851d9f3c2c83bc91e26e8baafc2224f8522","modified":1542610758356},{"_id":"public/CNAME","hash":"486d7f3b56f8ae7beedc054731275ee0f4017e81","modified":1542610758356},{"_id":"public/README.md","hash":"7524890e386b2669e17015eef2a6b239525672e9","modified":1542610758356},{"_id":"public/favicon.png","hash":"f19e255a25a7a47586074dee505d63c4db443438","modified":1542610758356},{"_id":"public/apple-touch-icon.png","hash":"80f6acded913cc59552a76af528873603f15558e","modified":1542610758356},{"_id":"public/demo/index.html","hash":"3fc289d5180fc995f129436406047a150ad42d82","modified":1542610758356},{"_id":"public/about/index.html","hash":"7352f5d48164b8fad4133e47173e5f765da7531f","modified":1542610758356},{"_id":"public/demo/css/component.css","hash":"3ee5f2a934986a74ab6fe1c24f2ffee8d9f0b40c","modified":1542610758356},{"_id":"public/demo/css/demo.css","hash":"5e610860218722103852254901ed4f561695bd38","modified":1542610758356},{"_id":"public/demo/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1542610758357},{"_id":"public/demo/css/init.css","hash":"19249942460483b83425fd9072329b6b4decc9d6","modified":1542610758357},{"_id":"public/demo/img/11.jpg","hash":"9edc600344b745f9340fa041003254b6f60187ce","modified":1542610758357},{"_id":"public/demo/img/12.jpg","hash":"e9857d9321c7b35847c24efd55e81a7657e3fc2d","modified":1542610758357},{"_id":"public/demo/img/13.jpg","hash":"a5f476016a19effc9c588ba8938bf4c49414a089","modified":1542610758357},{"_id":"public/demo/img/14.jpg","hash":"99df3ffe7f7ce609402c27800ed758cddd8cd818","modified":1542610758357},{"_id":"public/demo/img/2.jpg","hash":"85d205dd455451e1235c33e27a1060ba5cf1b2c3","modified":1542610758357},{"_id":"public/demo/img/3.jpg","hash":"44945eec703223535155953fcf9c24c84e5b5056","modified":1542610758357},{"_id":"public/demo/img/4.jpg","hash":"769dbadadab1bd82b24b1a2cc4520a6713178120","modified":1542610758357},{"_id":"public/demo/img/5.jpg","hash":"4fff7c86ad034e7c5f7697b4f7b12f7525068c8f","modified":1542610758357},{"_id":"public/demo/img/6.jpg","hash":"688d59d3ddc43d117da60c2d86d4979d10b3e8f0","modified":1542610758357},{"_id":"public/demo/img/10.jpg","hash":"cf054dcda4fe76940264a2f7b45ace9a8f8788f2","modified":1542610758357},{"_id":"public/demo/img/8.jpg","hash":"5c1cc79f3c0dbab37493cb913f8f3a3b0ea38470","modified":1542610758357},{"_id":"public/demo/img/Thumbs.db","hash":"1f4318671088fdc6d057fa748a88f65519e721a8","modified":1542610758358},{"_id":"public/demo/img/9.jpg","hash":"7c34266bb957f6b00a5d0bb5f5cedabd3a31fcf5","modified":1542610758358},{"_id":"public/demo/img/7.jpg","hash":"8069d3fc4a4737e3155799dcce2fedd4066d2bbb","modified":1542610758358},{"_id":"public/demo/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1542610758358},{"_id":"public/demo/js/colorfinder-1.1.js","hash":"fe47069f811272fcd33a7488642e30fd3f25d725","modified":1542610758358},{"_id":"public/demo/js/gridScrollFx.js","hash":"eaf98cdf8b39384e04ae61b901e08ed32aa485db","modified":1542610758358},{"_id":"public/demo/img/loading.gif","hash":"deedbc14742a4163d1fcce18211cfc76ba06505f","modified":1542610758358},{"_id":"public/demo/js/imagesloaded.pkgd.min.js","hash":"dea4f6ecff8935bba3323104fee273a173f1262e","modified":1542610758358},{"_id":"public/demo/js/masonry.pkgd.min.js","hash":"d87128d50e1c17e03ac7a2297dd0337158775301","modified":1542610758359},{"_id":"public/demo/js/modernizr.custom.js","hash":"897d01634e1728d281fa5c6e27f37d1d7652290c","modified":1542610758359},{"_id":"public/images/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1542610758359},{"_id":"public/demo/img/1.jpg","hash":"2d1d841ae831bc8d88adbd95df9c1f3c331fb518","modified":1542610758359},{"_id":"public/images/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1542610758359},{"_id":"public/demo/img/dummy.png","hash":"b7bed4edd54d4b0d8dde97d03a102530fc9f9d54","modified":1542610758359},{"_id":"public/demo/fonts/codropsicons/codropsicons.ttf","hash":"e670d3deb662651d71461be5a41add4a48b8998a","modified":1542610758359},{"_id":"public/demo/fonts/codropsicons/codropsicons.eot","hash":"d3bd1eb3823f094524ddf6070c154ccab81e6951","modified":1542610758359},{"_id":"public/demo/fonts/codropsicons/codropsicons.svg","hash":"0de9f0aaf1cdf27ef9931d45c5eab3374c7142f4","modified":1542610758359},{"_id":"public/demo/fonts/codropsicons/codropsicons.woff","hash":"7c0ba611c947ddb5a82fa47a87a1ce63ed8bcd7f","modified":1542610758359},{"_id":"public/demo/fonts/codropsicons/license.txt","hash":"d3d34d2a512acf27557ea82ac82a51058df43091","modified":1542610758359},{"_id":"public/css/article.css","hash":"e3e39a149262ce47fb66b0241de833c35f4ce123","modified":1542610759074},{"_id":"public/css/backtop.css","hash":"8a1f89c6e5a8e322917ff17d3631deb42abc3c9f","modified":1542610759074},{"_id":"public/css/base.css","hash":"60e60b07a5e9a0d620f78e7c94251a81eb3b1d92","modified":1542610759074},{"_id":"public/css/component.css","hash":"d1b9fedb2d82433c3af4205bd8392f6af671193c","modified":1542610759074},{"_id":"public/css/main.css","hash":"52f215c184ada5e1cedf4424c822915a749f9dfd","modified":1542610759074},{"_id":"public/css/content.css","hash":"698069e5c0d99d1ac021a9af29dc32a7db5c1c71","modified":1542610759075},{"_id":"public/css/category.css","hash":"5e8ed140ec7b3f192a26faf4b828ab655f476b80","modified":1542610759075},{"_id":"public/css/mixins.css","hash":"673948d2c6a48be842db7f72701695304adf781c","modified":1542610759075},{"_id":"public/css/search.css","hash":"f17216afcd10d0ac5ff95eb015706cee20781b58","modified":1542610759075},{"_id":"public/css/navigation.css","hash":"3a81417fc07ee2f42ff1d1bcb089e653934cf8da","modified":1542610759075},{"_id":"public/css/playball.css","hash":"49045d0cceae613d902d2e1b3fac268e8e555ae8","modified":1542610759075},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542610759075},{"_id":"public/js/backtop.js","hash":"9f1c5967e3585d3ee323bf97f412af290ee4404f","modified":1542610759075},{"_id":"public/js/main.js","hash":"4e14f8cbfe3645876991a3541ba46f85a39b7252","modified":1542610759075},{"_id":"public/js/search.js","hash":"c269b0f33cbf8791f43177d19dc8bbc05dd533ad","modified":1542610759075},{"_id":"public/js/modernizr.custom.js","hash":"c36a15206943880cbb6a88016ab9f4b99a30570a","modified":1542610759075},{"_id":"public/js/uiMorphingButton_fixed.js","hash":"7e45f9a7588328559ccc4446d19922227f2d378f","modified":1542610759075},{"_id":"public/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1542610759075},{"_id":"public/css/style.css","hash":"407e225e62fbfa7dfefbcb3400b7199a538d092c","modified":1542610759075},{"_id":"public/images/background_1.jpg","hash":"2dbf868225f7b454ca0c745c64a96ba948f00dc3","modified":1542610759089},{"_id":"public/images/avatar.jpg","hash":"159a800376aebf291e959414f8b19da833a10648","modified":1542610759089},{"_id":"public/images/background.jpg","hash":"b28817e6107175d793fcab7f48120926db2a6217","modified":1542610759098},{"_id":"public/images/background_bak.png","hash":"dcccd29a5e8b71153c3ed3f139c3de31f6fefd90","modified":1542610759104}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-10-09T14:51:34.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-10-09 22:51:34\n---\n","updated":"2017-10-16T15:25:32.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjonym6dd0001qu0xducm5b0y","content":"","excerpt":"","more":""}],"Post":[{"title":"穿越的桃心~","date":"2016-05-21T07:23:18.000Z","typora-copy-images-to":"ipic","_content":"\n最近没事看看 Instagram 的时候，对于双击点赞的功能感觉蛮 Like 。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)\n\n<!--more-->\n\n![EZHeartForLike_logo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png)    \n效果图(第一张是双击图片触发，第二张是单击按钮)：\n![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif)       ![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif)    \n先说说这是个什么东西。    \n一开始我是在 Instagram 的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。就像这样：\n![EZHeartForLike_gem](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg)    \n好吧，尺寸是是用我又爱又恨的 4S 的 320 x 480    \n紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样\n![aixin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg)\n很快我遇到问题：如果两个桃心都在同一个 View 中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个 View 中（现实中很多情况都不会），**位置不明确**是一个巨大的问题。因此跨View的动画是 EZHeartForLike 是这次的主要话题。当然动画是使用 UIView 来实现的~~    \n那么，讲讲我的思路历程吧：    \n首先，我想了下能不能在一个 EZHeartForLikeView 中分别放入下列三个 View ，已实现我的想法：    \n\n* ContentView ：用于让用户将自己的 View 放入其中。类似 iOS8 里面的UIVisualEffectView 的 contentView 一样。    \n* SmallHeart ：被当做按钮的小桃心，是 Public 的，提供给用户改造它的样式、大小、位置等。 \n* BigHeart ：出现在图片( ImageView )中的大桃心\n\n在我自己涂涂画画后是这样的：    \n![EZHeartForLike_begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg)\n\n一开始觉得可能能行，因为两个桃心都在同一个View中( EZHeartForLikeView )，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为 Public 对外提供，那么用户就可以将它放入自己的 View 中。因此这个想法很快被否了。。。\n\n这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个 SuperView ，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：    \n简单一句话就是：**找到相同的 SuperView ，映射坐标，在 SuperView 上完成动画的实现**    \n![EZHeartForLike_findview](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg)\n具体怎么找到相同的 SuperView 嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。    \n这里我又要祭出我的灵魂画风了\n![EZHeartForLike_lianbiao](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg)    \n实现起来其实不是能难，且看代码：\n\n``` objc\n- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount > bigViewSuperViewCount) {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n```\n\n有了上面的思想，映射坐标同样变得简单：\n\n``` objc \n    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n```\n\n既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)    \n有兴趣的同学可以查看我的 [这个 Demo](https://github.com/objchris/ChrisDerDemos) ，可以下载在项目中，顺便给我个 Like 吧。","source":"_posts/EZHeartForLike.md","raw":"---\ntitle: 穿越的桃心~\ndate: 2016-05-21 15:23:18\ntags: \n- Animation\ntypora-copy-images-to: ipic\n---\n\n最近没事看看 Instagram 的时候，对于双击点赞的功能感觉蛮 Like 。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)\n\n<!--more-->\n\n![EZHeartForLike_logo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png)    \n效果图(第一张是双击图片触发，第二张是单击按钮)：\n![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif)       ![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif)    \n先说说这是个什么东西。    \n一开始我是在 Instagram 的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。就像这样：\n![EZHeartForLike_gem](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg)    \n好吧，尺寸是是用我又爱又恨的 4S 的 320 x 480    \n紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样\n![aixin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg)\n很快我遇到问题：如果两个桃心都在同一个 View 中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个 View 中（现实中很多情况都不会），**位置不明确**是一个巨大的问题。因此跨View的动画是 EZHeartForLike 是这次的主要话题。当然动画是使用 UIView 来实现的~~    \n那么，讲讲我的思路历程吧：    \n首先，我想了下能不能在一个 EZHeartForLikeView 中分别放入下列三个 View ，已实现我的想法：    \n\n* ContentView ：用于让用户将自己的 View 放入其中。类似 iOS8 里面的UIVisualEffectView 的 contentView 一样。    \n* SmallHeart ：被当做按钮的小桃心，是 Public 的，提供给用户改造它的样式、大小、位置等。 \n* BigHeart ：出现在图片( ImageView )中的大桃心\n\n在我自己涂涂画画后是这样的：    \n![EZHeartForLike_begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg)\n\n一开始觉得可能能行，因为两个桃心都在同一个View中( EZHeartForLikeView )，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为 Public 对外提供，那么用户就可以将它放入自己的 View 中。因此这个想法很快被否了。。。\n\n这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个 SuperView ，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：    \n简单一句话就是：**找到相同的 SuperView ，映射坐标，在 SuperView 上完成动画的实现**    \n![EZHeartForLike_findview](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg)\n具体怎么找到相同的 SuperView 嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。    \n这里我又要祭出我的灵魂画风了\n![EZHeartForLike_lianbiao](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg)    \n实现起来其实不是能难，且看代码：\n\n``` objc\n- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount > bigViewSuperViewCount) {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n```\n\n有了上面的思想，映射坐标同样变得简单：\n\n``` objc \n    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n```\n\n既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)    \n有兴趣的同学可以查看我的 [这个 Demo](https://github.com/objchris/ChrisDerDemos) ，可以下载在项目中，顺便给我个 Like 吧。","slug":"EZHeartForLike","published":1,"updated":"2018-11-09T07:15:04.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6da0000qu0xcu82gwq3","content":"<p>最近没事看看 Instagram 的时候，对于双击点赞的功能感觉蛮 Like 。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png\" alt=\"EZHeartForLike_logo\"><br>效果图(第一张是双击图片触发，第二张是单击按钮)：<br><img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif\" alt=\"\">       <img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif\" alt=\"\"><br>先说说这是个什么东西。<br>一开始我是在 Instagram 的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。就像这样：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg\" alt=\"EZHeartForLike_gem\"><br>好吧，尺寸是是用我又爱又恨的 4S 的 320 x 480<br>紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg\" alt=\"aixin\"><br>很快我遇到问题：如果两个桃心都在同一个 View 中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个 View 中（现实中很多情况都不会），<strong>位置不明确</strong>是一个巨大的问题。因此跨View的动画是 EZHeartForLike 是这次的主要话题。当然动画是使用 UIView 来实现的~~<br>那么，讲讲我的思路历程吧：<br>首先，我想了下能不能在一个 EZHeartForLikeView 中分别放入下列三个 View ，已实现我的想法：    </p>\n<ul>\n<li>ContentView ：用于让用户将自己的 View 放入其中。类似 iOS8 里面的UIVisualEffectView 的 contentView 一样。    </li>\n<li>SmallHeart ：被当做按钮的小桃心，是 Public 的，提供给用户改造它的样式、大小、位置等。 </li>\n<li>BigHeart ：出现在图片( ImageView )中的大桃心</li>\n</ul>\n<p>在我自己涂涂画画后是这样的：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg\" alt=\"EZHeartForLike_begin\"></p>\n<p>一开始觉得可能能行，因为两个桃心都在同一个View中( EZHeartForLikeView )，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为 Public 对外提供，那么用户就可以将它放入自己的 View 中。因此这个想法很快被否了。。。</p>\n<p>这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个 SuperView ，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：<br>简单一句话就是：<strong>找到相同的 SuperView ，映射坐标，在 SuperView 上完成动画的实现</strong><br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg\" alt=\"EZHeartForLike_findview\"><br>具体怎么找到相同的 SuperView 嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。<br>这里我又要祭出我的灵魂画风了<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg\" alt=\"EZHeartForLike_lianbiao\"><br>实现起来其实不是能难，且看代码：</p>\n<pre><code class=\"objc\">- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount &gt; bigViewSuperViewCount) {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n</code></pre>\n<p>有了上面的思想，映射坐标同样变得简单：</p>\n<pre><code class=\"objc\">    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n</code></pre>\n<p>既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)<br>有兴趣的同学可以查看我的 <a href=\"https://github.com/objchris/ChrisDerDemos\" target=\"_blank\" rel=\"external\">这个 Demo</a> ，可以下载在项目中，顺便给我个 Like 吧。</p>\n","excerpt":"<p>最近没事看看 Instagram 的时候，对于双击点赞的功能感觉蛮 Like 。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png\" alt=\"EZHeartForLike_logo\"><br>效果图(第一张是双击图片触发，第二张是单击按钮)：<br><img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif\" alt=\"\">       <img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif\" alt=\"\"><br>先说说这是个什么东西。<br>一开始我是在 Instagram 的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。就像这样：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg\" alt=\"EZHeartForLike_gem\"><br>好吧，尺寸是是用我又爱又恨的 4S 的 320 x 480<br>紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg\" alt=\"aixin\"><br>很快我遇到问题：如果两个桃心都在同一个 View 中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个 View 中（现实中很多情况都不会），<strong>位置不明确</strong>是一个巨大的问题。因此跨View的动画是 EZHeartForLike 是这次的主要话题。当然动画是使用 UIView 来实现的~~<br>那么，讲讲我的思路历程吧：<br>首先，我想了下能不能在一个 EZHeartForLikeView 中分别放入下列三个 View ，已实现我的想法：    </p>\n<ul>\n<li>ContentView ：用于让用户将自己的 View 放入其中。类似 iOS8 里面的UIVisualEffectView 的 contentView 一样。    </li>\n<li>SmallHeart ：被当做按钮的小桃心，是 Public 的，提供给用户改造它的样式、大小、位置等。 </li>\n<li>BigHeart ：出现在图片( ImageView )中的大桃心</li>\n</ul>\n<p>在我自己涂涂画画后是这样的：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg\" alt=\"EZHeartForLike_begin\"></p>\n<p>一开始觉得可能能行，因为两个桃心都在同一个View中( EZHeartForLikeView )，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为 Public 对外提供，那么用户就可以将它放入自己的 View 中。因此这个想法很快被否了。。。</p>\n<p>这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个 SuperView ，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：<br>简单一句话就是：<strong>找到相同的 SuperView ，映射坐标，在 SuperView 上完成动画的实现</strong><br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg\" alt=\"EZHeartForLike_findview\"><br>具体怎么找到相同的 SuperView 嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。<br>这里我又要祭出我的灵魂画风了<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg\" alt=\"EZHeartForLike_lianbiao\"><br>实现起来其实不是能难，且看代码：</p>\n<pre><code class=\"objc\">- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount &gt; bigViewSuperViewCount) {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n</code></pre>\n<p>有了上面的思想，映射坐标同样变得简单：</p>\n<pre><code class=\"objc\">    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n</code></pre>\n<p>既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)<br>有兴趣的同学可以查看我的 <a href=\"https://github.com/objchris/ChrisDerDemos\">这个 Demo</a> ，可以下载在项目中，顺便给我个 Like 吧。</p>"},{"title":"VSCode 和 SourceKit-LSP","date":"2018-11-19T12:56:06.000Z","typora-copy-images-to":"ipic","_content":"\n三年前 VSCode 诞生，它设计理念在我看来还是不错的，如今下载得到的 zip 也才 70M 不到。看了文档知道其中只是内嵌了些 JavaScript 、 TypeScript 等少数语言的支持。用户可以根据需要，通过安装 extension 来实现自定义功能的 IDE 。\n\n但用 VSCode 来写 Swift 一直以来都不是很友好，知道最近 SourceKit-LSP 开源，就打算来试试这个被 MS 捧在掌心的 IDE 。\n\n<!--more-->\n\n## 本文大纲\n\n写这篇文章的时候 VSCode 的版本是 Version 1.29.1 (1.29.1) ，更新日志在[这里](https://code.visualstudio.com/updates/v1_29) 。VSCode 三年来的发展我没有过多去了解，但是看更新日志，基本上是每月一更新，很是给力。\n\n我也是第一次使用 VSCode ，在写本文的时候所做的定位是尝尝鲜，是抱着试试的心态，很多地方也没有去深入的了解，所以本篇文章就仅仅从以下两个方面出发，简单讲一下 VSCode 和 SourceKit-LSP 的集合：\n\n1. VSCode 的配置和 extensions 的安装\n2. SourceKit-LSP 的安装和 Swift 的编译运行\n\n## VSCode 的配置与扩展\n\n先对 VSCode 做一个大致的了解，官方文档中有几个[介绍视频](https://code.visualstudio.com/docs/getstarted/introvideos)可以看看，只是挂在 YouTube 上的，需要科学上网。\n\n### Settings\n\nVSCode 在实现用户自定义上真的是做了很多的功夫，基本能想到的东西都有一个配置项可供用户自定义设置。\n\n安装完 VSCode 后，通过 `⌘+,` 调出 Settings 界面，如下图所示：\n\n![Screen Shot 2018-11-16 at 11.35.28 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/vr8t4.png)\n\n但是我建议，还是通过直接修改配置文件 `Settings.json` 的方式来更改配置。配置涉及方方面面，且对应的，还有全局配置和工作区( Workspace )的配置。\n\n- **User Setting** - 存放在：`~/Library/Application Support/Code/User/` ，是全局配置，影响所有打开的 VSCode 的窗口。\n- **Workspace Settings** - 存放在工作区的 `.vscode` 文件夹中。仅影响当前工作区，会覆盖 User Setting 中存在的项，用于不同机器间的共享，可以配置项目使用的编译器版本，如 Python2 、Python3 等。\n\n通过上图右上角 `···` 按钮即可查看修改 `Settings.json` 文件：\n![Screen Shot 2018-11-16 at 11.47.17 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/5xxac.png)\n\n左侧是默认配置，右侧是用户自定义配置。通过修改键值对的方式实时更改 VSCode 。上图是我自己的一些配置：sidebar 的位置在左侧，activityBar 显示。我用习惯了 Xcode ，用不习惯类似于 IDEA 的 Tabs ，所以关闭 Tabs 和 Preview 功能。主题用 Horizon，并自己做了一些修改，还改了字体字号和文件icon。配置了 Python3 的解释器的地址。还有很多的配置可以自定义，具体可以阅读 [配置](https://code.visualstudio.com/docs/getstarted/settings) ，就不多赘述了。\n\n### extension\n\n安装扩展十分简单，通过快捷键 `⌘+⇧+x` 可以唤出搜索安装界面。搜索想要的 extension 就可以安装了，**Install** 等待安装完成后 **Reload** 重新加载 extension 就可以了。\n\n搜索可以使用特定的 filter ，有 `@buildin` 、`@installed` 、`@outdated` 、`@recommended` ，各自表示 VSCode 自带，已安装，过期的，建议安装的。还可以通过 `@category` 来搜索指定类别的 extension 。\n\n安装的 extension 默认是自动更新的，如果不想要自动更新，可以在配置文件中修改配置： `extensions.autoUpdatesetting` 的值为 `false` 。设置 `extensions.autoCheckUpdates`的值可以关闭 extension 的自动检查更新。\n\n更多关于 extension 的说明，请看 [这里](https://code.visualstudio.com/docs/editor/extension-gallery)。\n\n为了接下来的工作，我们要安装的扩展如下：\n\n![Screen Shot 2018-11-19 at 2.44.33 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/prq7v.png)\n\n- SourceKit-LSP : 对 Swift 的支持\n- file-icon、Horizon Theme : VSCode 的一些主题配置\n- C/C++ 、Python : 本文不会提及，有需要进行 C/C++ 或 Python 可以安装，Python 在官方文档中还有专门的[介绍](https://code.visualstudio.com/docs/python/python-tutorial)。\n\n## SourceKit-LSP 和 Swift \n\n[LSP](https://microsoft.github.io/language-server-protocol/) 是 Language Server Protocol 的简称，是微软开源的一套用于代码自动完成、跳转到定义、hover 显示文档等功能的协议，被广泛应用于各种 IDE 中，实现了这套协议，可以在 VSCode 等 IDE 中使用上述的特性，给编码过程带来极大的便利。\n\n### SourceKit-LSP\n\n[SourceKit-LSP(以下简称SLSP)](https://github.com/apple/sourcekit-lsp) 就是 LSP 的一套实现，提供对 Swift 的支持。在安装 VSCode Extension 的时候，我们可以发现，其实已经有很多 Swift 的扩展可供使用，但是使用时却不能像 Xcode 一般便利，没有跳转到定义、显示文档之类的功能。所以，SLSP 应运而生。\n\n#### 安装和配置\n\n> SourceKit-LSP is under heavy development! The best way to try it out is to build it from source. You will also need a Swift development toolchain and an editor that supports LSP.\n\n让我们跟着文档来，安装 SLSP 最好的方式是通过源码安装，这就需要我们的电脑有 Swift 的环境。像我们用 beta 版的 Xcode 要用新版本的 Swift 时要装 snapshot 一样，SLSP 依赖的 `sourcekitd` 和 `clangd` 是在 Swift 的 toolchain 运行时启动的。我在写这篇文章的时候用的 snapshot 是 [swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a](https://swift.org/download/#snapshots) 。\n\n下载下来的 pkg 安装后，Swift 的 snapshot 存放在 `/Library/Developer/Toolchains` 。\n\n进入 sourcekit-lsp 文件夹：\n\n```shell\ncd <path_to_sourcekit_lsp>\nswift build\n```\n\n这里 `build` 的时候有可能会有这样的问题出现：\n\n```shell\nsourcekit-lsp' requires a minimum Swift tools version of 4.2.0 (currently 4.0.0)\n```\n\n看出错信息，是 Swift 的版本太低，我试过将 Swift 的版本更改为 snapshot 的版本（打开终端，更改 `TOOLCHAINS` 的值）：\n\n```shell\n# 使用 xcrun --find swift ，可以看到当前是使用 Xcode 中的 swift\n~ xcrun --find swift\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift\n# 设置 TOOLCHAINS 环境变量\n~ export TOOLCHAINS=swift\n# 使用 xcrun --find swift ，已经变成最后安装的 snapshot 版本\n~ xcrun --find swift\n/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain/usr/bin/swift\n```\n\n会出现下面这个问题：\n\n```shell\n<unknown>:0: error: Swift does not support the SDK 'MacOSX10.13.sdk'\n```\n\nGoogle 了一下，参考[这里](https://forums.swift.org/t/error-building-swift-swift-does-not-support-the-sdk-macosx10-13-sdk/13701)。可能是 Command Line Tools 的版本不对应所致，于是我安装了 `Command_Line_Tools_macOS_10.14_for_Xcode_10.1.dmg` 。`xcode-select -s` 选择安装的 command line tools 之后以为就可以了，没想到还是有问题：\n\n```shell\n~ sudo xcode-select -s /Library/Developer/CommandLineTools\n~ swift build\nerror: terminated(72): xcrun --sdk macosx --find xctest output:\n```\n\n找不到 macOS 的 SDK ...\n\n没有找到最好的解决方式，无奈之下，只能安装 Xcode 10 ，让 Xcode 10 帮助我们设置一系列的环境变量、SDK等。编译 SourceKit-LSP 只兼容 Xcode 10 这种一刀斩的做法，还真是苹果一贯任性的作风。（这肯定不是唯一的解决方法，以后有好的解决方法会回来补充）\n\n#### VSCode Extension\n\n好了，编译完 sourcekit-lsp 后，就要安装 VSCode extension 了，SourceKit-LSP 已经做好了对 VSCode 和 Sublime Text 的支持，直接执行命令就可以了（需要 npm ）：\n\n```shell\n# in sourcekit-lsp\ncd Editors/vscode\nnpm run createDevPackage\n```\n\n打包完成了，就可以使用 VSCode 的 `code` 命令进行安装了。\n\n```shell\n# in sourcekit-lsp/Editors/vscode\ncode --install-extension out/sourcekit-lsp-vscode-dev.vsix\n```\n\n打开 VSCode ，配置也很简单，SLSP 就两个配置项，分别为：\n\n1. `sourcekit-lsp.serverPath` - 指定 soursekit-lsp 位置的完整路径。\n\n2. `sourcekit-lsp.toolchainPath` - 指定 Swift snapshot 的位置。\n\n   Swift snapshot 的路径我们可以用一个变量来存储：\n\n   ```shell\n   export SOURCEKIT_TOOLCHAIN_PATH=/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain\n   ```\n\n添加在全局配置 `settings.json` 或工作区配置 `.vscode/settings.json` 即可，如下：\n\n\n\n\n\n### Code some swift\n\n\n\n## 总结\n\nSourceKit-LSP 的出世可以让我们在其他支持 LSP 的 IDE 上更友好地进行 Swift 代码的编写，用于跨平台编码库文件是挺不错，但用来写应用感觉还是有点力不从心。\n\n总的来说，不同的场景运用不同的编译器，来实现不同的需求，比如在 Linux 上写 Swift 等等，VSCode + SLSP 还是值得被关注的。\n\n## 参考资料\n\n[1.VSCode docs](https://code.visualstudio.com/docs)\n\n[2.LSP](https://microsoft.github.io/language-server-protocol/)\n\n[3.Sourcekit-LSP](https://github.com/apple/sourcekit-lsp)\n\n[4.Using the Package Manager](https://swift.org/getting-started/#using-the-package-manager)","source":"_posts/VSCode+SLSP.md","raw":"---\ntitle: VSCode 和 SourceKit-LSP\ndate: 2018-11-19 20:56:06\ntags:\n- Swift\ntypora-copy-images-to: ipic\n---\n\n三年前 VSCode 诞生，它设计理念在我看来还是不错的，如今下载得到的 zip 也才 70M 不到。看了文档知道其中只是内嵌了些 JavaScript 、 TypeScript 等少数语言的支持。用户可以根据需要，通过安装 extension 来实现自定义功能的 IDE 。\n\n但用 VSCode 来写 Swift 一直以来都不是很友好，知道最近 SourceKit-LSP 开源，就打算来试试这个被 MS 捧在掌心的 IDE 。\n\n<!--more-->\n\n## 本文大纲\n\n写这篇文章的时候 VSCode 的版本是 Version 1.29.1 (1.29.1) ，更新日志在[这里](https://code.visualstudio.com/updates/v1_29) 。VSCode 三年来的发展我没有过多去了解，但是看更新日志，基本上是每月一更新，很是给力。\n\n我也是第一次使用 VSCode ，在写本文的时候所做的定位是尝尝鲜，是抱着试试的心态，很多地方也没有去深入的了解，所以本篇文章就仅仅从以下两个方面出发，简单讲一下 VSCode 和 SourceKit-LSP 的集合：\n\n1. VSCode 的配置和 extensions 的安装\n2. SourceKit-LSP 的安装和 Swift 的编译运行\n\n## VSCode 的配置与扩展\n\n先对 VSCode 做一个大致的了解，官方文档中有几个[介绍视频](https://code.visualstudio.com/docs/getstarted/introvideos)可以看看，只是挂在 YouTube 上的，需要科学上网。\n\n### Settings\n\nVSCode 在实现用户自定义上真的是做了很多的功夫，基本能想到的东西都有一个配置项可供用户自定义设置。\n\n安装完 VSCode 后，通过 `⌘+,` 调出 Settings 界面，如下图所示：\n\n![Screen Shot 2018-11-16 at 11.35.28 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/vr8t4.png)\n\n但是我建议，还是通过直接修改配置文件 `Settings.json` 的方式来更改配置。配置涉及方方面面，且对应的，还有全局配置和工作区( Workspace )的配置。\n\n- **User Setting** - 存放在：`~/Library/Application Support/Code/User/` ，是全局配置，影响所有打开的 VSCode 的窗口。\n- **Workspace Settings** - 存放在工作区的 `.vscode` 文件夹中。仅影响当前工作区，会覆盖 User Setting 中存在的项，用于不同机器间的共享，可以配置项目使用的编译器版本，如 Python2 、Python3 等。\n\n通过上图右上角 `···` 按钮即可查看修改 `Settings.json` 文件：\n![Screen Shot 2018-11-16 at 11.47.17 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/5xxac.png)\n\n左侧是默认配置，右侧是用户自定义配置。通过修改键值对的方式实时更改 VSCode 。上图是我自己的一些配置：sidebar 的位置在左侧，activityBar 显示。我用习惯了 Xcode ，用不习惯类似于 IDEA 的 Tabs ，所以关闭 Tabs 和 Preview 功能。主题用 Horizon，并自己做了一些修改，还改了字体字号和文件icon。配置了 Python3 的解释器的地址。还有很多的配置可以自定义，具体可以阅读 [配置](https://code.visualstudio.com/docs/getstarted/settings) ，就不多赘述了。\n\n### extension\n\n安装扩展十分简单，通过快捷键 `⌘+⇧+x` 可以唤出搜索安装界面。搜索想要的 extension 就可以安装了，**Install** 等待安装完成后 **Reload** 重新加载 extension 就可以了。\n\n搜索可以使用特定的 filter ，有 `@buildin` 、`@installed` 、`@outdated` 、`@recommended` ，各自表示 VSCode 自带，已安装，过期的，建议安装的。还可以通过 `@category` 来搜索指定类别的 extension 。\n\n安装的 extension 默认是自动更新的，如果不想要自动更新，可以在配置文件中修改配置： `extensions.autoUpdatesetting` 的值为 `false` 。设置 `extensions.autoCheckUpdates`的值可以关闭 extension 的自动检查更新。\n\n更多关于 extension 的说明，请看 [这里](https://code.visualstudio.com/docs/editor/extension-gallery)。\n\n为了接下来的工作，我们要安装的扩展如下：\n\n![Screen Shot 2018-11-19 at 2.44.33 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/prq7v.png)\n\n- SourceKit-LSP : 对 Swift 的支持\n- file-icon、Horizon Theme : VSCode 的一些主题配置\n- C/C++ 、Python : 本文不会提及，有需要进行 C/C++ 或 Python 可以安装，Python 在官方文档中还有专门的[介绍](https://code.visualstudio.com/docs/python/python-tutorial)。\n\n## SourceKit-LSP 和 Swift \n\n[LSP](https://microsoft.github.io/language-server-protocol/) 是 Language Server Protocol 的简称，是微软开源的一套用于代码自动完成、跳转到定义、hover 显示文档等功能的协议，被广泛应用于各种 IDE 中，实现了这套协议，可以在 VSCode 等 IDE 中使用上述的特性，给编码过程带来极大的便利。\n\n### SourceKit-LSP\n\n[SourceKit-LSP(以下简称SLSP)](https://github.com/apple/sourcekit-lsp) 就是 LSP 的一套实现，提供对 Swift 的支持。在安装 VSCode Extension 的时候，我们可以发现，其实已经有很多 Swift 的扩展可供使用，但是使用时却不能像 Xcode 一般便利，没有跳转到定义、显示文档之类的功能。所以，SLSP 应运而生。\n\n#### 安装和配置\n\n> SourceKit-LSP is under heavy development! The best way to try it out is to build it from source. You will also need a Swift development toolchain and an editor that supports LSP.\n\n让我们跟着文档来，安装 SLSP 最好的方式是通过源码安装，这就需要我们的电脑有 Swift 的环境。像我们用 beta 版的 Xcode 要用新版本的 Swift 时要装 snapshot 一样，SLSP 依赖的 `sourcekitd` 和 `clangd` 是在 Swift 的 toolchain 运行时启动的。我在写这篇文章的时候用的 snapshot 是 [swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a](https://swift.org/download/#snapshots) 。\n\n下载下来的 pkg 安装后，Swift 的 snapshot 存放在 `/Library/Developer/Toolchains` 。\n\n进入 sourcekit-lsp 文件夹：\n\n```shell\ncd <path_to_sourcekit_lsp>\nswift build\n```\n\n这里 `build` 的时候有可能会有这样的问题出现：\n\n```shell\nsourcekit-lsp' requires a minimum Swift tools version of 4.2.0 (currently 4.0.0)\n```\n\n看出错信息，是 Swift 的版本太低，我试过将 Swift 的版本更改为 snapshot 的版本（打开终端，更改 `TOOLCHAINS` 的值）：\n\n```shell\n# 使用 xcrun --find swift ，可以看到当前是使用 Xcode 中的 swift\n~ xcrun --find swift\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift\n# 设置 TOOLCHAINS 环境变量\n~ export TOOLCHAINS=swift\n# 使用 xcrun --find swift ，已经变成最后安装的 snapshot 版本\n~ xcrun --find swift\n/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain/usr/bin/swift\n```\n\n会出现下面这个问题：\n\n```shell\n<unknown>:0: error: Swift does not support the SDK 'MacOSX10.13.sdk'\n```\n\nGoogle 了一下，参考[这里](https://forums.swift.org/t/error-building-swift-swift-does-not-support-the-sdk-macosx10-13-sdk/13701)。可能是 Command Line Tools 的版本不对应所致，于是我安装了 `Command_Line_Tools_macOS_10.14_for_Xcode_10.1.dmg` 。`xcode-select -s` 选择安装的 command line tools 之后以为就可以了，没想到还是有问题：\n\n```shell\n~ sudo xcode-select -s /Library/Developer/CommandLineTools\n~ swift build\nerror: terminated(72): xcrun --sdk macosx --find xctest output:\n```\n\n找不到 macOS 的 SDK ...\n\n没有找到最好的解决方式，无奈之下，只能安装 Xcode 10 ，让 Xcode 10 帮助我们设置一系列的环境变量、SDK等。编译 SourceKit-LSP 只兼容 Xcode 10 这种一刀斩的做法，还真是苹果一贯任性的作风。（这肯定不是唯一的解决方法，以后有好的解决方法会回来补充）\n\n#### VSCode Extension\n\n好了，编译完 sourcekit-lsp 后，就要安装 VSCode extension 了，SourceKit-LSP 已经做好了对 VSCode 和 Sublime Text 的支持，直接执行命令就可以了（需要 npm ）：\n\n```shell\n# in sourcekit-lsp\ncd Editors/vscode\nnpm run createDevPackage\n```\n\n打包完成了，就可以使用 VSCode 的 `code` 命令进行安装了。\n\n```shell\n# in sourcekit-lsp/Editors/vscode\ncode --install-extension out/sourcekit-lsp-vscode-dev.vsix\n```\n\n打开 VSCode ，配置也很简单，SLSP 就两个配置项，分别为：\n\n1. `sourcekit-lsp.serverPath` - 指定 soursekit-lsp 位置的完整路径。\n\n2. `sourcekit-lsp.toolchainPath` - 指定 Swift snapshot 的位置。\n\n   Swift snapshot 的路径我们可以用一个变量来存储：\n\n   ```shell\n   export SOURCEKIT_TOOLCHAIN_PATH=/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain\n   ```\n\n添加在全局配置 `settings.json` 或工作区配置 `.vscode/settings.json` 即可，如下：\n\n\n\n\n\n### Code some swift\n\n\n\n## 总结\n\nSourceKit-LSP 的出世可以让我们在其他支持 LSP 的 IDE 上更友好地进行 Swift 代码的编写，用于跨平台编码库文件是挺不错，但用来写应用感觉还是有点力不从心。\n\n总的来说，不同的场景运用不同的编译器，来实现不同的需求，比如在 Linux 上写 Swift 等等，VSCode + SLSP 还是值得被关注的。\n\n## 参考资料\n\n[1.VSCode docs](https://code.visualstudio.com/docs)\n\n[2.LSP](https://microsoft.github.io/language-server-protocol/)\n\n[3.Sourcekit-LSP](https://github.com/apple/sourcekit-lsp)\n\n[4.Using the Package Manager](https://swift.org/getting-started/#using-the-package-manager)","slug":"VSCode+SLSP","published":1,"updated":"2018-11-19T07:10:54.477Z","_id":"cjonym6df0002qu0xq0h0ie39","comments":1,"layout":"post","photos":[],"link":"","content":"<p>三年前 VSCode 诞生，它设计理念在我看来还是不错的，如今下载得到的 zip 也才 70M 不到。看了文档知道其中只是内嵌了些 JavaScript 、 TypeScript 等少数语言的支持。用户可以根据需要，通过安装 extension 来实现自定义功能的 IDE 。</p>\n<p>但用 VSCode 来写 Swift 一直以来都不是很友好，知道最近 SourceKit-LSP 开源，就打算来试试这个被 MS 捧在掌心的 IDE 。</p>\n<a id=\"more\"></a>\n<h2 id=\"本文大纲\"><a href=\"#本文大纲\" class=\"headerlink\" title=\"本文大纲\"></a>本文大纲</h2><p>写这篇文章的时候 VSCode 的版本是 Version 1.29.1 (1.29.1) ，更新日志在<a href=\"https://code.visualstudio.com/updates/v1_29\" target=\"_blank\" rel=\"external\">这里</a> 。VSCode 三年来的发展我没有过多去了解，但是看更新日志，基本上是每月一更新，很是给力。</p>\n<p>我也是第一次使用 VSCode ，在写本文的时候所做的定位是尝尝鲜，是抱着试试的心态，很多地方也没有去深入的了解，所以本篇文章就仅仅从以下两个方面出发，简单讲一下 VSCode 和 SourceKit-LSP 的集合：</p>\n<ol>\n<li>VSCode 的配置和 extensions 的安装</li>\n<li>SourceKit-LSP 的安装和 Swift 的编译运行</li>\n</ol>\n<h2 id=\"VSCode-的配置与扩展\"><a href=\"#VSCode-的配置与扩展\" class=\"headerlink\" title=\"VSCode 的配置与扩展\"></a>VSCode 的配置与扩展</h2><p>先对 VSCode 做一个大致的了解，官方文档中有几个<a href=\"https://code.visualstudio.com/docs/getstarted/introvideos\" target=\"_blank\" rel=\"external\">介绍视频</a>可以看看，只是挂在 YouTube 上的，需要科学上网。</p>\n<h3 id=\"Settings\"><a href=\"#Settings\" class=\"headerlink\" title=\"Settings\"></a>Settings</h3><p>VSCode 在实现用户自定义上真的是做了很多的功夫，基本能想到的东西都有一个配置项可供用户自定义设置。</p>\n<p>安装完 VSCode 后，通过 <code>⌘+,</code> 调出 Settings 界面，如下图所示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/vr8t4.png\" alt=\"Screen Shot 2018-11-16 at 11.35.28 AM\"></p>\n<p>但是我建议，还是通过直接修改配置文件 <code>Settings.json</code> 的方式来更改配置。配置涉及方方面面，且对应的，还有全局配置和工作区( Workspace )的配置。</p>\n<ul>\n<li><strong>User Setting</strong> - 存放在：<code>~/Library/Application Support/Code/User/</code> ，是全局配置，影响所有打开的 VSCode 的窗口。</li>\n<li><strong>Workspace Settings</strong> - 存放在工作区的 <code>.vscode</code> 文件夹中。仅影响当前工作区，会覆盖 User Setting 中存在的项，用于不同机器间的共享，可以配置项目使用的编译器版本，如 Python2 、Python3 等。</li>\n</ul>\n<p>通过上图右上角 <code>···</code> 按钮即可查看修改 <code>Settings.json</code> 文件：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/5xxac.png\" alt=\"Screen Shot 2018-11-16 at 11.47.17 AM\"></p>\n<p>左侧是默认配置，右侧是用户自定义配置。通过修改键值对的方式实时更改 VSCode 。上图是我自己的一些配置：sidebar 的位置在左侧，activityBar 显示。我用习惯了 Xcode ，用不习惯类似于 IDEA 的 Tabs ，所以关闭 Tabs 和 Preview 功能。主题用 Horizon，并自己做了一些修改，还改了字体字号和文件icon。配置了 Python3 的解释器的地址。还有很多的配置可以自定义，具体可以阅读 <a href=\"https://code.visualstudio.com/docs/getstarted/settings\" target=\"_blank\" rel=\"external\">配置</a> ，就不多赘述了。</p>\n<h3 id=\"extension\"><a href=\"#extension\" class=\"headerlink\" title=\"extension\"></a>extension</h3><p>安装扩展十分简单，通过快捷键 <code>⌘+⇧+x</code> 可以唤出搜索安装界面。搜索想要的 extension 就可以安装了，<strong>Install</strong> 等待安装完成后 <strong>Reload</strong> 重新加载 extension 就可以了。</p>\n<p>搜索可以使用特定的 filter ，有 <code>@buildin</code> 、<code>@installed</code> 、<code>@outdated</code> 、<code>@recommended</code> ，各自表示 VSCode 自带，已安装，过期的，建议安装的。还可以通过 <code>@category</code> 来搜索指定类别的 extension 。</p>\n<p>安装的 extension 默认是自动更新的，如果不想要自动更新，可以在配置文件中修改配置： <code>extensions.autoUpdatesetting</code> 的值为 <code>false</code> 。设置 <code>extensions.autoCheckUpdates</code>的值可以关闭 extension 的自动检查更新。</p>\n<p>更多关于 extension 的说明，请看 <a href=\"https://code.visualstudio.com/docs/editor/extension-gallery\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>为了接下来的工作，我们要安装的扩展如下：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/prq7v.png\" alt=\"Screen Shot 2018-11-19 at 2.44.33 PM\"></p>\n<ul>\n<li>SourceKit-LSP : 对 Swift 的支持</li>\n<li>file-icon、Horizon Theme : VSCode 的一些主题配置</li>\n<li>C/C++ 、Python : 本文不会提及，有需要进行 C/C++ 或 Python 可以安装，Python 在官方文档中还有专门的<a href=\"https://code.visualstudio.com/docs/python/python-tutorial\" target=\"_blank\" rel=\"external\">介绍</a>。</li>\n</ul>\n<h2 id=\"SourceKit-LSP-和-Swift\"><a href=\"#SourceKit-LSP-和-Swift\" class=\"headerlink\" title=\"SourceKit-LSP 和 Swift\"></a>SourceKit-LSP 和 Swift</h2><p><a href=\"https://microsoft.github.io/language-server-protocol/\" target=\"_blank\" rel=\"external\">LSP</a> 是 Language Server Protocol 的简称，是微软开源的一套用于代码自动完成、跳转到定义、hover 显示文档等功能的协议，被广泛应用于各种 IDE 中，实现了这套协议，可以在 VSCode 等 IDE 中使用上述的特性，给编码过程带来极大的便利。</p>\n<h3 id=\"SourceKit-LSP\"><a href=\"#SourceKit-LSP\" class=\"headerlink\" title=\"SourceKit-LSP\"></a>SourceKit-LSP</h3><p><a href=\"https://github.com/apple/sourcekit-lsp\" target=\"_blank\" rel=\"external\">SourceKit-LSP(以下简称SLSP)</a> 就是 LSP 的一套实现，提供对 Swift 的支持。在安装 VSCode Extension 的时候，我们可以发现，其实已经有很多 Swift 的扩展可供使用，但是使用时却不能像 Xcode 一般便利，没有跳转到定义、显示文档之类的功能。所以，SLSP 应运而生。</p>\n<h4 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h4><blockquote>\n<p>SourceKit-LSP is under heavy development! The best way to try it out is to build it from source. You will also need a Swift development toolchain and an editor that supports LSP.</p>\n</blockquote>\n<p>让我们跟着文档来，安装 SLSP 最好的方式是通过源码安装，这就需要我们的电脑有 Swift 的环境。像我们用 beta 版的 Xcode 要用新版本的 Swift 时要装 snapshot 一样，SLSP 依赖的 <code>sourcekitd</code> 和 <code>clangd</code> 是在 Swift 的 toolchain 运行时启动的。我在写这篇文章的时候用的 snapshot 是 <a href=\"https://swift.org/download/#snapshots\" target=\"_blank\" rel=\"external\">swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a</a> 。</p>\n<p>下载下来的 pkg 安装后，Swift 的 snapshot 存放在 <code>/Library/Developer/Toolchains</code> 。</p>\n<p>进入 sourcekit-lsp 文件夹：</p>\n<pre><code class=\"shell\">cd &lt;path_to_sourcekit_lsp&gt;\nswift build\n</code></pre>\n<p>这里 <code>build</code> 的时候有可能会有这样的问题出现：</p>\n<pre><code class=\"shell\">sourcekit-lsp&#39; requires a minimum Swift tools version of 4.2.0 (currently 4.0.0)\n</code></pre>\n<p>看出错信息，是 Swift 的版本太低，我试过将 Swift 的版本更改为 snapshot 的版本（打开终端，更改 <code>TOOLCHAINS</code> 的值）：</p>\n<pre><code class=\"shell\"># 使用 xcrun --find swift ，可以看到当前是使用 Xcode 中的 swift\n~ xcrun --find swift\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift\n# 设置 TOOLCHAINS 环境变量\n~ export TOOLCHAINS=swift\n# 使用 xcrun --find swift ，已经变成最后安装的 snapshot 版本\n~ xcrun --find swift\n/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain/usr/bin/swift\n</code></pre>\n<p>会出现下面这个问题：</p>\n<pre><code class=\"shell\">&lt;unknown&gt;:0: error: Swift does not support the SDK &#39;MacOSX10.13.sdk&#39;\n</code></pre>\n<p>Google 了一下，参考<a href=\"https://forums.swift.org/t/error-building-swift-swift-does-not-support-the-sdk-macosx10-13-sdk/13701\" target=\"_blank\" rel=\"external\">这里</a>。可能是 Command Line Tools 的版本不对应所致，于是我安装了 <code>Command_Line_Tools_macOS_10.14_for_Xcode_10.1.dmg</code> 。<code>xcode-select -s</code> 选择安装的 command line tools 之后以为就可以了，没想到还是有问题：</p>\n<pre><code class=\"shell\">~ sudo xcode-select -s /Library/Developer/CommandLineTools\n~ swift build\nerror: terminated(72): xcrun --sdk macosx --find xctest output:\n</code></pre>\n<p>找不到 macOS 的 SDK …</p>\n<p>没有找到最好的解决方式，无奈之下，只能安装 Xcode 10 ，让 Xcode 10 帮助我们设置一系列的环境变量、SDK等。编译 SourceKit-LSP 只兼容 Xcode 10 这种一刀斩的做法，还真是苹果一贯任性的作风。（这肯定不是唯一的解决方法，以后有好的解决方法会回来补充）</p>\n<h4 id=\"VSCode-Extension\"><a href=\"#VSCode-Extension\" class=\"headerlink\" title=\"VSCode Extension\"></a>VSCode Extension</h4><p>好了，编译完 sourcekit-lsp 后，就要安装 VSCode extension 了，SourceKit-LSP 已经做好了对 VSCode 和 Sublime Text 的支持，直接执行命令就可以了（需要 npm ）：</p>\n<pre><code class=\"shell\"># in sourcekit-lsp\ncd Editors/vscode\nnpm run createDevPackage\n</code></pre>\n<p>打包完成了，就可以使用 VSCode 的 <code>code</code> 命令进行安装了。</p>\n<pre><code class=\"shell\"># in sourcekit-lsp/Editors/vscode\ncode --install-extension out/sourcekit-lsp-vscode-dev.vsix\n</code></pre>\n<p>打开 VSCode ，配置也很简单，SLSP 就两个配置项，分别为：</p>\n<ol>\n<li><p><code>sourcekit-lsp.serverPath</code> - 指定 soursekit-lsp 位置的完整路径。</p>\n</li>\n<li><p><code>sourcekit-lsp.toolchainPath</code> - 指定 Swift snapshot 的位置。</p>\n<p>Swift snapshot 的路径我们可以用一个变量来存储：</p>\n<pre><code class=\"shell\">export SOURCEKIT_TOOLCHAIN_PATH=/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain\n</code></pre>\n</li>\n</ol>\n<p>添加在全局配置 <code>settings.json</code> 或工作区配置 <code>.vscode/settings.json</code> 即可，如下：</p>\n<h3 id=\"Code-some-swift\"><a href=\"#Code-some-swift\" class=\"headerlink\" title=\"Code some swift\"></a>Code some swift</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>SourceKit-LSP 的出世可以让我们在其他支持 LSP 的 IDE 上更友好地进行 Swift 代码的编写，用于跨平台编码库文件是挺不错，但用来写应用感觉还是有点力不从心。</p>\n<p>总的来说，不同的场景运用不同的编译器，来实现不同的需求，比如在 Linux 上写 Swift 等等，VSCode + SLSP 还是值得被关注的。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://code.visualstudio.com/docs\" target=\"_blank\" rel=\"external\">1.VSCode docs</a></p>\n<p><a href=\"https://microsoft.github.io/language-server-protocol/\" target=\"_blank\" rel=\"external\">2.LSP</a></p>\n<p><a href=\"https://github.com/apple/sourcekit-lsp\" target=\"_blank\" rel=\"external\">3.Sourcekit-LSP</a></p>\n<p><a href=\"https://swift.org/getting-started/#using-the-package-manager\" target=\"_blank\" rel=\"external\">4.Using the Package Manager</a></p>\n","excerpt":"<p>三年前 VSCode 诞生，它设计理念在我看来还是不错的，如今下载得到的 zip 也才 70M 不到。看了文档知道其中只是内嵌了些 JavaScript 、 TypeScript 等少数语言的支持。用户可以根据需要，通过安装 extension 来实现自定义功能的 IDE 。</p>\n<p>但用 VSCode 来写 Swift 一直以来都不是很友好，知道最近 SourceKit-LSP 开源，就打算来试试这个被 MS 捧在掌心的 IDE 。</p>","more":"<h2 id=\"本文大纲\"><a href=\"#本文大纲\" class=\"headerlink\" title=\"本文大纲\"></a>本文大纲</h2><p>写这篇文章的时候 VSCode 的版本是 Version 1.29.1 (1.29.1) ，更新日志在<a href=\"https://code.visualstudio.com/updates/v1_29\">这里</a> 。VSCode 三年来的发展我没有过多去了解，但是看更新日志，基本上是每月一更新，很是给力。</p>\n<p>我也是第一次使用 VSCode ，在写本文的时候所做的定位是尝尝鲜，是抱着试试的心态，很多地方也没有去深入的了解，所以本篇文章就仅仅从以下两个方面出发，简单讲一下 VSCode 和 SourceKit-LSP 的集合：</p>\n<ol>\n<li>VSCode 的配置和 extensions 的安装</li>\n<li>SourceKit-LSP 的安装和 Swift 的编译运行</li>\n</ol>\n<h2 id=\"VSCode-的配置与扩展\"><a href=\"#VSCode-的配置与扩展\" class=\"headerlink\" title=\"VSCode 的配置与扩展\"></a>VSCode 的配置与扩展</h2><p>先对 VSCode 做一个大致的了解，官方文档中有几个<a href=\"https://code.visualstudio.com/docs/getstarted/introvideos\">介绍视频</a>可以看看，只是挂在 YouTube 上的，需要科学上网。</p>\n<h3 id=\"Settings\"><a href=\"#Settings\" class=\"headerlink\" title=\"Settings\"></a>Settings</h3><p>VSCode 在实现用户自定义上真的是做了很多的功夫，基本能想到的东西都有一个配置项可供用户自定义设置。</p>\n<p>安装完 VSCode 后，通过 <code>⌘+,</code> 调出 Settings 界面，如下图所示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/vr8t4.png\" alt=\"Screen Shot 2018-11-16 at 11.35.28 AM\"></p>\n<p>但是我建议，还是通过直接修改配置文件 <code>Settings.json</code> 的方式来更改配置。配置涉及方方面面，且对应的，还有全局配置和工作区( Workspace )的配置。</p>\n<ul>\n<li><strong>User Setting</strong> - 存放在：<code>~/Library/Application Support/Code/User/</code> ，是全局配置，影响所有打开的 VSCode 的窗口。</li>\n<li><strong>Workspace Settings</strong> - 存放在工作区的 <code>.vscode</code> 文件夹中。仅影响当前工作区，会覆盖 User Setting 中存在的项，用于不同机器间的共享，可以配置项目使用的编译器版本，如 Python2 、Python3 等。</li>\n</ul>\n<p>通过上图右上角 <code>···</code> 按钮即可查看修改 <code>Settings.json</code> 文件：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/5xxac.png\" alt=\"Screen Shot 2018-11-16 at 11.47.17 AM\"></p>\n<p>左侧是默认配置，右侧是用户自定义配置。通过修改键值对的方式实时更改 VSCode 。上图是我自己的一些配置：sidebar 的位置在左侧，activityBar 显示。我用习惯了 Xcode ，用不习惯类似于 IDEA 的 Tabs ，所以关闭 Tabs 和 Preview 功能。主题用 Horizon，并自己做了一些修改，还改了字体字号和文件icon。配置了 Python3 的解释器的地址。还有很多的配置可以自定义，具体可以阅读 <a href=\"https://code.visualstudio.com/docs/getstarted/settings\">配置</a> ，就不多赘述了。</p>\n<h3 id=\"extension\"><a href=\"#extension\" class=\"headerlink\" title=\"extension\"></a>extension</h3><p>安装扩展十分简单，通过快捷键 <code>⌘+⇧+x</code> 可以唤出搜索安装界面。搜索想要的 extension 就可以安装了，<strong>Install</strong> 等待安装完成后 <strong>Reload</strong> 重新加载 extension 就可以了。</p>\n<p>搜索可以使用特定的 filter ，有 <code>@buildin</code> 、<code>@installed</code> 、<code>@outdated</code> 、<code>@recommended</code> ，各自表示 VSCode 自带，已安装，过期的，建议安装的。还可以通过 <code>@category</code> 来搜索指定类别的 extension 。</p>\n<p>安装的 extension 默认是自动更新的，如果不想要自动更新，可以在配置文件中修改配置： <code>extensions.autoUpdatesetting</code> 的值为 <code>false</code> 。设置 <code>extensions.autoCheckUpdates</code>的值可以关闭 extension 的自动检查更新。</p>\n<p>更多关于 extension 的说明，请看 <a href=\"https://code.visualstudio.com/docs/editor/extension-gallery\">这里</a>。</p>\n<p>为了接下来的工作，我们要安装的扩展如下：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/prq7v.png\" alt=\"Screen Shot 2018-11-19 at 2.44.33 PM\"></p>\n<ul>\n<li>SourceKit-LSP : 对 Swift 的支持</li>\n<li>file-icon、Horizon Theme : VSCode 的一些主题配置</li>\n<li>C/C++ 、Python : 本文不会提及，有需要进行 C/C++ 或 Python 可以安装，Python 在官方文档中还有专门的<a href=\"https://code.visualstudio.com/docs/python/python-tutorial\">介绍</a>。</li>\n</ul>\n<h2 id=\"SourceKit-LSP-和-Swift\"><a href=\"#SourceKit-LSP-和-Swift\" class=\"headerlink\" title=\"SourceKit-LSP 和 Swift\"></a>SourceKit-LSP 和 Swift</h2><p><a href=\"https://microsoft.github.io/language-server-protocol/\">LSP</a> 是 Language Server Protocol 的简称，是微软开源的一套用于代码自动完成、跳转到定义、hover 显示文档等功能的协议，被广泛应用于各种 IDE 中，实现了这套协议，可以在 VSCode 等 IDE 中使用上述的特性，给编码过程带来极大的便利。</p>\n<h3 id=\"SourceKit-LSP\"><a href=\"#SourceKit-LSP\" class=\"headerlink\" title=\"SourceKit-LSP\"></a>SourceKit-LSP</h3><p><a href=\"https://github.com/apple/sourcekit-lsp\">SourceKit-LSP(以下简称SLSP)</a> 就是 LSP 的一套实现，提供对 Swift 的支持。在安装 VSCode Extension 的时候，我们可以发现，其实已经有很多 Swift 的扩展可供使用，但是使用时却不能像 Xcode 一般便利，没有跳转到定义、显示文档之类的功能。所以，SLSP 应运而生。</p>\n<h4 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h4><blockquote>\n<p>SourceKit-LSP is under heavy development! The best way to try it out is to build it from source. You will also need a Swift development toolchain and an editor that supports LSP.</p>\n</blockquote>\n<p>让我们跟着文档来，安装 SLSP 最好的方式是通过源码安装，这就需要我们的电脑有 Swift 的环境。像我们用 beta 版的 Xcode 要用新版本的 Swift 时要装 snapshot 一样，SLSP 依赖的 <code>sourcekitd</code> 和 <code>clangd</code> 是在 Swift 的 toolchain 运行时启动的。我在写这篇文章的时候用的 snapshot 是 <a href=\"https://swift.org/download/#snapshots\">swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a</a> 。</p>\n<p>下载下来的 pkg 安装后，Swift 的 snapshot 存放在 <code>/Library/Developer/Toolchains</code> 。</p>\n<p>进入 sourcekit-lsp 文件夹：</p>\n<pre><code class=\"shell\">cd &lt;path_to_sourcekit_lsp&gt;\nswift build\n</code></pre>\n<p>这里 <code>build</code> 的时候有可能会有这样的问题出现：</p>\n<pre><code class=\"shell\">sourcekit-lsp&#39; requires a minimum Swift tools version of 4.2.0 (currently 4.0.0)\n</code></pre>\n<p>看出错信息，是 Swift 的版本太低，我试过将 Swift 的版本更改为 snapshot 的版本（打开终端，更改 <code>TOOLCHAINS</code> 的值）：</p>\n<pre><code class=\"shell\"># 使用 xcrun --find swift ，可以看到当前是使用 Xcode 中的 swift\n~ xcrun --find swift\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift\n# 设置 TOOLCHAINS 环境变量\n~ export TOOLCHAINS=swift\n# 使用 xcrun --find swift ，已经变成最后安装的 snapshot 版本\n~ xcrun --find swift\n/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain/usr/bin/swift\n</code></pre>\n<p>会出现下面这个问题：</p>\n<pre><code class=\"shell\">&lt;unknown&gt;:0: error: Swift does not support the SDK &#39;MacOSX10.13.sdk&#39;\n</code></pre>\n<p>Google 了一下，参考<a href=\"https://forums.swift.org/t/error-building-swift-swift-does-not-support-the-sdk-macosx10-13-sdk/13701\">这里</a>。可能是 Command Line Tools 的版本不对应所致，于是我安装了 <code>Command_Line_Tools_macOS_10.14_for_Xcode_10.1.dmg</code> 。<code>xcode-select -s</code> 选择安装的 command line tools 之后以为就可以了，没想到还是有问题：</p>\n<pre><code class=\"shell\">~ sudo xcode-select -s /Library/Developer/CommandLineTools\n~ swift build\nerror: terminated(72): xcrun --sdk macosx --find xctest output:\n</code></pre>\n<p>找不到 macOS 的 SDK …</p>\n<p>没有找到最好的解决方式，无奈之下，只能安装 Xcode 10 ，让 Xcode 10 帮助我们设置一系列的环境变量、SDK等。编译 SourceKit-LSP 只兼容 Xcode 10 这种一刀斩的做法，还真是苹果一贯任性的作风。（这肯定不是唯一的解决方法，以后有好的解决方法会回来补充）</p>\n<h4 id=\"VSCode-Extension\"><a href=\"#VSCode-Extension\" class=\"headerlink\" title=\"VSCode Extension\"></a>VSCode Extension</h4><p>好了，编译完 sourcekit-lsp 后，就要安装 VSCode extension 了，SourceKit-LSP 已经做好了对 VSCode 和 Sublime Text 的支持，直接执行命令就可以了（需要 npm ）：</p>\n<pre><code class=\"shell\"># in sourcekit-lsp\ncd Editors/vscode\nnpm run createDevPackage\n</code></pre>\n<p>打包完成了，就可以使用 VSCode 的 <code>code</code> 命令进行安装了。</p>\n<pre><code class=\"shell\"># in sourcekit-lsp/Editors/vscode\ncode --install-extension out/sourcekit-lsp-vscode-dev.vsix\n</code></pre>\n<p>打开 VSCode ，配置也很简单，SLSP 就两个配置项，分别为：</p>\n<ol>\n<li><p><code>sourcekit-lsp.serverPath</code> - 指定 soursekit-lsp 位置的完整路径。</p>\n</li>\n<li><p><code>sourcekit-lsp.toolchainPath</code> - 指定 Swift snapshot 的位置。</p>\n<p>Swift snapshot 的路径我们可以用一个变量来存储：</p>\n<pre><code class=\"shell\">export SOURCEKIT_TOOLCHAIN_PATH=/Library/Developer/Toolchains/swift-DEVELOPMENT-SNAPSHOT-2018-11-01-a.xctoolchain\n</code></pre>\n</li>\n</ol>\n<p>添加在全局配置 <code>settings.json</code> 或工作区配置 <code>.vscode/settings.json</code> 即可，如下：</p>\n<h3 id=\"Code-some-swift\"><a href=\"#Code-some-swift\" class=\"headerlink\" title=\"Code some swift\"></a>Code some swift</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>SourceKit-LSP 的出世可以让我们在其他支持 LSP 的 IDE 上更友好地进行 Swift 代码的编写，用于跨平台编码库文件是挺不错，但用来写应用感觉还是有点力不从心。</p>\n<p>总的来说，不同的场景运用不同的编译器，来实现不同的需求，比如在 Linux 上写 Swift 等等，VSCode + SLSP 还是值得被关注的。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://code.visualstudio.com/docs\">1.VSCode docs</a></p>\n<p><a href=\"https://microsoft.github.io/language-server-protocol/\">2.LSP</a></p>\n<p><a href=\"https://github.com/apple/sourcekit-lsp\">3.Sourcekit-LSP</a></p>\n<p><a href=\"https://swift.org/getting-started/#using-the-package-manager\">4.Using the Package Manager</a></p>"},{"title":"Jenkins密林探索","date":"2018-04-27T10:39:08.000Z","typora-copy-images-to":"ipic","_content":"\n说到持续集成，Jenkins 是用得比较多的。本文说明了我从安装到配置再到打包 ipa 文件，从手动打包到点击一下按钮自动生成 ipa 所做的事情。\n\n得益于 Jenkins ，让开发体验提升了不少。不多说，文内多图，来跟我一起密林探索吧 :]\n\n<!--more-->\n\n![Jenkins](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aohum.png)\n\n## Jenkins安装\n\n本文以 *Jenkins* 当前时间 **2018.03.27** 的最近 weekly 版本 *2.113* 来说明， Jenkins 是 Java web 项目，在使用上有 Java 环境的限制：**jdk1.8 以上**。\n\n对于 macOS10.9 和 10.10 来说，系统中自带有 jdk1.6 ，但这并不符合要求。而其他版本（ macOS10.11 以上）中貌似没有 jdk ，可以在命令行工具键入`java -version`来判断。\n\n若出现以下提示，则表示没有配置 Java 环境或系统中没有安装 jdk ：\n\n```Shell\nNo Java runtime present, requesting install.\n```\n\n若弹出安装对话框，点击 **『好』** 退出对话框。\n\n不然，定位到`/Library/Java/JavaVirtualMachines`中可查看是否存在 jdk 。\n\n如果都没有，或 jdk 版本不符，则需要重新安装。 macOS 的安装方式比较简单，在[Oracle的jdk下载地址](http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html)上下载 dmg 安装包，直接安装 jdk1.8 到系统中。然后修改`~/.bashrc`文件配置一系列的系统变量，如果使用`zsh`，则修改`~/.zshrc`。在文件末尾添加：\n\n```shell\n# 通常通过dmg安装的jdk都是在/Library/Java/JavaVirtualMachines/下，需根据实际情况对JAVA_HOME进行配置\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Content/Home\"\nexport CLASS_HOME=\"$JAVA_HOME/lib\"\nexport PATH=\".;$PATH:$JAVA_HOME/bin\"\n```\n\n然后重置一下配置：\n\n```shell\nsource ~/.bashrc\n```\n\n或者（使用`zsh`）\n\n```Shell\nsource ~/.zshrc\n```\n\n再次使用`java - version`验证是否安装成功（全文部分截图是我使用公司电脑安装 Jenkins 时截下来的）：\n\n![55B9E6EFD1C3099B8203D17D0089360C](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ve0qh.png)\n\n好了，然后安装 **Jenkins ** 。同样的，在[官网下载页面](https://jenkins.io/download/)上选择 **Weekly — Mac OS X** 下载 *pkg* 安装包。\n\n![Jenkins Website](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gz4yg.png)\n\n以 **2.113** 为例，一步步安装。\n\n![Jenkins Install Begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9ez6l.png)\n\n![Jenkins Install Step2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9dt4k.png)\n\n安装完成后，会自动打开浏览器，跳转到`localhost:8080`可以看到 Jenkins 正在准备中...\n\n如果提示打不开，使用 Safari 出现以下界面：\n\n![Oops Jenkins Start Failed](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gaawr.png)\n\n则可能是 jdk 的配置出了问题，返回去看看前文关于 jdk 的配置，检查一遍是否正确。\n\n> 注：如果此时重启系统，会发现多了一个名为『 jenkins 』的普通成员。\n\n在 jenkins 初始化工作完成后，会跳转到另一个**解锁  jenkins ** 的界面，提示密码存放在`/Users/Shared/Jenkins/Home/secrets/initialAdminPassword`中，到其中查看，会发现`secret`文件夹被设置了权限，使用我们当前的用户无读写的权限。\n\n![解锁jenkins](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jc4l1.png)\n\n此时使用命令行工具，键入如下命令，并输入电脑的管理员 root 密码（通常是我们自己的登录密码）后：\n\n```shell\nsudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword\n```\n\n可以看到 jenkins 的初始化密码：\n\n![屏幕快照 2018-03-26 下午12.44.11](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/s09vt.png)\n\n将该密码填入到网页中，完成解锁工作。**此密码同时是登录 jenkins 的 admin 账户的密码，见下文。**\n\n之后，安装社区推荐的插件即可：\n\n![屏幕快照 2018-03-26 下午12.45.24](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/lg2px.png)\n\n然后创建第一个管理员用户，此处建议自行创建一个用户，当然也可以点击右下角的 **『使用 admin 账户继续』** ，密码是 jenkins 的解锁密码，也就是 initialAdminPassword 里面那个字符串。\n\n![屏幕快照 2018-03-26 下午12.50.00](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cio9r.png)\n\n保存完成后，Congratulation~ 🎉🎉🎉 \n\n行李已经收拾好了，可以继续 jenkins 密林探索之旅了。\n\n## Jenkins配置\n\n在安装完 Jenkins 后，就可以愉快地使用它来持续集成我们的项目了，如果对一些启动配置不感兴趣，不想看这一部分，可以愉快地略过，不修改配置也完全不影响使用。\n\n需要修改配置的情况如下（包括但不完全包括）：\n\n1. 默认地，当 jenkins 安装在服务器上时，监听的是服务器的 8080 端口。而我们知道，在做 Java Web 开发时，应用服务器 tomcat 的默认端口也是 8080 ，不修改配置的话，很容易造成冲突。\n2. 我们在使用 Jenkins 会安装各种插件，同时运行很多个构建工作，都有可能造成内存溢出的问题。\n3. 当我们需要配置 HTTPS ，证书等等。\n\n### 启动与关闭\n\n首先，针对使用 **pkg** 安装的方式（使用直接下载 war ，用`java -jar`运行不在本文的讨论范围内。），Jenkins 作为一个后台驻留程序（ *Daemon* ），在 Wins 下我们习惯叫服务，自然有开关。\n\n一个后台驻留程序是运行在系统后台的，没有任何GUI的程序。在 macOS 下，一个后台驻留程序的配置保存在一个`plist`文件中，非系统驻留程序的`plist`文件都统一存放在`/Library/LaunchDaemons`之中。\n\n我们知道，`plist`本质是 xml 文件，其中存放的都是键值对，里面的键都是 [launch.plist](x-man-page://5/launchd.plist) 中定义的，这个`plist`用于告知`launch`去哪里运行脚本，以及运行过程中一些路径和用户、组的配置。\n\n所以，启动和关闭的命令看起来比较少见：\n\n```shell\n# 开启Jenkins\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n# 关闭Jenkins\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n\n打开`org.jenkins-ci.plist`，看到`ProgramArguments`，写着运行脚本的位置：\n\n![019DE0A84C235007987FE3CF18813083](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ntvgu.png)\n\n### JVM的配置\n\n接下来，我们来看看 `jenkins-runner.sh` 这个脚本中的内容。\n\n```shell\n#!/bin/bash\n#\n# Startup script used by Jenkins launchd job.\n# Mac OS X launchd process calls this script to customize\n# the java process command line used to run Jenkins.\n#\n# Customizable parameters are found in\n# /Library/Preferences/org.jenkins-ci.plist\n#\n# You can manipulate it using the \"defaults\" utility.\n# See \"man defaults\" for details.\n\ndefaults=\"defaults read /Library/Preferences/org.jenkins-ci\"\n\nwar=`$defaults war` || war=\"/Applications/Jenkins/jenkins.war\"\n\njavaArgs=\"-Dfile.encoding=UTF-8\"\n\nminPermGen=`$defaults minPermGen` && javaArgs=\"$javaArgs -XX:PermSize=${minPermGen}\"\npermGen=`$defaults permGen` && javaArgs=\"$javaArgs -XX:MaxPermSize=${permGen}\"\n\nminHeapSize=`$defaults minHeapSize` && javaArgs=\"$javaArgs -Xms${minHeapSize}\"\nheapSize=`$defaults heapSize` && javaArgs=\"$javaArgs -Xmx${heapSize}\"\n\ntmpdir=`$defaults tmpdir` && javaArgs=\"$javaArgs -Djava.io.tmpdir=${tmpdir}\"\n\nhome=`$defaults JENKINS_HOME` && export JENKINS_HOME=\"$home\"\n\nadd_to_args() {\n    val=`$defaults $1` && args=\"$args --${1}=${val}\"\n}\n\nargs=\"\"\nadd_to_args prefix\nadd_to_args httpPort\nadd_to_args httpListenAddress\nadd_to_args httpsPort\nadd_to_args httpsListenAddress\nadd_to_args httpsKeyStore\nadd_to_args httpsKeyStorePassword\n\necho \"JENKINS_HOME=$JENKINS_HOME\"\necho \"Jenkins command line for execution:\"\necho /usr/bin/java $javaArgs -jar \"$war\" $args\nexec /usr/bin/java $javaArgs -jar \"$war\" $args\n```\n\n第一行我们看到，给`defaults`赋了值：\n\n```shell\ndefaults read /Library/Preferences/org.jenkins-ci SETTING\n```\n\n> 注：`defaults` 命令可以用来读取其中的配置项`SETTING`的值。不写`SETTING`可以读取所有的配置。\n\n其中，`/Library/Preferences/org.jenkins-ci`是 Jenkins 的配置文件所在的位置。\n\n然后，用`defaults`读取`org.jenkins-ci`文件中`war`、`minPermGen`、`permGen`等值，最后使用`java -jar`来启动 Jenkins 。\n\nJenkins 是 Java 程序，运行在 JVM 上。通过上述分析，我们知道，修改`org.jenkins-ci`这中的键值对，可以达到配置 Jenkins 的目的。\n\n下面介绍目前几个常用的配置项（当然如果你是一名 Java Web 程序开发者，对 JVM 比我更熟悉，应该可以按照`jenkins-runner.sh`脚本中的格式修改脚本添加一些自定义配置，这里只是抛砖引玉）：\n\n* war :  war 包的指定位置，默认值：`/Applications/Jenkins/jenkins.war`\n* minPermGen :  JVM 的非堆内存空间，将赋值给`XX:PermSize`\n* permGen :  JVM 的最大非堆内存空间，将赋值给`XX:MaxPermSize`\n* minHeapSize :  JVM 的堆内存空间，将赋值给`Xms`\n* heapSize :  JVM 的最大堆内存空间，将赋值给`Xmx`\n* tmpdir :  Jenkins 运行的临时存放空间，此值会作为变量赋值给 JVM 的环境变量`java.io.tmpdir`\n* JENKINS_HOME :  Jenkins 目录，默认值：`/Users/Shared/Jenkins/Home`，保存着工作空间， war 包解压后存放在此，插件，用户，节点，日志等等\n* prefix : 访问页面的前缀。上述安装后打开的 url 是`localhost:8080`，当配置 prefix 之后，若配置为`/objchris`（不可以漏掉`/`），则访问路径变成`localhost:8080/objchris`。\n* httpPort、httpsport :  http、https 端口\n* httpListenAddress、httpsListenAddress : 接收请求 IP ，默认为 0.0.0.0 ，即其他主机也可以访问到，接收任意 IP 发来的请求。若设置为 127.0.0.1 ，则只能本机访问。\n\n对于配置项，有兴趣的同学可以参考[这里](https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins)，十分详细且有一些配置示例。\n\n修改配置，可以使用以下命令：\n\n```shell\nsudo defaults write /Library/Preferences/org.jenkins-ci SETTING VALUE\n```\n\n做错了也没关系，重新 write 一遍或`defaults`也支持删除：\n\n```shell\nsudo defaults delete /Library/Preferences/org.jenkins-ci SETTING\n```\n\n## 卸载 Jenkins\n\n要残忍舍弃 Jenkins 投奔其他 CI 工具的话：\n\n```Shell\n'/Library/Application Support/Jenkins/Uninstall.command'\n```\n\n同样针对使用 **pkg** 安装的方式。\n\n下载 war 包，直接停止服务删除 war 包就好了。\n\n使用 homebrew ，有 homebrew 自己的管理方式，不在此说明了。\n\n> 有时候，遇到一些玄学才能解释的问题（例如文件损坏无法启动 Jenkins ...），卸载重装或许也是一个好方法，嗯[正经脸]。\n\n## 插件安装\n\n在密林探索开始以前，我们要带上一些工具，给 Jenkins 安装一些插件。\n\n插件安装在『 系统管理 — 管理插件 』，图标是一块绿色的小拼图。点击进去可以看到可更新、可选插件、已安装、高级。都是望名知意，不多做解释了。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gru5l.png)\n\n选择 *可选插件* ，在过滤处输入想要安装的插件。对我们来说，版本管理工具 Git 或 SVN 用得最多，但是如果一开始安装 Jenkins 的时候已选择社区推荐插件的话，其实已经安装好了 GitHub 的相关插件 [GitHub plugin](http://wiki.jenkins-ci.org/display/JENKINS/Github+Plugin) 。 SVN 的话，我所使用的 Jenkins 2.113 版本在 war 包内部嵌入了 SVN 的插件 [Subversion Plug-in](https://wiki.jenkins.io/display/JENKINS/Subversion+Plugin) 。如果公司内部有 Git 服务器，通常是部署的开源 GitLab ，则需要安装`GitLab Plugin`用于管理源码和`Gitlab Hook Plugin`用于构建 GitLab 的触发器。\n\n我的主要目的是 iOS 项目构建，因此还需要选择`Xcode integration`安装 Xcode 插件，和管理签名证书私钥和 PP 文件的`Keychains and Provisioning Profiles Management`。\n\n安装完了这些，我们就可以配置一个构建项目了。\n\n## 构建项目\n\n### 基本项目配置\n\n回到主界面上，点击左上角 *新建任务* ，进入新建任务界面。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j5l33.png)\n\n确定后，开始项目的通用配置：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tpk2j.png)\n\n我的项目是托管在公司内部 SVN 上的，所以`Github Project`不打勾，勾上`丢弃旧的构建`会将构建记录保留一定时间（根据自己需求设置天数）和最大保留个数。`参数化构建过程`可以为构建过程添加相应的参数。`关闭构建`主要针对定时任务（下面会说到），顾名思义就是关闭当前任务，自然不会启动定时任务。\n\n### 源码管理—— SVN\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r6yz.png)\n\n我所在的公司源码管理使用 SVN ，在 Module 中填上 SVN 的一些信息：\n\n* Repository URL ：仓库地址\n* Credentials ：用于登录、拉取代码的账户密码\n* Local module directory ： 存放在工作空间的位置，每当新建一个任务， Jenkins 会在`$HOME`目录下的`workspace`中新建一个以任务名称命名的文件夹。因此，如果此项填入`.`（默认值就是`.`），则从 SVN 仓库地址拉取的代码将直接存放在其中。填写其他路径（如`./path/to/subfolder`），则放在对应的路径中。 **Jenkins 在运行脚本的时候所在的位置是`$HOME/workspace/[任务名称]`，所以如果此项修改了，添加了其他子文件夹，在下面写运行脚本位置时需要注意路径是否正确。**\n* Repository depth ：拉取代码时的深度，分别有以下几个：\n  * infinity ：遍历所有文件夹，拉取所有文件和文件夹\n  * empty ：将本地路径初始化，不拉取任何文件\n  * files ：当前文件夹和文件，不包含子文件夹\n  * immediates ：当前文件夹、文件、子文件夹，但不遍历子文件夹\n  * as-it-is ：继承原有的深度\n* Ignore external ：拉取代码时忽略 external 的属性设置的库。\n* Cancel process on externals fail ：拉取 external 的属性设置的库失败时停止。\n\n`Check-out Strategy`是检出策略。可选择 ：尽可能多地使用`svn update`，每次都 checkout 一个新的，或使用脚本 checkout ，不需要 Jenkins 帮我们 checkout 等等。\n\n### 构建环境\n\n我们知道，打包 iOS 需要代码签名( *codesign* )，也就需要私钥，因此第一步，是先将 keychain 添加到 Jenkins 。\n\n#### 添加 Keychain 和 Provisioning Profiles \n\n还记得上面安装插件的时候安装了`Keychains and Provisioning Profiles Management`吗？在构建环境这里，可以看到`Keychains and Code Signing Identities`选项：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r1ie.png)\n\n但此时还没有配置，所以要先去 **系统管理 —— Keychains and Provisioning Profiles Management**添加 Keychain 和 Provisioning Profiles 。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3n7n0.png)\n\n提示我们 Upload Keychain ，选择`/Users/管理员用户名/Library/keychains/login.keychain`上传。然后输入 Keychain 的密码和签名使用的证书的 Code Signing Identity （ 如：iPhone Distribution: *** CO.,LTD (ABCD678EFG) ）\n\n再上传 Provisioning Profiles ，上传的文件最终位置在`/Users/Shared/Jenkins/Home/kpp_upload/`。然后将`/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profiles`填写到页面的`Provisioning Profiles Directory Path`，然后保存就可以了。\n\n这样的操作是让 Jenkins 在进行构建的时候将`kpp_upload`中的 Provisioning Profiles 拷贝到`MobileDevice/Provisioning Profiles`文件夹中，就跟我们平时安装 Provisioning Profiles 一样。\n\n完成后大致是这样子：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ac2j7.png)\n\n这里添加了 Developer 和 Distribution 的开发者证书和 Development 和 Ad-hoc 的 Provisioning Profiles 。\n\n#### 配置项目使用的 Keychain\n\n回到项目配置中，此时就可以选择 Keychain and Code Signing Identity 了。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4wmwm.png)\n\n这里的 Provisioning Profiles 是需要 development 和 ad-hoc 的。\n\n### 构建\n\n项目构建最简单的方式就是使用脚本了，可以看我前面写过的[文章——iOS脚本打包 - xcodebuild](https://objchris.com/2018/04/02/iOS脚本打包/)。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l2gp4.png)\n\n增加构建步骤，选择`Execute shell`，填入脚本：\n\n```shell\n#!/bin/sh -l\n# 解决找不到pod和pod提示语言不对的问题\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport PATH=\"/usr/local/bin:$PATH\"\necho $PATH\npod --version\n# 解锁用户上传的Keychain\n# KEYCHAIN_PATH 和 KEYCHAIN_PASSWORD 是配置构建环境时，Keychains and Provisioning Profiles Management插件提供，可直接使用\nsecurity list-keychains -s \"${KEYCHAIN_PATH}\"\nsecurity default-keychain -d user -s \"${KEYCHAIN_PATH}\"\n# 告诉系统Keychain已解锁，无须再弹出UI\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k \"${KEYCHAIN_PASSWORD}\" \"${KEYCHAIN_PATH}\"\nsecurity unlock-keychain -p \"${KEYCHAIN_PASSWORD}\"\nsecurity show-keychain-info \"${KEYCHAIN_PATH}\"\nsecurity find-identity -p codesigning -v\n# 执行我们的打包脚本\nsh KeyXBuild.sh\n```\n\n到这里就已经完成打包，得到 ipa 文件了。\n\n一些构建后的操作就不多说了，或者通过 SVN 上传到某个目录，或者上传到蒲公英这种分发平台。\n\n## 构建状态提示\n\n每一次构建成功失败都会有提示：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zm08o.png)\n\n构建结束后可以查看日志输出：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/crs2g.png)\n\n项目构建的成功与否决定了一个项目的分数， Jenkins 使用类似天气预报的样式呈现：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2en18.jpg)\n\n第一次使用 Jenkins ，尝试个四五十次应该就差不多了：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8t6x.png)\n\n\n\n## Troubleshooting\n\n### -bash: pod: command not found\n\n前面说过，Jenkins 在安装完成后会创建一个名为 jenkins 的普通用户，我们可以通过 **系统偏好设置 -> 用户与群组** 来修改 jenkins 用户的密码，然后登入到其中。进行一些检查操作。\n\n我的项目使用到 Cocoapods 来管理第三方库，且`Pods`这个文件夹没有上传到 SVN 上，只上传了`Podfile`和`Podfile.lock`。因此需要在 Jenkins 上进行一次`Pod install`。这就需要 Jenkins 用户安装 Pod ，这时候就需要登录 jenkins 去完成安装操作了。\n\n### Code Signing Error: Provisioning profile \"xxx\" doesn't include signing certificate \"iPhone Developer: xxx\"\n\n出现此问题是因为，使用 xcodebuild archive 时，指定的 Provisioning profile 和证书都必须是开发使用的。不能是 ad-hoc 或 app store 。\n\n在 archive 后进行 export 的时候才是使用 ad-hoc 或 app store 的证书和 Provisioning profile 。\n\n### codesign：unknown error -1=ffffffffffffffff\n\n这个问题是没有访问 Keychain 的权限，因为我们的 Keychain 是从 Jenkins 上传的，每次构建时 Jenkins 都会将 Keychain 文件拷贝到工作项目路径中。\n\n因此我们需要自己手动解锁：\n\n```shell\nsecurity unlock-keychain -p \"${KEYCHAIN_PASSWORD}\"\n```\n\n在 macOS 10.12 前，这样就可以了。但是新版本中，解锁操作过后还是会弹出UI来解锁 Keychain 。而 Jenkins 是没有用户交互的，所以签名时才会有这个错误出现。\n\n解决方法是：\n\n```shell\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k \"${KEYCHAIN_PASSWORD}\" \"${KEYCHAIN_PATH}\"\n```\n\n别忘了其中的`codesign:`，很多添加了类似命令还是不成功的原因可能是忽略了`codesign:`\n\n### Something of Keychain\n\n脚本打包时，会使用`~/Library/Keychain`中的 login.keychain 。因此，网上很多教程都是将打包使用的证书和私钥（ login.keychain ）直接拷贝到 Jenkins 中，但是这样不利于项目配置。因为不同的项目可能需要不同的证书签名，要添加新证书就需要再次复制 keychain 文件到 jenkins 的`~/Library/Keychains`下，覆盖原来的`login.keychain`。这样容易造成老项目无法成功打包（因为旧 keychain 被覆盖）。\n\n因此，我一直在找如何直接使用 Jenkins 提供的配置去动态添加 keychain ，**Keychains and Provisioning Profiles Management** 插件帮我们完成 keychain 文件和 Provisioning Profiles 的位置问题，但是需要配合`Xcode`插件去使用。这样让脚本打包变得不方便。\n\n为了解决这个问题，才有了上面构建脚本中对 Keychain 的一系列操作。\n\n## 说在最后\n\n可能在未来使用过程中会遇到问题，会回来补充。\n\nつつく","source":"_posts/Jenkins.md","raw":"---\ntitle: Jenkins密林探索\ndate: 2018-04-27 18:39:08\ntags: \n- CI\ntypora-copy-images-to: ipic\n---\n\n说到持续集成，Jenkins 是用得比较多的。本文说明了我从安装到配置再到打包 ipa 文件，从手动打包到点击一下按钮自动生成 ipa 所做的事情。\n\n得益于 Jenkins ，让开发体验提升了不少。不多说，文内多图，来跟我一起密林探索吧 :]\n\n<!--more-->\n\n![Jenkins](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aohum.png)\n\n## Jenkins安装\n\n本文以 *Jenkins* 当前时间 **2018.03.27** 的最近 weekly 版本 *2.113* 来说明， Jenkins 是 Java web 项目，在使用上有 Java 环境的限制：**jdk1.8 以上**。\n\n对于 macOS10.9 和 10.10 来说，系统中自带有 jdk1.6 ，但这并不符合要求。而其他版本（ macOS10.11 以上）中貌似没有 jdk ，可以在命令行工具键入`java -version`来判断。\n\n若出现以下提示，则表示没有配置 Java 环境或系统中没有安装 jdk ：\n\n```Shell\nNo Java runtime present, requesting install.\n```\n\n若弹出安装对话框，点击 **『好』** 退出对话框。\n\n不然，定位到`/Library/Java/JavaVirtualMachines`中可查看是否存在 jdk 。\n\n如果都没有，或 jdk 版本不符，则需要重新安装。 macOS 的安装方式比较简单，在[Oracle的jdk下载地址](http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html)上下载 dmg 安装包，直接安装 jdk1.8 到系统中。然后修改`~/.bashrc`文件配置一系列的系统变量，如果使用`zsh`，则修改`~/.zshrc`。在文件末尾添加：\n\n```shell\n# 通常通过dmg安装的jdk都是在/Library/Java/JavaVirtualMachines/下，需根据实际情况对JAVA_HOME进行配置\nexport JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Content/Home\"\nexport CLASS_HOME=\"$JAVA_HOME/lib\"\nexport PATH=\".;$PATH:$JAVA_HOME/bin\"\n```\n\n然后重置一下配置：\n\n```shell\nsource ~/.bashrc\n```\n\n或者（使用`zsh`）\n\n```Shell\nsource ~/.zshrc\n```\n\n再次使用`java - version`验证是否安装成功（全文部分截图是我使用公司电脑安装 Jenkins 时截下来的）：\n\n![55B9E6EFD1C3099B8203D17D0089360C](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ve0qh.png)\n\n好了，然后安装 **Jenkins ** 。同样的，在[官网下载页面](https://jenkins.io/download/)上选择 **Weekly — Mac OS X** 下载 *pkg* 安装包。\n\n![Jenkins Website](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gz4yg.png)\n\n以 **2.113** 为例，一步步安装。\n\n![Jenkins Install Begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9ez6l.png)\n\n![Jenkins Install Step2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9dt4k.png)\n\n安装完成后，会自动打开浏览器，跳转到`localhost:8080`可以看到 Jenkins 正在准备中...\n\n如果提示打不开，使用 Safari 出现以下界面：\n\n![Oops Jenkins Start Failed](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gaawr.png)\n\n则可能是 jdk 的配置出了问题，返回去看看前文关于 jdk 的配置，检查一遍是否正确。\n\n> 注：如果此时重启系统，会发现多了一个名为『 jenkins 』的普通成员。\n\n在 jenkins 初始化工作完成后，会跳转到另一个**解锁  jenkins ** 的界面，提示密码存放在`/Users/Shared/Jenkins/Home/secrets/initialAdminPassword`中，到其中查看，会发现`secret`文件夹被设置了权限，使用我们当前的用户无读写的权限。\n\n![解锁jenkins](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jc4l1.png)\n\n此时使用命令行工具，键入如下命令，并输入电脑的管理员 root 密码（通常是我们自己的登录密码）后：\n\n```shell\nsudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword\n```\n\n可以看到 jenkins 的初始化密码：\n\n![屏幕快照 2018-03-26 下午12.44.11](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/s09vt.png)\n\n将该密码填入到网页中，完成解锁工作。**此密码同时是登录 jenkins 的 admin 账户的密码，见下文。**\n\n之后，安装社区推荐的插件即可：\n\n![屏幕快照 2018-03-26 下午12.45.24](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/lg2px.png)\n\n然后创建第一个管理员用户，此处建议自行创建一个用户，当然也可以点击右下角的 **『使用 admin 账户继续』** ，密码是 jenkins 的解锁密码，也就是 initialAdminPassword 里面那个字符串。\n\n![屏幕快照 2018-03-26 下午12.50.00](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cio9r.png)\n\n保存完成后，Congratulation~ 🎉🎉🎉 \n\n行李已经收拾好了，可以继续 jenkins 密林探索之旅了。\n\n## Jenkins配置\n\n在安装完 Jenkins 后，就可以愉快地使用它来持续集成我们的项目了，如果对一些启动配置不感兴趣，不想看这一部分，可以愉快地略过，不修改配置也完全不影响使用。\n\n需要修改配置的情况如下（包括但不完全包括）：\n\n1. 默认地，当 jenkins 安装在服务器上时，监听的是服务器的 8080 端口。而我们知道，在做 Java Web 开发时，应用服务器 tomcat 的默认端口也是 8080 ，不修改配置的话，很容易造成冲突。\n2. 我们在使用 Jenkins 会安装各种插件，同时运行很多个构建工作，都有可能造成内存溢出的问题。\n3. 当我们需要配置 HTTPS ，证书等等。\n\n### 启动与关闭\n\n首先，针对使用 **pkg** 安装的方式（使用直接下载 war ，用`java -jar`运行不在本文的讨论范围内。），Jenkins 作为一个后台驻留程序（ *Daemon* ），在 Wins 下我们习惯叫服务，自然有开关。\n\n一个后台驻留程序是运行在系统后台的，没有任何GUI的程序。在 macOS 下，一个后台驻留程序的配置保存在一个`plist`文件中，非系统驻留程序的`plist`文件都统一存放在`/Library/LaunchDaemons`之中。\n\n我们知道，`plist`本质是 xml 文件，其中存放的都是键值对，里面的键都是 [launch.plist](x-man-page://5/launchd.plist) 中定义的，这个`plist`用于告知`launch`去哪里运行脚本，以及运行过程中一些路径和用户、组的配置。\n\n所以，启动和关闭的命令看起来比较少见：\n\n```shell\n# 开启Jenkins\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n# 关闭Jenkins\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n\n打开`org.jenkins-ci.plist`，看到`ProgramArguments`，写着运行脚本的位置：\n\n![019DE0A84C235007987FE3CF18813083](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ntvgu.png)\n\n### JVM的配置\n\n接下来，我们来看看 `jenkins-runner.sh` 这个脚本中的内容。\n\n```shell\n#!/bin/bash\n#\n# Startup script used by Jenkins launchd job.\n# Mac OS X launchd process calls this script to customize\n# the java process command line used to run Jenkins.\n#\n# Customizable parameters are found in\n# /Library/Preferences/org.jenkins-ci.plist\n#\n# You can manipulate it using the \"defaults\" utility.\n# See \"man defaults\" for details.\n\ndefaults=\"defaults read /Library/Preferences/org.jenkins-ci\"\n\nwar=`$defaults war` || war=\"/Applications/Jenkins/jenkins.war\"\n\njavaArgs=\"-Dfile.encoding=UTF-8\"\n\nminPermGen=`$defaults minPermGen` && javaArgs=\"$javaArgs -XX:PermSize=${minPermGen}\"\npermGen=`$defaults permGen` && javaArgs=\"$javaArgs -XX:MaxPermSize=${permGen}\"\n\nminHeapSize=`$defaults minHeapSize` && javaArgs=\"$javaArgs -Xms${minHeapSize}\"\nheapSize=`$defaults heapSize` && javaArgs=\"$javaArgs -Xmx${heapSize}\"\n\ntmpdir=`$defaults tmpdir` && javaArgs=\"$javaArgs -Djava.io.tmpdir=${tmpdir}\"\n\nhome=`$defaults JENKINS_HOME` && export JENKINS_HOME=\"$home\"\n\nadd_to_args() {\n    val=`$defaults $1` && args=\"$args --${1}=${val}\"\n}\n\nargs=\"\"\nadd_to_args prefix\nadd_to_args httpPort\nadd_to_args httpListenAddress\nadd_to_args httpsPort\nadd_to_args httpsListenAddress\nadd_to_args httpsKeyStore\nadd_to_args httpsKeyStorePassword\n\necho \"JENKINS_HOME=$JENKINS_HOME\"\necho \"Jenkins command line for execution:\"\necho /usr/bin/java $javaArgs -jar \"$war\" $args\nexec /usr/bin/java $javaArgs -jar \"$war\" $args\n```\n\n第一行我们看到，给`defaults`赋了值：\n\n```shell\ndefaults read /Library/Preferences/org.jenkins-ci SETTING\n```\n\n> 注：`defaults` 命令可以用来读取其中的配置项`SETTING`的值。不写`SETTING`可以读取所有的配置。\n\n其中，`/Library/Preferences/org.jenkins-ci`是 Jenkins 的配置文件所在的位置。\n\n然后，用`defaults`读取`org.jenkins-ci`文件中`war`、`minPermGen`、`permGen`等值，最后使用`java -jar`来启动 Jenkins 。\n\nJenkins 是 Java 程序，运行在 JVM 上。通过上述分析，我们知道，修改`org.jenkins-ci`这中的键值对，可以达到配置 Jenkins 的目的。\n\n下面介绍目前几个常用的配置项（当然如果你是一名 Java Web 程序开发者，对 JVM 比我更熟悉，应该可以按照`jenkins-runner.sh`脚本中的格式修改脚本添加一些自定义配置，这里只是抛砖引玉）：\n\n* war :  war 包的指定位置，默认值：`/Applications/Jenkins/jenkins.war`\n* minPermGen :  JVM 的非堆内存空间，将赋值给`XX:PermSize`\n* permGen :  JVM 的最大非堆内存空间，将赋值给`XX:MaxPermSize`\n* minHeapSize :  JVM 的堆内存空间，将赋值给`Xms`\n* heapSize :  JVM 的最大堆内存空间，将赋值给`Xmx`\n* tmpdir :  Jenkins 运行的临时存放空间，此值会作为变量赋值给 JVM 的环境变量`java.io.tmpdir`\n* JENKINS_HOME :  Jenkins 目录，默认值：`/Users/Shared/Jenkins/Home`，保存着工作空间， war 包解压后存放在此，插件，用户，节点，日志等等\n* prefix : 访问页面的前缀。上述安装后打开的 url 是`localhost:8080`，当配置 prefix 之后，若配置为`/objchris`（不可以漏掉`/`），则访问路径变成`localhost:8080/objchris`。\n* httpPort、httpsport :  http、https 端口\n* httpListenAddress、httpsListenAddress : 接收请求 IP ，默认为 0.0.0.0 ，即其他主机也可以访问到，接收任意 IP 发来的请求。若设置为 127.0.0.1 ，则只能本机访问。\n\n对于配置项，有兴趣的同学可以参考[这里](https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins)，十分详细且有一些配置示例。\n\n修改配置，可以使用以下命令：\n\n```shell\nsudo defaults write /Library/Preferences/org.jenkins-ci SETTING VALUE\n```\n\n做错了也没关系，重新 write 一遍或`defaults`也支持删除：\n\n```shell\nsudo defaults delete /Library/Preferences/org.jenkins-ci SETTING\n```\n\n## 卸载 Jenkins\n\n要残忍舍弃 Jenkins 投奔其他 CI 工具的话：\n\n```Shell\n'/Library/Application Support/Jenkins/Uninstall.command'\n```\n\n同样针对使用 **pkg** 安装的方式。\n\n下载 war 包，直接停止服务删除 war 包就好了。\n\n使用 homebrew ，有 homebrew 自己的管理方式，不在此说明了。\n\n> 有时候，遇到一些玄学才能解释的问题（例如文件损坏无法启动 Jenkins ...），卸载重装或许也是一个好方法，嗯[正经脸]。\n\n## 插件安装\n\n在密林探索开始以前，我们要带上一些工具，给 Jenkins 安装一些插件。\n\n插件安装在『 系统管理 — 管理插件 』，图标是一块绿色的小拼图。点击进去可以看到可更新、可选插件、已安装、高级。都是望名知意，不多做解释了。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gru5l.png)\n\n选择 *可选插件* ，在过滤处输入想要安装的插件。对我们来说，版本管理工具 Git 或 SVN 用得最多，但是如果一开始安装 Jenkins 的时候已选择社区推荐插件的话，其实已经安装好了 GitHub 的相关插件 [GitHub plugin](http://wiki.jenkins-ci.org/display/JENKINS/Github+Plugin) 。 SVN 的话，我所使用的 Jenkins 2.113 版本在 war 包内部嵌入了 SVN 的插件 [Subversion Plug-in](https://wiki.jenkins.io/display/JENKINS/Subversion+Plugin) 。如果公司内部有 Git 服务器，通常是部署的开源 GitLab ，则需要安装`GitLab Plugin`用于管理源码和`Gitlab Hook Plugin`用于构建 GitLab 的触发器。\n\n我的主要目的是 iOS 项目构建，因此还需要选择`Xcode integration`安装 Xcode 插件，和管理签名证书私钥和 PP 文件的`Keychains and Provisioning Profiles Management`。\n\n安装完了这些，我们就可以配置一个构建项目了。\n\n## 构建项目\n\n### 基本项目配置\n\n回到主界面上，点击左上角 *新建任务* ，进入新建任务界面。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j5l33.png)\n\n确定后，开始项目的通用配置：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tpk2j.png)\n\n我的项目是托管在公司内部 SVN 上的，所以`Github Project`不打勾，勾上`丢弃旧的构建`会将构建记录保留一定时间（根据自己需求设置天数）和最大保留个数。`参数化构建过程`可以为构建过程添加相应的参数。`关闭构建`主要针对定时任务（下面会说到），顾名思义就是关闭当前任务，自然不会启动定时任务。\n\n### 源码管理—— SVN\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r6yz.png)\n\n我所在的公司源码管理使用 SVN ，在 Module 中填上 SVN 的一些信息：\n\n* Repository URL ：仓库地址\n* Credentials ：用于登录、拉取代码的账户密码\n* Local module directory ： 存放在工作空间的位置，每当新建一个任务， Jenkins 会在`$HOME`目录下的`workspace`中新建一个以任务名称命名的文件夹。因此，如果此项填入`.`（默认值就是`.`），则从 SVN 仓库地址拉取的代码将直接存放在其中。填写其他路径（如`./path/to/subfolder`），则放在对应的路径中。 **Jenkins 在运行脚本的时候所在的位置是`$HOME/workspace/[任务名称]`，所以如果此项修改了，添加了其他子文件夹，在下面写运行脚本位置时需要注意路径是否正确。**\n* Repository depth ：拉取代码时的深度，分别有以下几个：\n  * infinity ：遍历所有文件夹，拉取所有文件和文件夹\n  * empty ：将本地路径初始化，不拉取任何文件\n  * files ：当前文件夹和文件，不包含子文件夹\n  * immediates ：当前文件夹、文件、子文件夹，但不遍历子文件夹\n  * as-it-is ：继承原有的深度\n* Ignore external ：拉取代码时忽略 external 的属性设置的库。\n* Cancel process on externals fail ：拉取 external 的属性设置的库失败时停止。\n\n`Check-out Strategy`是检出策略。可选择 ：尽可能多地使用`svn update`，每次都 checkout 一个新的，或使用脚本 checkout ，不需要 Jenkins 帮我们 checkout 等等。\n\n### 构建环境\n\n我们知道，打包 iOS 需要代码签名( *codesign* )，也就需要私钥，因此第一步，是先将 keychain 添加到 Jenkins 。\n\n#### 添加 Keychain 和 Provisioning Profiles \n\n还记得上面安装插件的时候安装了`Keychains and Provisioning Profiles Management`吗？在构建环境这里，可以看到`Keychains and Code Signing Identities`选项：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r1ie.png)\n\n但此时还没有配置，所以要先去 **系统管理 —— Keychains and Provisioning Profiles Management**添加 Keychain 和 Provisioning Profiles 。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3n7n0.png)\n\n提示我们 Upload Keychain ，选择`/Users/管理员用户名/Library/keychains/login.keychain`上传。然后输入 Keychain 的密码和签名使用的证书的 Code Signing Identity （ 如：iPhone Distribution: *** CO.,LTD (ABCD678EFG) ）\n\n再上传 Provisioning Profiles ，上传的文件最终位置在`/Users/Shared/Jenkins/Home/kpp_upload/`。然后将`/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profiles`填写到页面的`Provisioning Profiles Directory Path`，然后保存就可以了。\n\n这样的操作是让 Jenkins 在进行构建的时候将`kpp_upload`中的 Provisioning Profiles 拷贝到`MobileDevice/Provisioning Profiles`文件夹中，就跟我们平时安装 Provisioning Profiles 一样。\n\n完成后大致是这样子：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ac2j7.png)\n\n这里添加了 Developer 和 Distribution 的开发者证书和 Development 和 Ad-hoc 的 Provisioning Profiles 。\n\n#### 配置项目使用的 Keychain\n\n回到项目配置中，此时就可以选择 Keychain and Code Signing Identity 了。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4wmwm.png)\n\n这里的 Provisioning Profiles 是需要 development 和 ad-hoc 的。\n\n### 构建\n\n项目构建最简单的方式就是使用脚本了，可以看我前面写过的[文章——iOS脚本打包 - xcodebuild](https://objchris.com/2018/04/02/iOS脚本打包/)。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l2gp4.png)\n\n增加构建步骤，选择`Execute shell`，填入脚本：\n\n```shell\n#!/bin/sh -l\n# 解决找不到pod和pod提示语言不对的问题\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport PATH=\"/usr/local/bin:$PATH\"\necho $PATH\npod --version\n# 解锁用户上传的Keychain\n# KEYCHAIN_PATH 和 KEYCHAIN_PASSWORD 是配置构建环境时，Keychains and Provisioning Profiles Management插件提供，可直接使用\nsecurity list-keychains -s \"${KEYCHAIN_PATH}\"\nsecurity default-keychain -d user -s \"${KEYCHAIN_PATH}\"\n# 告诉系统Keychain已解锁，无须再弹出UI\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k \"${KEYCHAIN_PASSWORD}\" \"${KEYCHAIN_PATH}\"\nsecurity unlock-keychain -p \"${KEYCHAIN_PASSWORD}\"\nsecurity show-keychain-info \"${KEYCHAIN_PATH}\"\nsecurity find-identity -p codesigning -v\n# 执行我们的打包脚本\nsh KeyXBuild.sh\n```\n\n到这里就已经完成打包，得到 ipa 文件了。\n\n一些构建后的操作就不多说了，或者通过 SVN 上传到某个目录，或者上传到蒲公英这种分发平台。\n\n## 构建状态提示\n\n每一次构建成功失败都会有提示：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zm08o.png)\n\n构建结束后可以查看日志输出：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/crs2g.png)\n\n项目构建的成功与否决定了一个项目的分数， Jenkins 使用类似天气预报的样式呈现：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2en18.jpg)\n\n第一次使用 Jenkins ，尝试个四五十次应该就差不多了：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8t6x.png)\n\n\n\n## Troubleshooting\n\n### -bash: pod: command not found\n\n前面说过，Jenkins 在安装完成后会创建一个名为 jenkins 的普通用户，我们可以通过 **系统偏好设置 -> 用户与群组** 来修改 jenkins 用户的密码，然后登入到其中。进行一些检查操作。\n\n我的项目使用到 Cocoapods 来管理第三方库，且`Pods`这个文件夹没有上传到 SVN 上，只上传了`Podfile`和`Podfile.lock`。因此需要在 Jenkins 上进行一次`Pod install`。这就需要 Jenkins 用户安装 Pod ，这时候就需要登录 jenkins 去完成安装操作了。\n\n### Code Signing Error: Provisioning profile \"xxx\" doesn't include signing certificate \"iPhone Developer: xxx\"\n\n出现此问题是因为，使用 xcodebuild archive 时，指定的 Provisioning profile 和证书都必须是开发使用的。不能是 ad-hoc 或 app store 。\n\n在 archive 后进行 export 的时候才是使用 ad-hoc 或 app store 的证书和 Provisioning profile 。\n\n### codesign：unknown error -1=ffffffffffffffff\n\n这个问题是没有访问 Keychain 的权限，因为我们的 Keychain 是从 Jenkins 上传的，每次构建时 Jenkins 都会将 Keychain 文件拷贝到工作项目路径中。\n\n因此我们需要自己手动解锁：\n\n```shell\nsecurity unlock-keychain -p \"${KEYCHAIN_PASSWORD}\"\n```\n\n在 macOS 10.12 前，这样就可以了。但是新版本中，解锁操作过后还是会弹出UI来解锁 Keychain 。而 Jenkins 是没有用户交互的，所以签名时才会有这个错误出现。\n\n解决方法是：\n\n```shell\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k \"${KEYCHAIN_PASSWORD}\" \"${KEYCHAIN_PATH}\"\n```\n\n别忘了其中的`codesign:`，很多添加了类似命令还是不成功的原因可能是忽略了`codesign:`\n\n### Something of Keychain\n\n脚本打包时，会使用`~/Library/Keychain`中的 login.keychain 。因此，网上很多教程都是将打包使用的证书和私钥（ login.keychain ）直接拷贝到 Jenkins 中，但是这样不利于项目配置。因为不同的项目可能需要不同的证书签名，要添加新证书就需要再次复制 keychain 文件到 jenkins 的`~/Library/Keychains`下，覆盖原来的`login.keychain`。这样容易造成老项目无法成功打包（因为旧 keychain 被覆盖）。\n\n因此，我一直在找如何直接使用 Jenkins 提供的配置去动态添加 keychain ，**Keychains and Provisioning Profiles Management** 插件帮我们完成 keychain 文件和 Provisioning Profiles 的位置问题，但是需要配合`Xcode`插件去使用。这样让脚本打包变得不方便。\n\n为了解决这个问题，才有了上面构建脚本中对 Keychain 的一系列操作。\n\n## 说在最后\n\n可能在未来使用过程中会遇到问题，会回来补充。\n\nつつく","slug":"Jenkins","published":1,"updated":"2018-11-06T12:53:47.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dj0004qu0xyml8ep67","content":"<p>说到持续集成，Jenkins 是用得比较多的。本文说明了我从安装到配置再到打包 ipa 文件，从手动打包到点击一下按钮自动生成 ipa 所做的事情。</p>\n<p>得益于 Jenkins ，让开发体验提升了不少。不多说，文内多图，来跟我一起密林探索吧 :]</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aohum.png\" alt=\"Jenkins\"></p>\n<h2 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h2><p>本文以 <em>Jenkins</em> 当前时间 <strong>2018.03.27</strong> 的最近 weekly 版本 <em>2.113</em> 来说明， Jenkins 是 Java web 项目，在使用上有 Java 环境的限制：<strong>jdk1.8 以上</strong>。</p>\n<p>对于 macOS10.9 和 10.10 来说，系统中自带有 jdk1.6 ，但这并不符合要求。而其他版本（ macOS10.11 以上）中貌似没有 jdk ，可以在命令行工具键入<code>java -version</code>来判断。</p>\n<p>若出现以下提示，则表示没有配置 Java 环境或系统中没有安装 jdk ：</p>\n<pre><code class=\"Shell\">No Java runtime present, requesting install.\n</code></pre>\n<p>若弹出安装对话框，点击 <strong>『好』</strong> 退出对话框。</p>\n<p>不然，定位到<code>/Library/Java/JavaVirtualMachines</code>中可查看是否存在 jdk 。</p>\n<p>如果都没有，或 jdk 版本不符，则需要重新安装。 macOS 的安装方式比较简单，在<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\" target=\"_blank\" rel=\"external\">Oracle的jdk下载地址</a>上下载 dmg 安装包，直接安装 jdk1.8 到系统中。然后修改<code>~/.bashrc</code>文件配置一系列的系统变量，如果使用<code>zsh</code>，则修改<code>~/.zshrc</code>。在文件末尾添加：</p>\n<pre><code class=\"shell\"># 通常通过dmg安装的jdk都是在/Library/Java/JavaVirtualMachines/下，需根据实际情况对JAVA_HOME进行配置\nexport JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Content/Home&quot;\nexport CLASS_HOME=&quot;$JAVA_HOME/lib&quot;\nexport PATH=&quot;.;$PATH:$JAVA_HOME/bin&quot;\n</code></pre>\n<p>然后重置一下配置：</p>\n<pre><code class=\"shell\">source ~/.bashrc\n</code></pre>\n<p>或者（使用<code>zsh</code>）</p>\n<pre><code class=\"Shell\">source ~/.zshrc\n</code></pre>\n<p>再次使用<code>java - version</code>验证是否安装成功（全文部分截图是我使用公司电脑安装 Jenkins 时截下来的）：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ve0qh.png\" alt=\"55B9E6EFD1C3099B8203D17D0089360C\"></p>\n<p>好了，然后安装 <strong>Jenkins </strong> 。同样的，在<a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"external\">官网下载页面</a>上选择 <strong>Weekly — Mac OS X</strong> 下载 <em>pkg</em> 安装包。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gz4yg.png\" alt=\"Jenkins Website\"></p>\n<p>以 <strong>2.113</strong> 为例，一步步安装。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9ez6l.png\" alt=\"Jenkins Install Begin\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9dt4k.png\" alt=\"Jenkins Install Step2\"></p>\n<p>安装完成后，会自动打开浏览器，跳转到<code>localhost:8080</code>可以看到 Jenkins 正在准备中…</p>\n<p>如果提示打不开，使用 Safari 出现以下界面：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gaawr.png\" alt=\"Oops Jenkins Start Failed\"></p>\n<p>则可能是 jdk 的配置出了问题，返回去看看前文关于 jdk 的配置，检查一遍是否正确。</p>\n<blockquote>\n<p>注：如果此时重启系统，会发现多了一个名为『 jenkins 』的普通成员。</p>\n</blockquote>\n<p>在 jenkins 初始化工作完成后，会跳转到另一个<strong>解锁  jenkins </strong> 的界面，提示密码存放在<code>/Users/Shared/Jenkins/Home/secrets/initialAdminPassword</code>中，到其中查看，会发现<code>secret</code>文件夹被设置了权限，使用我们当前的用户无读写的权限。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jc4l1.png\" alt=\"解锁jenkins\"></p>\n<p>此时使用命令行工具，键入如下命令，并输入电脑的管理员 root 密码（通常是我们自己的登录密码）后：</p>\n<pre><code class=\"shell\">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword\n</code></pre>\n<p>可以看到 jenkins 的初始化密码：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/s09vt.png\" alt=\"屏幕快照 2018-03-26 下午12.44.11\"></p>\n<p>将该密码填入到网页中，完成解锁工作。<strong>此密码同时是登录 jenkins 的 admin 账户的密码，见下文。</strong></p>\n<p>之后，安装社区推荐的插件即可：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/lg2px.png\" alt=\"屏幕快照 2018-03-26 下午12.45.24\"></p>\n<p>然后创建第一个管理员用户，此处建议自行创建一个用户，当然也可以点击右下角的 <strong>『使用 admin 账户继续』</strong> ，密码是 jenkins 的解锁密码，也就是 initialAdminPassword 里面那个字符串。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cio9r.png\" alt=\"屏幕快照 2018-03-26 下午12.50.00\"></p>\n<p>保存完成后，Congratulation~ 🎉🎉🎉 </p>\n<p>行李已经收拾好了，可以继续 jenkins 密林探索之旅了。</p>\n<h2 id=\"Jenkins配置\"><a href=\"#Jenkins配置\" class=\"headerlink\" title=\"Jenkins配置\"></a>Jenkins配置</h2><p>在安装完 Jenkins 后，就可以愉快地使用它来持续集成我们的项目了，如果对一些启动配置不感兴趣，不想看这一部分，可以愉快地略过，不修改配置也完全不影响使用。</p>\n<p>需要修改配置的情况如下（包括但不完全包括）：</p>\n<ol>\n<li>默认地，当 jenkins 安装在服务器上时，监听的是服务器的 8080 端口。而我们知道，在做 Java Web 开发时，应用服务器 tomcat 的默认端口也是 8080 ，不修改配置的话，很容易造成冲突。</li>\n<li>我们在使用 Jenkins 会安装各种插件，同时运行很多个构建工作，都有可能造成内存溢出的问题。</li>\n<li>当我们需要配置 HTTPS ，证书等等。</li>\n</ol>\n<h3 id=\"启动与关闭\"><a href=\"#启动与关闭\" class=\"headerlink\" title=\"启动与关闭\"></a>启动与关闭</h3><p>首先，针对使用 <strong>pkg</strong> 安装的方式（使用直接下载 war ，用<code>java -jar</code>运行不在本文的讨论范围内。），Jenkins 作为一个后台驻留程序（ <em>Daemon</em> ），在 Wins 下我们习惯叫服务，自然有开关。</p>\n<p>一个后台驻留程序是运行在系统后台的，没有任何GUI的程序。在 macOS 下，一个后台驻留程序的配置保存在一个<code>plist</code>文件中，非系统驻留程序的<code>plist</code>文件都统一存放在<code>/Library/LaunchDaemons</code>之中。</p>\n<p>我们知道，<code>plist</code>本质是 xml 文件，其中存放的都是键值对，里面的键都是 <a href=\"x-man-page://5/launchd.plist\" target=\"_blank\" rel=\"external\">launch.plist</a> 中定义的，这个<code>plist</code>用于告知<code>launch</code>去哪里运行脚本，以及运行过程中一些路径和用户、组的配置。</p>\n<p>所以，启动和关闭的命令看起来比较少见：</p>\n<pre><code class=\"shell\"># 开启Jenkins\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n# 关闭Jenkins\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n</code></pre>\n<p>打开<code>org.jenkins-ci.plist</code>，看到<code>ProgramArguments</code>，写着运行脚本的位置：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ntvgu.png\" alt=\"019DE0A84C235007987FE3CF18813083\"></p>\n<h3 id=\"JVM的配置\"><a href=\"#JVM的配置\" class=\"headerlink\" title=\"JVM的配置\"></a>JVM的配置</h3><p>接下来，我们来看看 <code>jenkins-runner.sh</code> 这个脚本中的内容。</p>\n<pre><code class=\"shell\">#!/bin/bash\n#\n# Startup script used by Jenkins launchd job.\n# Mac OS X launchd process calls this script to customize\n# the java process command line used to run Jenkins.\n#\n# Customizable parameters are found in\n# /Library/Preferences/org.jenkins-ci.plist\n#\n# You can manipulate it using the &quot;defaults&quot; utility.\n# See &quot;man defaults&quot; for details.\n\ndefaults=&quot;defaults read /Library/Preferences/org.jenkins-ci&quot;\n\nwar=`$defaults war` || war=&quot;/Applications/Jenkins/jenkins.war&quot;\n\njavaArgs=&quot;-Dfile.encoding=UTF-8&quot;\n\nminPermGen=`$defaults minPermGen` &amp;&amp; javaArgs=&quot;$javaArgs -XX:PermSize=${minPermGen}&quot;\npermGen=`$defaults permGen` &amp;&amp; javaArgs=&quot;$javaArgs -XX:MaxPermSize=${permGen}&quot;\n\nminHeapSize=`$defaults minHeapSize` &amp;&amp; javaArgs=&quot;$javaArgs -Xms${minHeapSize}&quot;\nheapSize=`$defaults heapSize` &amp;&amp; javaArgs=&quot;$javaArgs -Xmx${heapSize}&quot;\n\ntmpdir=`$defaults tmpdir` &amp;&amp; javaArgs=&quot;$javaArgs -Djava.io.tmpdir=${tmpdir}&quot;\n\nhome=`$defaults JENKINS_HOME` &amp;&amp; export JENKINS_HOME=&quot;$home&quot;\n\nadd_to_args() {\n    val=`$defaults $1` &amp;&amp; args=&quot;$args --${1}=${val}&quot;\n}\n\nargs=&quot;&quot;\nadd_to_args prefix\nadd_to_args httpPort\nadd_to_args httpListenAddress\nadd_to_args httpsPort\nadd_to_args httpsListenAddress\nadd_to_args httpsKeyStore\nadd_to_args httpsKeyStorePassword\n\necho &quot;JENKINS_HOME=$JENKINS_HOME&quot;\necho &quot;Jenkins command line for execution:&quot;\necho /usr/bin/java $javaArgs -jar &quot;$war&quot; $args\nexec /usr/bin/java $javaArgs -jar &quot;$war&quot; $args\n</code></pre>\n<p>第一行我们看到，给<code>defaults</code>赋了值：</p>\n<pre><code class=\"shell\">defaults read /Library/Preferences/org.jenkins-ci SETTING\n</code></pre>\n<blockquote>\n<p>注：<code>defaults</code> 命令可以用来读取其中的配置项<code>SETTING</code>的值。不写<code>SETTING</code>可以读取所有的配置。</p>\n</blockquote>\n<p>其中，<code>/Library/Preferences/org.jenkins-ci</code>是 Jenkins 的配置文件所在的位置。</p>\n<p>然后，用<code>defaults</code>读取<code>org.jenkins-ci</code>文件中<code>war</code>、<code>minPermGen</code>、<code>permGen</code>等值，最后使用<code>java -jar</code>来启动 Jenkins 。</p>\n<p>Jenkins 是 Java 程序，运行在 JVM 上。通过上述分析，我们知道，修改<code>org.jenkins-ci</code>这中的键值对，可以达到配置 Jenkins 的目的。</p>\n<p>下面介绍目前几个常用的配置项（当然如果你是一名 Java Web 程序开发者，对 JVM 比我更熟悉，应该可以按照<code>jenkins-runner.sh</code>脚本中的格式修改脚本添加一些自定义配置，这里只是抛砖引玉）：</p>\n<ul>\n<li>war :  war 包的指定位置，默认值：<code>/Applications/Jenkins/jenkins.war</code></li>\n<li>minPermGen :  JVM 的非堆内存空间，将赋值给<code>XX:PermSize</code></li>\n<li>permGen :  JVM 的最大非堆内存空间，将赋值给<code>XX:MaxPermSize</code></li>\n<li>minHeapSize :  JVM 的堆内存空间，将赋值给<code>Xms</code></li>\n<li>heapSize :  JVM 的最大堆内存空间，将赋值给<code>Xmx</code></li>\n<li>tmpdir :  Jenkins 运行的临时存放空间，此值会作为变量赋值给 JVM 的环境变量<code>java.io.tmpdir</code></li>\n<li>JENKINS_HOME :  Jenkins 目录，默认值：<code>/Users/Shared/Jenkins/Home</code>，保存着工作空间， war 包解压后存放在此，插件，用户，节点，日志等等</li>\n<li>prefix : 访问页面的前缀。上述安装后打开的 url 是<code>localhost:8080</code>，当配置 prefix 之后，若配置为<code>/objchris</code>（不可以漏掉<code>/</code>），则访问路径变成<code>localhost:8080/objchris</code>。</li>\n<li>httpPort、httpsport :  http、https 端口</li>\n<li>httpListenAddress、httpsListenAddress : 接收请求 IP ，默认为 0.0.0.0 ，即其他主机也可以访问到，接收任意 IP 发来的请求。若设置为 127.0.0.1 ，则只能本机访问。</li>\n</ul>\n<p>对于配置项，有兴趣的同学可以参考<a href=\"https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins\" target=\"_blank\" rel=\"external\">这里</a>，十分详细且有一些配置示例。</p>\n<p>修改配置，可以使用以下命令：</p>\n<pre><code class=\"shell\">sudo defaults write /Library/Preferences/org.jenkins-ci SETTING VALUE\n</code></pre>\n<p>做错了也没关系，重新 write 一遍或<code>defaults</code>也支持删除：</p>\n<pre><code class=\"shell\">sudo defaults delete /Library/Preferences/org.jenkins-ci SETTING\n</code></pre>\n<h2 id=\"卸载-Jenkins\"><a href=\"#卸载-Jenkins\" class=\"headerlink\" title=\"卸载 Jenkins\"></a>卸载 Jenkins</h2><p>要残忍舍弃 Jenkins 投奔其他 CI 工具的话：</p>\n<pre><code class=\"Shell\">&#39;/Library/Application Support/Jenkins/Uninstall.command&#39;\n</code></pre>\n<p>同样针对使用 <strong>pkg</strong> 安装的方式。</p>\n<p>下载 war 包，直接停止服务删除 war 包就好了。</p>\n<p>使用 homebrew ，有 homebrew 自己的管理方式，不在此说明了。</p>\n<blockquote>\n<p>有时候，遇到一些玄学才能解释的问题（例如文件损坏无法启动 Jenkins …），卸载重装或许也是一个好方法，嗯[正经脸]。</p>\n</blockquote>\n<h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><p>在密林探索开始以前，我们要带上一些工具，给 Jenkins 安装一些插件。</p>\n<p>插件安装在『 系统管理 — 管理插件 』，图标是一块绿色的小拼图。点击进去可以看到可更新、可选插件、已安装、高级。都是望名知意，不多做解释了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gru5l.png\" alt=\"\"></p>\n<p>选择 <em>可选插件</em> ，在过滤处输入想要安装的插件。对我们来说，版本管理工具 Git 或 SVN 用得最多，但是如果一开始安装 Jenkins 的时候已选择社区推荐插件的话，其实已经安装好了 GitHub 的相关插件 <a href=\"http://wiki.jenkins-ci.org/display/JENKINS/Github+Plugin\" target=\"_blank\" rel=\"external\">GitHub plugin</a> 。 SVN 的话，我所使用的 Jenkins 2.113 版本在 war 包内部嵌入了 SVN 的插件 <a href=\"https://wiki.jenkins.io/display/JENKINS/Subversion+Plugin\" target=\"_blank\" rel=\"external\">Subversion Plug-in</a> 。如果公司内部有 Git 服务器，通常是部署的开源 GitLab ，则需要安装<code>GitLab Plugin</code>用于管理源码和<code>Gitlab Hook Plugin</code>用于构建 GitLab 的触发器。</p>\n<p>我的主要目的是 iOS 项目构建，因此还需要选择<code>Xcode integration</code>安装 Xcode 插件，和管理签名证书私钥和 PP 文件的<code>Keychains and Provisioning Profiles Management</code>。</p>\n<p>安装完了这些，我们就可以配置一个构建项目了。</p>\n<h2 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h2><h3 id=\"基本项目配置\"><a href=\"#基本项目配置\" class=\"headerlink\" title=\"基本项目配置\"></a>基本项目配置</h3><p>回到主界面上，点击左上角 <em>新建任务</em> ，进入新建任务界面。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j5l33.png\" alt=\"\"></p>\n<p>确定后，开始项目的通用配置：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tpk2j.png\" alt=\"\"></p>\n<p>我的项目是托管在公司内部 SVN 上的，所以<code>Github Project</code>不打勾，勾上<code>丢弃旧的构建</code>会将构建记录保留一定时间（根据自己需求设置天数）和最大保留个数。<code>参数化构建过程</code>可以为构建过程添加相应的参数。<code>关闭构建</code>主要针对定时任务（下面会说到），顾名思义就是关闭当前任务，自然不会启动定时任务。</p>\n<h3 id=\"源码管理——-SVN\"><a href=\"#源码管理——-SVN\" class=\"headerlink\" title=\"源码管理—— SVN\"></a>源码管理—— SVN</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r6yz.png\" alt=\"\"></p>\n<p>我所在的公司源码管理使用 SVN ，在 Module 中填上 SVN 的一些信息：</p>\n<ul>\n<li>Repository URL ：仓库地址</li>\n<li>Credentials ：用于登录、拉取代码的账户密码</li>\n<li>Local module directory ： 存放在工作空间的位置，每当新建一个任务， Jenkins 会在<code>$HOME</code>目录下的<code>workspace</code>中新建一个以任务名称命名的文件夹。因此，如果此项填入<code>.</code>（默认值就是<code>.</code>），则从 SVN 仓库地址拉取的代码将直接存放在其中。填写其他路径（如<code>./path/to/subfolder</code>），则放在对应的路径中。 <strong>Jenkins 在运行脚本的时候所在的位置是<code>$HOME/workspace/[任务名称]</code>，所以如果此项修改了，添加了其他子文件夹，在下面写运行脚本位置时需要注意路径是否正确。</strong></li>\n<li>Repository depth ：拉取代码时的深度，分别有以下几个：<ul>\n<li>infinity ：遍历所有文件夹，拉取所有文件和文件夹</li>\n<li>empty ：将本地路径初始化，不拉取任何文件</li>\n<li>files ：当前文件夹和文件，不包含子文件夹</li>\n<li>immediates ：当前文件夹、文件、子文件夹，但不遍历子文件夹</li>\n<li>as-it-is ：继承原有的深度</li>\n</ul>\n</li>\n<li>Ignore external ：拉取代码时忽略 external 的属性设置的库。</li>\n<li>Cancel process on externals fail ：拉取 external 的属性设置的库失败时停止。</li>\n</ul>\n<p><code>Check-out Strategy</code>是检出策略。可选择 ：尽可能多地使用<code>svn update</code>，每次都 checkout 一个新的，或使用脚本 checkout ，不需要 Jenkins 帮我们 checkout 等等。</p>\n<h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>我们知道，打包 iOS 需要代码签名( <em>codesign</em> )，也就需要私钥，因此第一步，是先将 keychain 添加到 Jenkins 。</p>\n<h4 id=\"添加-Keychain-和-Provisioning-Profiles\"><a href=\"#添加-Keychain-和-Provisioning-Profiles\" class=\"headerlink\" title=\"添加 Keychain 和 Provisioning Profiles\"></a>添加 Keychain 和 Provisioning Profiles</h4><p>还记得上面安装插件的时候安装了<code>Keychains and Provisioning Profiles Management</code>吗？在构建环境这里，可以看到<code>Keychains and Code Signing Identities</code>选项：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r1ie.png\" alt=\"\"></p>\n<p>但此时还没有配置，所以要先去 <strong>系统管理 —— Keychains and Provisioning Profiles Management</strong>添加 Keychain 和 Provisioning Profiles 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3n7n0.png\" alt=\"\"></p>\n<p>提示我们 Upload Keychain ，选择<code>/Users/管理员用户名/Library/keychains/login.keychain</code>上传。然后输入 Keychain 的密码和签名使用的证书的 Code Signing Identity （ 如：iPhone Distribution: <em>*</em> CO.,LTD (ABCD678EFG) ）</p>\n<p>再上传 Provisioning Profiles ，上传的文件最终位置在<code>/Users/Shared/Jenkins/Home/kpp_upload/</code>。然后将<code>/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profiles</code>填写到页面的<code>Provisioning Profiles Directory Path</code>，然后保存就可以了。</p>\n<p>这样的操作是让 Jenkins 在进行构建的时候将<code>kpp_upload</code>中的 Provisioning Profiles 拷贝到<code>MobileDevice/Provisioning Profiles</code>文件夹中，就跟我们平时安装 Provisioning Profiles 一样。</p>\n<p>完成后大致是这样子：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ac2j7.png\" alt=\"\"></p>\n<p>这里添加了 Developer 和 Distribution 的开发者证书和 Development 和 Ad-hoc 的 Provisioning Profiles 。</p>\n<h4 id=\"配置项目使用的-Keychain\"><a href=\"#配置项目使用的-Keychain\" class=\"headerlink\" title=\"配置项目使用的 Keychain\"></a>配置项目使用的 Keychain</h4><p>回到项目配置中，此时就可以选择 Keychain and Code Signing Identity 了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4wmwm.png\" alt=\"\"></p>\n<p>这里的 Provisioning Profiles 是需要 development 和 ad-hoc 的。</p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>项目构建最简单的方式就是使用脚本了，可以看我前面写过的<a href=\"https://objchris.com/2018/04/02/iOS脚本打包/\" target=\"_blank\" rel=\"external\">文章——iOS脚本打包 - xcodebuild</a>。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l2gp4.png\" alt=\"\"></p>\n<p>增加构建步骤，选择<code>Execute shell</code>，填入脚本：</p>\n<pre><code class=\"shell\">#!/bin/sh -l\n# 解决找不到pod和pod提示语言不对的问题\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport PATH=&quot;/usr/local/bin:$PATH&quot;\necho $PATH\npod --version\n# 解锁用户上传的Keychain\n# KEYCHAIN_PATH 和 KEYCHAIN_PASSWORD 是配置构建环境时，Keychains and Provisioning Profiles Management插件提供，可直接使用\nsecurity list-keychains -s &quot;${KEYCHAIN_PATH}&quot;\nsecurity default-keychain -d user -s &quot;${KEYCHAIN_PATH}&quot;\n# 告诉系统Keychain已解锁，无须再弹出UI\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k &quot;${KEYCHAIN_PASSWORD}&quot; &quot;${KEYCHAIN_PATH}&quot;\nsecurity unlock-keychain -p &quot;${KEYCHAIN_PASSWORD}&quot;\nsecurity show-keychain-info &quot;${KEYCHAIN_PATH}&quot;\nsecurity find-identity -p codesigning -v\n# 执行我们的打包脚本\nsh KeyXBuild.sh\n</code></pre>\n<p>到这里就已经完成打包，得到 ipa 文件了。</p>\n<p>一些构建后的操作就不多说了，或者通过 SVN 上传到某个目录，或者上传到蒲公英这种分发平台。</p>\n<h2 id=\"构建状态提示\"><a href=\"#构建状态提示\" class=\"headerlink\" title=\"构建状态提示\"></a>构建状态提示</h2><p>每一次构建成功失败都会有提示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zm08o.png\" alt=\"\"></p>\n<p>构建结束后可以查看日志输出：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/crs2g.png\" alt=\"\"></p>\n<p>项目构建的成功与否决定了一个项目的分数， Jenkins 使用类似天气预报的样式呈现：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2en18.jpg\" alt=\"\"></p>\n<p>第一次使用 Jenkins ，尝试个四五十次应该就差不多了：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8t6x.png\" alt=\"\"></p>\n<h2 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h2><h3 id=\"bash-pod-command-not-found\"><a href=\"#bash-pod-command-not-found\" class=\"headerlink\" title=\"-bash: pod: command not found\"></a>-bash: pod: command not found</h3><p>前面说过，Jenkins 在安装完成后会创建一个名为 jenkins 的普通用户，我们可以通过 <strong>系统偏好设置 -&gt; 用户与群组</strong> 来修改 jenkins 用户的密码，然后登入到其中。进行一些检查操作。</p>\n<p>我的项目使用到 Cocoapods 来管理第三方库，且<code>Pods</code>这个文件夹没有上传到 SVN 上，只上传了<code>Podfile</code>和<code>Podfile.lock</code>。因此需要在 Jenkins 上进行一次<code>Pod install</code>。这就需要 Jenkins 用户安装 Pod ，这时候就需要登录 jenkins 去完成安装操作了。</p>\n<h3 id=\"Code-Signing-Error-Provisioning-profile-“xxx”-doesn’t-include-signing-certificate-“iPhone-Developer-xxx”\"><a href=\"#Code-Signing-Error-Provisioning-profile-“xxx”-doesn’t-include-signing-certificate-“iPhone-Developer-xxx”\" class=\"headerlink\" title=\"Code Signing Error: Provisioning profile “xxx” doesn’t include signing certificate “iPhone Developer: xxx”\"></a>Code Signing Error: Provisioning profile “xxx” doesn’t include signing certificate “iPhone Developer: xxx”</h3><p>出现此问题是因为，使用 xcodebuild archive 时，指定的 Provisioning profile 和证书都必须是开发使用的。不能是 ad-hoc 或 app store 。</p>\n<p>在 archive 后进行 export 的时候才是使用 ad-hoc 或 app store 的证书和 Provisioning profile 。</p>\n<h3 id=\"codesign：unknown-error-1-ffffffffffffffff\"><a href=\"#codesign：unknown-error-1-ffffffffffffffff\" class=\"headerlink\" title=\"codesign：unknown error -1=ffffffffffffffff\"></a>codesign：unknown error -1=ffffffffffffffff</h3><p>这个问题是没有访问 Keychain 的权限，因为我们的 Keychain 是从 Jenkins 上传的，每次构建时 Jenkins 都会将 Keychain 文件拷贝到工作项目路径中。</p>\n<p>因此我们需要自己手动解锁：</p>\n<pre><code class=\"shell\">security unlock-keychain -p &quot;${KEYCHAIN_PASSWORD}&quot;\n</code></pre>\n<p>在 macOS 10.12 前，这样就可以了。但是新版本中，解锁操作过后还是会弹出UI来解锁 Keychain 。而 Jenkins 是没有用户交互的，所以签名时才会有这个错误出现。</p>\n<p>解决方法是：</p>\n<pre><code class=\"shell\">security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k &quot;${KEYCHAIN_PASSWORD}&quot; &quot;${KEYCHAIN_PATH}&quot;\n</code></pre>\n<p>别忘了其中的<code>codesign:</code>，很多添加了类似命令还是不成功的原因可能是忽略了<code>codesign:</code></p>\n<h3 id=\"Something-of-Keychain\"><a href=\"#Something-of-Keychain\" class=\"headerlink\" title=\"Something of Keychain\"></a>Something of Keychain</h3><p>脚本打包时，会使用<code>~/Library/Keychain</code>中的 login.keychain 。因此，网上很多教程都是将打包使用的证书和私钥（ login.keychain ）直接拷贝到 Jenkins 中，但是这样不利于项目配置。因为不同的项目可能需要不同的证书签名，要添加新证书就需要再次复制 keychain 文件到 jenkins 的<code>~/Library/Keychains</code>下，覆盖原来的<code>login.keychain</code>。这样容易造成老项目无法成功打包（因为旧 keychain 被覆盖）。</p>\n<p>因此，我一直在找如何直接使用 Jenkins 提供的配置去动态添加 keychain ，<strong>Keychains and Provisioning Profiles Management</strong> 插件帮我们完成 keychain 文件和 Provisioning Profiles 的位置问题，但是需要配合<code>Xcode</code>插件去使用。这样让脚本打包变得不方便。</p>\n<p>为了解决这个问题，才有了上面构建脚本中对 Keychain 的一系列操作。</p>\n<h2 id=\"说在最后\"><a href=\"#说在最后\" class=\"headerlink\" title=\"说在最后\"></a>说在最后</h2><p>可能在未来使用过程中会遇到问题，会回来补充。</p>\n<p>つつく</p>\n","excerpt":"<p>说到持续集成，Jenkins 是用得比较多的。本文说明了我从安装到配置再到打包 ipa 文件，从手动打包到点击一下按钮自动生成 ipa 所做的事情。</p>\n<p>得益于 Jenkins ，让开发体验提升了不少。不多说，文内多图，来跟我一起密林探索吧 :]</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aohum.png\" alt=\"Jenkins\"></p>\n<h2 id=\"Jenkins安装\"><a href=\"#Jenkins安装\" class=\"headerlink\" title=\"Jenkins安装\"></a>Jenkins安装</h2><p>本文以 <em>Jenkins</em> 当前时间 <strong>2018.03.27</strong> 的最近 weekly 版本 <em>2.113</em> 来说明， Jenkins 是 Java web 项目，在使用上有 Java 环境的限制：<strong>jdk1.8 以上</strong>。</p>\n<p>对于 macOS10.9 和 10.10 来说，系统中自带有 jdk1.6 ，但这并不符合要求。而其他版本（ macOS10.11 以上）中貌似没有 jdk ，可以在命令行工具键入<code>java -version</code>来判断。</p>\n<p>若出现以下提示，则表示没有配置 Java 环境或系统中没有安装 jdk ：</p>\n<pre><code class=\"Shell\">No Java runtime present, requesting install.\n</code></pre>\n<p>若弹出安装对话框，点击 <strong>『好』</strong> 退出对话框。</p>\n<p>不然，定位到<code>/Library/Java/JavaVirtualMachines</code>中可查看是否存在 jdk 。</p>\n<p>如果都没有，或 jdk 版本不符，则需要重新安装。 macOS 的安装方式比较简单，在<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\">Oracle的jdk下载地址</a>上下载 dmg 安装包，直接安装 jdk1.8 到系统中。然后修改<code>~/.bashrc</code>文件配置一系列的系统变量，如果使用<code>zsh</code>，则修改<code>~/.zshrc</code>。在文件末尾添加：</p>\n<pre><code class=\"shell\"># 通常通过dmg安装的jdk都是在/Library/Java/JavaVirtualMachines/下，需根据实际情况对JAVA_HOME进行配置\nexport JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Content/Home&quot;\nexport CLASS_HOME=&quot;$JAVA_HOME/lib&quot;\nexport PATH=&quot;.;$PATH:$JAVA_HOME/bin&quot;\n</code></pre>\n<p>然后重置一下配置：</p>\n<pre><code class=\"shell\">source ~/.bashrc\n</code></pre>\n<p>或者（使用<code>zsh</code>）</p>\n<pre><code class=\"Shell\">source ~/.zshrc\n</code></pre>\n<p>再次使用<code>java - version</code>验证是否安装成功（全文部分截图是我使用公司电脑安装 Jenkins 时截下来的）：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ve0qh.png\" alt=\"55B9E6EFD1C3099B8203D17D0089360C\"></p>\n<p>好了，然后安装 <strong>Jenkins </strong> 。同样的，在<a href=\"https://jenkins.io/download/\">官网下载页面</a>上选择 <strong>Weekly — Mac OS X</strong> 下载 <em>pkg</em> 安装包。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gz4yg.png\" alt=\"Jenkins Website\"></p>\n<p>以 <strong>2.113</strong> 为例，一步步安装。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9ez6l.png\" alt=\"Jenkins Install Begin\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9dt4k.png\" alt=\"Jenkins Install Step2\"></p>\n<p>安装完成后，会自动打开浏览器，跳转到<code>localhost:8080</code>可以看到 Jenkins 正在准备中…</p>\n<p>如果提示打不开，使用 Safari 出现以下界面：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gaawr.png\" alt=\"Oops Jenkins Start Failed\"></p>\n<p>则可能是 jdk 的配置出了问题，返回去看看前文关于 jdk 的配置，检查一遍是否正确。</p>\n<blockquote>\n<p>注：如果此时重启系统，会发现多了一个名为『 jenkins 』的普通成员。</p>\n</blockquote>\n<p>在 jenkins 初始化工作完成后，会跳转到另一个<strong>解锁  jenkins </strong> 的界面，提示密码存放在<code>/Users/Shared/Jenkins/Home/secrets/initialAdminPassword</code>中，到其中查看，会发现<code>secret</code>文件夹被设置了权限，使用我们当前的用户无读写的权限。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jc4l1.png\" alt=\"解锁jenkins\"></p>\n<p>此时使用命令行工具，键入如下命令，并输入电脑的管理员 root 密码（通常是我们自己的登录密码）后：</p>\n<pre><code class=\"shell\">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword\n</code></pre>\n<p>可以看到 jenkins 的初始化密码：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/s09vt.png\" alt=\"屏幕快照 2018-03-26 下午12.44.11\"></p>\n<p>将该密码填入到网页中，完成解锁工作。<strong>此密码同时是登录 jenkins 的 admin 账户的密码，见下文。</strong></p>\n<p>之后，安装社区推荐的插件即可：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/lg2px.png\" alt=\"屏幕快照 2018-03-26 下午12.45.24\"></p>\n<p>然后创建第一个管理员用户，此处建议自行创建一个用户，当然也可以点击右下角的 <strong>『使用 admin 账户继续』</strong> ，密码是 jenkins 的解锁密码，也就是 initialAdminPassword 里面那个字符串。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cio9r.png\" alt=\"屏幕快照 2018-03-26 下午12.50.00\"></p>\n<p>保存完成后，Congratulation~ 🎉🎉🎉 </p>\n<p>行李已经收拾好了，可以继续 jenkins 密林探索之旅了。</p>\n<h2 id=\"Jenkins配置\"><a href=\"#Jenkins配置\" class=\"headerlink\" title=\"Jenkins配置\"></a>Jenkins配置</h2><p>在安装完 Jenkins 后，就可以愉快地使用它来持续集成我们的项目了，如果对一些启动配置不感兴趣，不想看这一部分，可以愉快地略过，不修改配置也完全不影响使用。</p>\n<p>需要修改配置的情况如下（包括但不完全包括）：</p>\n<ol>\n<li>默认地，当 jenkins 安装在服务器上时，监听的是服务器的 8080 端口。而我们知道，在做 Java Web 开发时，应用服务器 tomcat 的默认端口也是 8080 ，不修改配置的话，很容易造成冲突。</li>\n<li>我们在使用 Jenkins 会安装各种插件，同时运行很多个构建工作，都有可能造成内存溢出的问题。</li>\n<li>当我们需要配置 HTTPS ，证书等等。</li>\n</ol>\n<h3 id=\"启动与关闭\"><a href=\"#启动与关闭\" class=\"headerlink\" title=\"启动与关闭\"></a>启动与关闭</h3><p>首先，针对使用 <strong>pkg</strong> 安装的方式（使用直接下载 war ，用<code>java -jar</code>运行不在本文的讨论范围内。），Jenkins 作为一个后台驻留程序（ <em>Daemon</em> ），在 Wins 下我们习惯叫服务，自然有开关。</p>\n<p>一个后台驻留程序是运行在系统后台的，没有任何GUI的程序。在 macOS 下，一个后台驻留程序的配置保存在一个<code>plist</code>文件中，非系统驻留程序的<code>plist</code>文件都统一存放在<code>/Library/LaunchDaemons</code>之中。</p>\n<p>我们知道，<code>plist</code>本质是 xml 文件，其中存放的都是键值对，里面的键都是 <a href=\"x-man-page://5/launchd.plist\">launch.plist</a> 中定义的，这个<code>plist</code>用于告知<code>launch</code>去哪里运行脚本，以及运行过程中一些路径和用户、组的配置。</p>\n<p>所以，启动和关闭的命令看起来比较少见：</p>\n<pre><code class=\"shell\"># 开启Jenkins\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n# 关闭Jenkins\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n</code></pre>\n<p>打开<code>org.jenkins-ci.plist</code>，看到<code>ProgramArguments</code>，写着运行脚本的位置：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ntvgu.png\" alt=\"019DE0A84C235007987FE3CF18813083\"></p>\n<h3 id=\"JVM的配置\"><a href=\"#JVM的配置\" class=\"headerlink\" title=\"JVM的配置\"></a>JVM的配置</h3><p>接下来，我们来看看 <code>jenkins-runner.sh</code> 这个脚本中的内容。</p>\n<pre><code class=\"shell\">#!/bin/bash\n#\n# Startup script used by Jenkins launchd job.\n# Mac OS X launchd process calls this script to customize\n# the java process command line used to run Jenkins.\n#\n# Customizable parameters are found in\n# /Library/Preferences/org.jenkins-ci.plist\n#\n# You can manipulate it using the &quot;defaults&quot; utility.\n# See &quot;man defaults&quot; for details.\n\ndefaults=&quot;defaults read /Library/Preferences/org.jenkins-ci&quot;\n\nwar=`$defaults war` || war=&quot;/Applications/Jenkins/jenkins.war&quot;\n\njavaArgs=&quot;-Dfile.encoding=UTF-8&quot;\n\nminPermGen=`$defaults minPermGen` &amp;&amp; javaArgs=&quot;$javaArgs -XX:PermSize=${minPermGen}&quot;\npermGen=`$defaults permGen` &amp;&amp; javaArgs=&quot;$javaArgs -XX:MaxPermSize=${permGen}&quot;\n\nminHeapSize=`$defaults minHeapSize` &amp;&amp; javaArgs=&quot;$javaArgs -Xms${minHeapSize}&quot;\nheapSize=`$defaults heapSize` &amp;&amp; javaArgs=&quot;$javaArgs -Xmx${heapSize}&quot;\n\ntmpdir=`$defaults tmpdir` &amp;&amp; javaArgs=&quot;$javaArgs -Djava.io.tmpdir=${tmpdir}&quot;\n\nhome=`$defaults JENKINS_HOME` &amp;&amp; export JENKINS_HOME=&quot;$home&quot;\n\nadd_to_args() {\n    val=`$defaults $1` &amp;&amp; args=&quot;$args --${1}=${val}&quot;\n}\n\nargs=&quot;&quot;\nadd_to_args prefix\nadd_to_args httpPort\nadd_to_args httpListenAddress\nadd_to_args httpsPort\nadd_to_args httpsListenAddress\nadd_to_args httpsKeyStore\nadd_to_args httpsKeyStorePassword\n\necho &quot;JENKINS_HOME=$JENKINS_HOME&quot;\necho &quot;Jenkins command line for execution:&quot;\necho /usr/bin/java $javaArgs -jar &quot;$war&quot; $args\nexec /usr/bin/java $javaArgs -jar &quot;$war&quot; $args\n</code></pre>\n<p>第一行我们看到，给<code>defaults</code>赋了值：</p>\n<pre><code class=\"shell\">defaults read /Library/Preferences/org.jenkins-ci SETTING\n</code></pre>\n<blockquote>\n<p>注：<code>defaults</code> 命令可以用来读取其中的配置项<code>SETTING</code>的值。不写<code>SETTING</code>可以读取所有的配置。</p>\n</blockquote>\n<p>其中，<code>/Library/Preferences/org.jenkins-ci</code>是 Jenkins 的配置文件所在的位置。</p>\n<p>然后，用<code>defaults</code>读取<code>org.jenkins-ci</code>文件中<code>war</code>、<code>minPermGen</code>、<code>permGen</code>等值，最后使用<code>java -jar</code>来启动 Jenkins 。</p>\n<p>Jenkins 是 Java 程序，运行在 JVM 上。通过上述分析，我们知道，修改<code>org.jenkins-ci</code>这中的键值对，可以达到配置 Jenkins 的目的。</p>\n<p>下面介绍目前几个常用的配置项（当然如果你是一名 Java Web 程序开发者，对 JVM 比我更熟悉，应该可以按照<code>jenkins-runner.sh</code>脚本中的格式修改脚本添加一些自定义配置，这里只是抛砖引玉）：</p>\n<ul>\n<li>war :  war 包的指定位置，默认值：<code>/Applications/Jenkins/jenkins.war</code></li>\n<li>minPermGen :  JVM 的非堆内存空间，将赋值给<code>XX:PermSize</code></li>\n<li>permGen :  JVM 的最大非堆内存空间，将赋值给<code>XX:MaxPermSize</code></li>\n<li>minHeapSize :  JVM 的堆内存空间，将赋值给<code>Xms</code></li>\n<li>heapSize :  JVM 的最大堆内存空间，将赋值给<code>Xmx</code></li>\n<li>tmpdir :  Jenkins 运行的临时存放空间，此值会作为变量赋值给 JVM 的环境变量<code>java.io.tmpdir</code></li>\n<li>JENKINS_HOME :  Jenkins 目录，默认值：<code>/Users/Shared/Jenkins/Home</code>，保存着工作空间， war 包解压后存放在此，插件，用户，节点，日志等等</li>\n<li>prefix : 访问页面的前缀。上述安装后打开的 url 是<code>localhost:8080</code>，当配置 prefix 之后，若配置为<code>/objchris</code>（不可以漏掉<code>/</code>），则访问路径变成<code>localhost:8080/objchris</code>。</li>\n<li>httpPort、httpsport :  http、https 端口</li>\n<li>httpListenAddress、httpsListenAddress : 接收请求 IP ，默认为 0.0.0.0 ，即其他主机也可以访问到，接收任意 IP 发来的请求。若设置为 127.0.0.1 ，则只能本机访问。</li>\n</ul>\n<p>对于配置项，有兴趣的同学可以参考<a href=\"https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins\">这里</a>，十分详细且有一些配置示例。</p>\n<p>修改配置，可以使用以下命令：</p>\n<pre><code class=\"shell\">sudo defaults write /Library/Preferences/org.jenkins-ci SETTING VALUE\n</code></pre>\n<p>做错了也没关系，重新 write 一遍或<code>defaults</code>也支持删除：</p>\n<pre><code class=\"shell\">sudo defaults delete /Library/Preferences/org.jenkins-ci SETTING\n</code></pre>\n<h2 id=\"卸载-Jenkins\"><a href=\"#卸载-Jenkins\" class=\"headerlink\" title=\"卸载 Jenkins\"></a>卸载 Jenkins</h2><p>要残忍舍弃 Jenkins 投奔其他 CI 工具的话：</p>\n<pre><code class=\"Shell\">&#39;/Library/Application Support/Jenkins/Uninstall.command&#39;\n</code></pre>\n<p>同样针对使用 <strong>pkg</strong> 安装的方式。</p>\n<p>下载 war 包，直接停止服务删除 war 包就好了。</p>\n<p>使用 homebrew ，有 homebrew 自己的管理方式，不在此说明了。</p>\n<blockquote>\n<p>有时候，遇到一些玄学才能解释的问题（例如文件损坏无法启动 Jenkins …），卸载重装或许也是一个好方法，嗯[正经脸]。</p>\n</blockquote>\n<h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><p>在密林探索开始以前，我们要带上一些工具，给 Jenkins 安装一些插件。</p>\n<p>插件安装在『 系统管理 — 管理插件 』，图标是一块绿色的小拼图。点击进去可以看到可更新、可选插件、已安装、高级。都是望名知意，不多做解释了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gru5l.png\" alt=\"\"></p>\n<p>选择 <em>可选插件</em> ，在过滤处输入想要安装的插件。对我们来说，版本管理工具 Git 或 SVN 用得最多，但是如果一开始安装 Jenkins 的时候已选择社区推荐插件的话，其实已经安装好了 GitHub 的相关插件 <a href=\"http://wiki.jenkins-ci.org/display/JENKINS/Github+Plugin\">GitHub plugin</a> 。 SVN 的话，我所使用的 Jenkins 2.113 版本在 war 包内部嵌入了 SVN 的插件 <a href=\"https://wiki.jenkins.io/display/JENKINS/Subversion+Plugin\">Subversion Plug-in</a> 。如果公司内部有 Git 服务器，通常是部署的开源 GitLab ，则需要安装<code>GitLab Plugin</code>用于管理源码和<code>Gitlab Hook Plugin</code>用于构建 GitLab 的触发器。</p>\n<p>我的主要目的是 iOS 项目构建，因此还需要选择<code>Xcode integration</code>安装 Xcode 插件，和管理签名证书私钥和 PP 文件的<code>Keychains and Provisioning Profiles Management</code>。</p>\n<p>安装完了这些，我们就可以配置一个构建项目了。</p>\n<h2 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h2><h3 id=\"基本项目配置\"><a href=\"#基本项目配置\" class=\"headerlink\" title=\"基本项目配置\"></a>基本项目配置</h3><p>回到主界面上，点击左上角 <em>新建任务</em> ，进入新建任务界面。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j5l33.png\" alt=\"\"></p>\n<p>确定后，开始项目的通用配置：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tpk2j.png\" alt=\"\"></p>\n<p>我的项目是托管在公司内部 SVN 上的，所以<code>Github Project</code>不打勾，勾上<code>丢弃旧的构建</code>会将构建记录保留一定时间（根据自己需求设置天数）和最大保留个数。<code>参数化构建过程</code>可以为构建过程添加相应的参数。<code>关闭构建</code>主要针对定时任务（下面会说到），顾名思义就是关闭当前任务，自然不会启动定时任务。</p>\n<h3 id=\"源码管理——-SVN\"><a href=\"#源码管理——-SVN\" class=\"headerlink\" title=\"源码管理—— SVN\"></a>源码管理—— SVN</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r6yz.png\" alt=\"\"></p>\n<p>我所在的公司源码管理使用 SVN ，在 Module 中填上 SVN 的一些信息：</p>\n<ul>\n<li>Repository URL ：仓库地址</li>\n<li>Credentials ：用于登录、拉取代码的账户密码</li>\n<li>Local module directory ： 存放在工作空间的位置，每当新建一个任务， Jenkins 会在<code>$HOME</code>目录下的<code>workspace</code>中新建一个以任务名称命名的文件夹。因此，如果此项填入<code>.</code>（默认值就是<code>.</code>），则从 SVN 仓库地址拉取的代码将直接存放在其中。填写其他路径（如<code>./path/to/subfolder</code>），则放在对应的路径中。 <strong>Jenkins 在运行脚本的时候所在的位置是<code>$HOME/workspace/[任务名称]</code>，所以如果此项修改了，添加了其他子文件夹，在下面写运行脚本位置时需要注意路径是否正确。</strong></li>\n<li>Repository depth ：拉取代码时的深度，分别有以下几个：<ul>\n<li>infinity ：遍历所有文件夹，拉取所有文件和文件夹</li>\n<li>empty ：将本地路径初始化，不拉取任何文件</li>\n<li>files ：当前文件夹和文件，不包含子文件夹</li>\n<li>immediates ：当前文件夹、文件、子文件夹，但不遍历子文件夹</li>\n<li>as-it-is ：继承原有的深度</li>\n</ul>\n</li>\n<li>Ignore external ：拉取代码时忽略 external 的属性设置的库。</li>\n<li>Cancel process on externals fail ：拉取 external 的属性设置的库失败时停止。</li>\n</ul>\n<p><code>Check-out Strategy</code>是检出策略。可选择 ：尽可能多地使用<code>svn update</code>，每次都 checkout 一个新的，或使用脚本 checkout ，不需要 Jenkins 帮我们 checkout 等等。</p>\n<h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>我们知道，打包 iOS 需要代码签名( <em>codesign</em> )，也就需要私钥，因此第一步，是先将 keychain 添加到 Jenkins 。</p>\n<h4 id=\"添加-Keychain-和-Provisioning-Profiles\"><a href=\"#添加-Keychain-和-Provisioning-Profiles\" class=\"headerlink\" title=\"添加 Keychain 和 Provisioning Profiles\"></a>添加 Keychain 和 Provisioning Profiles</h4><p>还记得上面安装插件的时候安装了<code>Keychains and Provisioning Profiles Management</code>吗？在构建环境这里，可以看到<code>Keychains and Code Signing Identities</code>选项：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7r1ie.png\" alt=\"\"></p>\n<p>但此时还没有配置，所以要先去 <strong>系统管理 —— Keychains and Provisioning Profiles Management</strong>添加 Keychain 和 Provisioning Profiles 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3n7n0.png\" alt=\"\"></p>\n<p>提示我们 Upload Keychain ，选择<code>/Users/管理员用户名/Library/keychains/login.keychain</code>上传。然后输入 Keychain 的密码和签名使用的证书的 Code Signing Identity （ 如：iPhone Distribution: <em>*</em> CO.,LTD (ABCD678EFG) ）</p>\n<p>再上传 Provisioning Profiles ，上传的文件最终位置在<code>/Users/Shared/Jenkins/Home/kpp_upload/</code>。然后将<code>/Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profiles</code>填写到页面的<code>Provisioning Profiles Directory Path</code>，然后保存就可以了。</p>\n<p>这样的操作是让 Jenkins 在进行构建的时候将<code>kpp_upload</code>中的 Provisioning Profiles 拷贝到<code>MobileDevice/Provisioning Profiles</code>文件夹中，就跟我们平时安装 Provisioning Profiles 一样。</p>\n<p>完成后大致是这样子：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ac2j7.png\" alt=\"\"></p>\n<p>这里添加了 Developer 和 Distribution 的开发者证书和 Development 和 Ad-hoc 的 Provisioning Profiles 。</p>\n<h4 id=\"配置项目使用的-Keychain\"><a href=\"#配置项目使用的-Keychain\" class=\"headerlink\" title=\"配置项目使用的 Keychain\"></a>配置项目使用的 Keychain</h4><p>回到项目配置中，此时就可以选择 Keychain and Code Signing Identity 了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4wmwm.png\" alt=\"\"></p>\n<p>这里的 Provisioning Profiles 是需要 development 和 ad-hoc 的。</p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>项目构建最简单的方式就是使用脚本了，可以看我前面写过的<a href=\"https://objchris.com/2018/04/02/iOS脚本打包/\">文章——iOS脚本打包 - xcodebuild</a>。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l2gp4.png\" alt=\"\"></p>\n<p>增加构建步骤，选择<code>Execute shell</code>，填入脚本：</p>\n<pre><code class=\"shell\">#!/bin/sh -l\n# 解决找不到pod和pod提示语言不对的问题\nexport LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\nexport PATH=&quot;/usr/local/bin:$PATH&quot;\necho $PATH\npod --version\n# 解锁用户上传的Keychain\n# KEYCHAIN_PATH 和 KEYCHAIN_PASSWORD 是配置构建环境时，Keychains and Provisioning Profiles Management插件提供，可直接使用\nsecurity list-keychains -s &quot;${KEYCHAIN_PATH}&quot;\nsecurity default-keychain -d user -s &quot;${KEYCHAIN_PATH}&quot;\n# 告诉系统Keychain已解锁，无须再弹出UI\nsecurity set-key-partition-list -S apple-tool:,apple:,codesign: -s -k &quot;${KEYCHAIN_PASSWORD}&quot; &quot;${KEYCHAIN_PATH}&quot;\nsecurity unlock-keychain -p &quot;${KEYCHAIN_PASSWORD}&quot;\nsecurity show-keychain-info &quot;${KEYCHAIN_PATH}&quot;\nsecurity find-identity -p codesigning -v\n# 执行我们的打包脚本\nsh KeyXBuild.sh\n</code></pre>\n<p>到这里就已经完成打包，得到 ipa 文件了。</p>\n<p>一些构建后的操作就不多说了，或者通过 SVN 上传到某个目录，或者上传到蒲公英这种分发平台。</p>\n<h2 id=\"构建状态提示\"><a href=\"#构建状态提示\" class=\"headerlink\" title=\"构建状态提示\"></a>构建状态提示</h2><p>每一次构建成功失败都会有提示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zm08o.png\" alt=\"\"></p>\n<p>构建结束后可以查看日志输出：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/crs2g.png\" alt=\"\"></p>\n<p>项目构建的成功与否决定了一个项目的分数， Jenkins 使用类似天气预报的样式呈现：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2en18.jpg\" alt=\"\"></p>\n<p>第一次使用 Jenkins ，尝试个四五十次应该就差不多了：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8t6x.png\" alt=\"\"></p>\n<h2 id=\"Troubleshooting\"><a href=\"#Troubleshooting\" class=\"headerlink\" title=\"Troubleshooting\"></a>Troubleshooting</h2><h3 id=\"bash-pod-command-not-found\"><a href=\"#bash-pod-command-not-found\" class=\"headerlink\" title=\"-bash: pod: command not found\"></a>-bash: pod: command not found</h3><p>前面说过，Jenkins 在安装完成后会创建一个名为 jenkins 的普通用户，我们可以通过 <strong>系统偏好设置 -&gt; 用户与群组</strong> 来修改 jenkins 用户的密码，然后登入到其中。进行一些检查操作。</p>\n<p>我的项目使用到 Cocoapods 来管理第三方库，且<code>Pods</code>这个文件夹没有上传到 SVN 上，只上传了<code>Podfile</code>和<code>Podfile.lock</code>。因此需要在 Jenkins 上进行一次<code>Pod install</code>。这就需要 Jenkins 用户安装 Pod ，这时候就需要登录 jenkins 去完成安装操作了。</p>\n<h3 id=\"Code-Signing-Error-Provisioning-profile-“xxx”-doesn’t-include-signing-certificate-“iPhone-Developer-xxx”\"><a href=\"#Code-Signing-Error-Provisioning-profile-“xxx”-doesn’t-include-signing-certificate-“iPhone-Developer-xxx”\" class=\"headerlink\" title=\"Code Signing Error: Provisioning profile “xxx” doesn’t include signing certificate “iPhone Developer: xxx”\"></a>Code Signing Error: Provisioning profile “xxx” doesn’t include signing certificate “iPhone Developer: xxx”</h3><p>出现此问题是因为，使用 xcodebuild archive 时，指定的 Provisioning profile 和证书都必须是开发使用的。不能是 ad-hoc 或 app store 。</p>\n<p>在 archive 后进行 export 的时候才是使用 ad-hoc 或 app store 的证书和 Provisioning profile 。</p>\n<h3 id=\"codesign：unknown-error-1-ffffffffffffffff\"><a href=\"#codesign：unknown-error-1-ffffffffffffffff\" class=\"headerlink\" title=\"codesign：unknown error -1=ffffffffffffffff\"></a>codesign：unknown error -1=ffffffffffffffff</h3><p>这个问题是没有访问 Keychain 的权限，因为我们的 Keychain 是从 Jenkins 上传的，每次构建时 Jenkins 都会将 Keychain 文件拷贝到工作项目路径中。</p>\n<p>因此我们需要自己手动解锁：</p>\n<pre><code class=\"shell\">security unlock-keychain -p &quot;${KEYCHAIN_PASSWORD}&quot;\n</code></pre>\n<p>在 macOS 10.12 前，这样就可以了。但是新版本中，解锁操作过后还是会弹出UI来解锁 Keychain 。而 Jenkins 是没有用户交互的，所以签名时才会有这个错误出现。</p>\n<p>解决方法是：</p>\n<pre><code class=\"shell\">security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k &quot;${KEYCHAIN_PASSWORD}&quot; &quot;${KEYCHAIN_PATH}&quot;\n</code></pre>\n<p>别忘了其中的<code>codesign:</code>，很多添加了类似命令还是不成功的原因可能是忽略了<code>codesign:</code></p>\n<h3 id=\"Something-of-Keychain\"><a href=\"#Something-of-Keychain\" class=\"headerlink\" title=\"Something of Keychain\"></a>Something of Keychain</h3><p>脚本打包时，会使用<code>~/Library/Keychain</code>中的 login.keychain 。因此，网上很多教程都是将打包使用的证书和私钥（ login.keychain ）直接拷贝到 Jenkins 中，但是这样不利于项目配置。因为不同的项目可能需要不同的证书签名，要添加新证书就需要再次复制 keychain 文件到 jenkins 的<code>~/Library/Keychains</code>下，覆盖原来的<code>login.keychain</code>。这样容易造成老项目无法成功打包（因为旧 keychain 被覆盖）。</p>\n<p>因此，我一直在找如何直接使用 Jenkins 提供的配置去动态添加 keychain ，<strong>Keychains and Provisioning Profiles Management</strong> 插件帮我们完成 keychain 文件和 Provisioning Profiles 的位置问题，但是需要配合<code>Xcode</code>插件去使用。这样让脚本打包变得不方便。</p>\n<p>为了解决这个问题，才有了上面构建脚本中对 Keychain 的一系列操作。</p>\n<h2 id=\"说在最后\"><a href=\"#说在最后\" class=\"headerlink\" title=\"说在最后\"></a>说在最后</h2><p>可能在未来使用过程中会遇到问题，会回来补充。</p>\n<p>つつく</p>"},{"title":"Autoresizing Mask","date":"2016-03-19T15:41:26.000Z","typora-copy-images-to":"ipic","_content":"\n不知道大家在开发的时候会不会使用到 UIView 的 autoresizingMask 属性。我自己的话自从开始出现 autoLayout 就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。\n\n<!--more-->\n\n# autoresizingMask\n它对应着一个枚举，属性是自动调整 SubView 和 SuperView 之间的位置和宽高。\n```\nenum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n   UIViewAutoresizingFlexibleWidth        = 1 << 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n   UIViewAutoresizingFlexibleHeight       = 1 << 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n## 简单介绍\n### UIViewAutoresizingNone\n不设置自动调整，默认值\n### UIViewAutoresizingFlexibleRightMargin \n这里就只讲 UIViewAutoresizingFlexibleRightMargin ，因为上下左右四个方位是一致的原理\n![autoresizingMask_FlexibleRightMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg)\n\n### UIViewAutoresizingFlexibleWidth\nUIViewAutoresizingFlexibleWidth 和 UIViewAutoresizingFlexibleHeight 也是同样的原理\n![autoresizingMask_FlexibleWidthCompare](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg)\n\n### 组合起来\n枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：\n``` objc\nUIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n```\n表示左右间隔都可以修改，效果就像上面那张图一样~\n\n## 有点代码对比会好些\n``` objc\n#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@\"Ezfen\"];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n```\n\n上面的代码中尺寸宽度被限定为 iPhone4s 的 320 。没有设置子 View（蓝色的 View ）的 autoresizingMask 属性的话运行结果如下：\n![autoresizingMask_4s](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg)\n\n设置了子 View（蓝色的 View ）autoresizingMask 后，再修改父 View 的宽度，可以看到随着赋值的不同，有不同的效果：\n设置了 UIViewAutoresizingFlexibleLeftMargin\n![autoresizingMask_FlexibleLeftMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg)\n\n还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~\n","source":"_posts/autoresizingMask.md","raw":"---\ntitle: Autoresizing Mask\ndate: 2016-03-19 23:41:26\ntags: \n- UIView\ntypora-copy-images-to: ipic\n---\n\n不知道大家在开发的时候会不会使用到 UIView 的 autoresizingMask 属性。我自己的话自从开始出现 autoLayout 就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。\n\n<!--more-->\n\n# autoresizingMask\n它对应着一个枚举，属性是自动调整 SubView 和 SuperView 之间的位置和宽高。\n```\nenum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n   UIViewAutoresizingFlexibleWidth        = 1 << 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n   UIViewAutoresizingFlexibleHeight       = 1 << 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n## 简单介绍\n### UIViewAutoresizingNone\n不设置自动调整，默认值\n### UIViewAutoresizingFlexibleRightMargin \n这里就只讲 UIViewAutoresizingFlexibleRightMargin ，因为上下左右四个方位是一致的原理\n![autoresizingMask_FlexibleRightMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg)\n\n### UIViewAutoresizingFlexibleWidth\nUIViewAutoresizingFlexibleWidth 和 UIViewAutoresizingFlexibleHeight 也是同样的原理\n![autoresizingMask_FlexibleWidthCompare](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg)\n\n### 组合起来\n枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：\n``` objc\nUIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n```\n表示左右间隔都可以修改，效果就像上面那张图一样~\n\n## 有点代码对比会好些\n``` objc\n#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@\"Ezfen\"];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n```\n\n上面的代码中尺寸宽度被限定为 iPhone4s 的 320 。没有设置子 View（蓝色的 View ）的 autoresizingMask 属性的话运行结果如下：\n![autoresizingMask_4s](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg)\n\n设置了子 View（蓝色的 View ）autoresizingMask 后，再修改父 View 的宽度，可以看到随着赋值的不同，有不同的效果：\n设置了 UIViewAutoresizingFlexibleLeftMargin\n![autoresizingMask_FlexibleLeftMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg)\n\n还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~\n","slug":"autoresizingMask","published":1,"updated":"2018-11-06T12:23:18.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dn0005qu0xdxm9vi19","content":"<p>不知道大家在开发的时候会不会使用到 UIView 的 autoresizingMask 属性。我自己的话自从开始出现 autoLayout 就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"autoresizingMask\"><a href=\"#autoresizingMask\" class=\"headerlink\" title=\"autoresizingMask\"></a>autoresizingMask</h1><p>它对应着一个枚举，属性是自动调整 SubView 和 SuperView 之间的位置和宽高。</p>\n<pre><code>enum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,\n   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,\n   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5\n};\n</code></pre><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><h3 id=\"UIViewAutoresizingNone\"><a href=\"#UIViewAutoresizingNone\" class=\"headerlink\" title=\"UIViewAutoresizingNone\"></a>UIViewAutoresizingNone</h3><p>不设置自动调整，默认值</p>\n<h3 id=\"UIViewAutoresizingFlexibleRightMargin\"><a href=\"#UIViewAutoresizingFlexibleRightMargin\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleRightMargin\"></a>UIViewAutoresizingFlexibleRightMargin</h3><p>这里就只讲 UIViewAutoresizingFlexibleRightMargin ，因为上下左右四个方位是一致的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg\" alt=\"autoresizingMask_FlexibleRightMargin\"></p>\n<h3 id=\"UIViewAutoresizingFlexibleWidth\"><a href=\"#UIViewAutoresizingFlexibleWidth\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleWidth\"></a>UIViewAutoresizingFlexibleWidth</h3><p>UIViewAutoresizingFlexibleWidth 和 UIViewAutoresizingFlexibleHeight 也是同样的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg\" alt=\"autoresizingMask_FlexibleWidthCompare\"></p>\n<h3 id=\"组合起来\"><a href=\"#组合起来\" class=\"headerlink\" title=\"组合起来\"></a>组合起来</h3><p>枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：</p>\n<pre><code class=\"objc\">UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n</code></pre>\n<p>表示左右间隔都可以修改，效果就像上面那张图一样~</p>\n<h2 id=\"有点代码对比会好些\"><a href=\"#有点代码对比会好些\" class=\"headerlink\" title=\"有点代码对比会好些\"></a>有点代码对比会好些</h2><pre><code class=\"objc\">#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@&quot;Ezfen&quot;];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n</code></pre>\n<p>上面的代码中尺寸宽度被限定为 iPhone4s 的 320 。没有设置子 View（蓝色的 View ）的 autoresizingMask 属性的话运行结果如下：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg\" alt=\"autoresizingMask_4s\"></p>\n<p>设置了子 View（蓝色的 View ）autoresizingMask 后，再修改父 View 的宽度，可以看到随着赋值的不同，有不同的效果：<br>设置了 UIViewAutoresizingFlexibleLeftMargin<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg\" alt=\"autoresizingMask_FlexibleLeftMargin\"></p>\n<p>还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~</p>\n","excerpt":"<p>不知道大家在开发的时候会不会使用到 UIView 的 autoresizingMask 属性。我自己的话自从开始出现 autoLayout 就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。</p>","more":"<h1 id=\"autoresizingMask\"><a href=\"#autoresizingMask\" class=\"headerlink\" title=\"autoresizingMask\"></a>autoresizingMask</h1><p>它对应着一个枚举，属性是自动调整 SubView 和 SuperView 之间的位置和宽高。</p>\n<pre><code>enum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,\n   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,\n   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5\n};\n</code></pre><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><h3 id=\"UIViewAutoresizingNone\"><a href=\"#UIViewAutoresizingNone\" class=\"headerlink\" title=\"UIViewAutoresizingNone\"></a>UIViewAutoresizingNone</h3><p>不设置自动调整，默认值</p>\n<h3 id=\"UIViewAutoresizingFlexibleRightMargin\"><a href=\"#UIViewAutoresizingFlexibleRightMargin\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleRightMargin\"></a>UIViewAutoresizingFlexibleRightMargin</h3><p>这里就只讲 UIViewAutoresizingFlexibleRightMargin ，因为上下左右四个方位是一致的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg\" alt=\"autoresizingMask_FlexibleRightMargin\"></p>\n<h3 id=\"UIViewAutoresizingFlexibleWidth\"><a href=\"#UIViewAutoresizingFlexibleWidth\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleWidth\"></a>UIViewAutoresizingFlexibleWidth</h3><p>UIViewAutoresizingFlexibleWidth 和 UIViewAutoresizingFlexibleHeight 也是同样的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg\" alt=\"autoresizingMask_FlexibleWidthCompare\"></p>\n<h3 id=\"组合起来\"><a href=\"#组合起来\" class=\"headerlink\" title=\"组合起来\"></a>组合起来</h3><p>枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：</p>\n<pre><code class=\"objc\">UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n</code></pre>\n<p>表示左右间隔都可以修改，效果就像上面那张图一样~</p>\n<h2 id=\"有点代码对比会好些\"><a href=\"#有点代码对比会好些\" class=\"headerlink\" title=\"有点代码对比会好些\"></a>有点代码对比会好些</h2><pre><code class=\"objc\">#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@&quot;Ezfen&quot;];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n</code></pre>\n<p>上面的代码中尺寸宽度被限定为 iPhone4s 的 320 。没有设置子 View（蓝色的 View ）的 autoresizingMask 属性的话运行结果如下：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg\" alt=\"autoresizingMask_4s\"></p>\n<p>设置了子 View（蓝色的 View ）autoresizingMask 后，再修改父 View 的宽度，可以看到随着赋值的不同，有不同的效果：<br>设置了 UIViewAutoresizingFlexibleLeftMargin<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg\" alt=\"autoresizingMask_FlexibleLeftMargin\"></p>\n<p>还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~</p>"},{"title":"Hello World Again","date":"2017-02-17T12:04:10.000Z","typora-copy-images-to":"ipic","_content":"决定给博客的名字起为**童年 CHILDHOOD**。\n\n**如童年般纯真，热爱，不朽。**\n\n趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前 Hexo 的 yilia 主题。所以换个博客主题，Hello World Again 。\n\n<!-- more -->\n\n## 开始捣鼓\n\n不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了 hollow 主题，并在其上进行修改。\n\n### 主页\n\n主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了 yilia ，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。\n\nhollow 主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。\n\n### Tags\n\n进入标签页面在主页右上角的 *井号* 按钮，标签页面是显示所有标签。\n\n因为暂时不支持站内搜索（还在构思中...），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。\n\n我是通过修改page.ejs来达到目的。\n\n``` html\n<section class=\"article-container\">\n<!-- Back Home -->\n<%- partial('_partial/backhome') %>\n\n<!-- Page Header -->\n<header class=\"intro-header\">\n    <div class=\"container\">\n        <div class=\"row\">\n            <div class=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <div class=\"post-heading\">\n                    <h1>TAGS</h1>\n                </div>\n            </div>\n        </div>\n    </div>\n</header>\n\n<!-- Post Content -->\n<article>\n    <div class=\"container\">\n        <div class=\"row\">\n            <!-- Post Main Content -->\n            <div class=\"post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <% site.tags.each(function(category){ %>\n                    <a class=\"category\" href=\"<%-category.name%>\"><%-category.name%></a>\n                <% }); %>\n            </div>\n        </div>\n    </div>\n</article>\n</section>\n<!-- Back to top -->\n<%- partial('_partial/backtop') %>\n```\n\n修改完 page.ejs 后，执行 `hexo new page \"tags\"` 就可以创建 tags 页了。然后调整格式就可以了。\n\n### About（最近修改中...）\n\n这个页面是自己添加的。\n\n这个页面是最复杂的。首先Hexo只支持 `index`,`page`,`post`,`layout`,`archive` 这几种自定义页面，所以修改了`page`后作为 category 页面之后就不能通过修改项目页面模板来添加新的自定义页面了。\n\n但是好在 Hexo 还是比较人性化的。\n\n除了修改 Hexo 的模板，有两种方法可以实现自定义页面\n\n1. 先执行`hexo new page \"xxx\"`，在 source 中出现 xxx 文件夹，其中有 xxx.md ，然后在 xxx.md 前加上`layout:false`，可以绕过 Hexo 解析，直接将 md 中的内容显示出来，这样就可以在 md 里面写 html 代码了。详见[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)\n2. 执行`hexo new page \"xxx\"`，同样得到 xxx 文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建 html，css，js，whatever you want 。然后记得在博客的主 _config.yml 中的 skip_render 项添加 xxx/** ，就可以了。\n\n### 评论\n\n评论就不加啦，毕竟清清爽爽还是最爱啊。\n\n而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。\n\n厌倦了多说等评论管理平台的话，推荐一个 [Gitment](https://github.com/imsun/gitment)，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在 Github 的 issue 里面，很适合托管在第三方服务器空间的博客使用。\n\n有问题在微博等社交平台联系吧。\n\n### 域名和全站 HTTPS\n\n域名在万网上购买，实名认证，解析到 github page 。都是很简单的操作。\n\n在实现全站 HTTPS 的时候走了不少弯路。主要想实现的有如下几点：\n\n- [x] 全站小绿锁\n\n\n- [x] 怕 HTTPS 慢，所以上 CDN\n\n\n- [ ] ~~自定义 SSL 证书~~ (无解)\n\n因为博客是托管在 Github 上的，要强制 HTTPS，Coding 可以做到，但是没有必要再部署一套到 Coding 上。所以就想到使用 CDN 来实现，顺便解决网页的访问速度问题。\n\nCDN 有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义 SSL 证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。\n\n工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的 CDN 厂商 [Cloudflare](https://www.cloudflare.com/) 来解析我的域名，Cloudflare 和百度云合作，在国内也有 CDN 服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。\n\n在 Cloudflare 成功解析后，在 Page rules 中定义重定向，将`http` 301 永久重定向到`https`。Cloudflare 还可以设置缓存时间，设置用户与 DNS 、DNS 与我们博客的服务器之间是否使用 SSL ，压缩 CSS、JS ，永久在线（不定时向服务器请求数据），安全级别（防 DDoS ）等。\n\n设置完后，看到了久违的小绿锁：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png)\n\n但是，点击文章，可以看到：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png)\n\n访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供`https`的二级域名，但现在已经关闭，要使用`https`需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云 COS 上，腾讯云 COS 就有支持 SSL 的图床测试域名，且提供 CDN 服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。\n\n所以，Congratulations~ 😄😄😄🎉🎉🎉~\n\n## 写在后面\n\n总有一些奇思妙想，所以本文仍在不断更新...\n\n博客是在 hollow 主题的[创作家](https://github.com/zchen9/hexo-theme-hollow)的基础上进行修改的，对此表示最真挚的感谢，开源万岁。\n\n如果要自己写主题，[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)记得多看看。\n\n对于域名购买和 Cloudflare 、腾讯云的使用， Google 可以搜到许多精彩且详细的文章，此处就不再赘述了。\n\n### 对于这次实践的总结：\n\n* 虽然是 Node.js 小白，但勉强做得出来，因为一行 nodejs 的代码都没写到\n* HTML、CSS、JS 可以做很多事情\n* 需要学习下 ejs、stylus ，都不是很难\n* 多看看别人的代码，很受启发","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World Again\ndate: 2017-2-17 20:04:10\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n决定给博客的名字起为**童年 CHILDHOOD**。\n\n**如童年般纯真，热爱，不朽。**\n\n趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前 Hexo 的 yilia 主题。所以换个博客主题，Hello World Again 。\n\n<!-- more -->\n\n## 开始捣鼓\n\n不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了 hollow 主题，并在其上进行修改。\n\n### 主页\n\n主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了 yilia ，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。\n\nhollow 主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。\n\n### Tags\n\n进入标签页面在主页右上角的 *井号* 按钮，标签页面是显示所有标签。\n\n因为暂时不支持站内搜索（还在构思中...），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。\n\n我是通过修改page.ejs来达到目的。\n\n``` html\n<section class=\"article-container\">\n<!-- Back Home -->\n<%- partial('_partial/backhome') %>\n\n<!-- Page Header -->\n<header class=\"intro-header\">\n    <div class=\"container\">\n        <div class=\"row\">\n            <div class=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <div class=\"post-heading\">\n                    <h1>TAGS</h1>\n                </div>\n            </div>\n        </div>\n    </div>\n</header>\n\n<!-- Post Content -->\n<article>\n    <div class=\"container\">\n        <div class=\"row\">\n            <!-- Post Main Content -->\n            <div class=\"post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <% site.tags.each(function(category){ %>\n                    <a class=\"category\" href=\"<%-category.name%>\"><%-category.name%></a>\n                <% }); %>\n            </div>\n        </div>\n    </div>\n</article>\n</section>\n<!-- Back to top -->\n<%- partial('_partial/backtop') %>\n```\n\n修改完 page.ejs 后，执行 `hexo new page \"tags\"` 就可以创建 tags 页了。然后调整格式就可以了。\n\n### About（最近修改中...）\n\n这个页面是自己添加的。\n\n这个页面是最复杂的。首先Hexo只支持 `index`,`page`,`post`,`layout`,`archive` 这几种自定义页面，所以修改了`page`后作为 category 页面之后就不能通过修改项目页面模板来添加新的自定义页面了。\n\n但是好在 Hexo 还是比较人性化的。\n\n除了修改 Hexo 的模板，有两种方法可以实现自定义页面\n\n1. 先执行`hexo new page \"xxx\"`，在 source 中出现 xxx 文件夹，其中有 xxx.md ，然后在 xxx.md 前加上`layout:false`，可以绕过 Hexo 解析，直接将 md 中的内容显示出来，这样就可以在 md 里面写 html 代码了。详见[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)\n2. 执行`hexo new page \"xxx\"`，同样得到 xxx 文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建 html，css，js，whatever you want 。然后记得在博客的主 _config.yml 中的 skip_render 项添加 xxx/** ，就可以了。\n\n### 评论\n\n评论就不加啦，毕竟清清爽爽还是最爱啊。\n\n而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。\n\n厌倦了多说等评论管理平台的话，推荐一个 [Gitment](https://github.com/imsun/gitment)，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在 Github 的 issue 里面，很适合托管在第三方服务器空间的博客使用。\n\n有问题在微博等社交平台联系吧。\n\n### 域名和全站 HTTPS\n\n域名在万网上购买，实名认证，解析到 github page 。都是很简单的操作。\n\n在实现全站 HTTPS 的时候走了不少弯路。主要想实现的有如下几点：\n\n- [x] 全站小绿锁\n\n\n- [x] 怕 HTTPS 慢，所以上 CDN\n\n\n- [ ] ~~自定义 SSL 证书~~ (无解)\n\n因为博客是托管在 Github 上的，要强制 HTTPS，Coding 可以做到，但是没有必要再部署一套到 Coding 上。所以就想到使用 CDN 来实现，顺便解决网页的访问速度问题。\n\nCDN 有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义 SSL 证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。\n\n工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的 CDN 厂商 [Cloudflare](https://www.cloudflare.com/) 来解析我的域名，Cloudflare 和百度云合作，在国内也有 CDN 服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。\n\n在 Cloudflare 成功解析后，在 Page rules 中定义重定向，将`http` 301 永久重定向到`https`。Cloudflare 还可以设置缓存时间，设置用户与 DNS 、DNS 与我们博客的服务器之间是否使用 SSL ，压缩 CSS、JS ，永久在线（不定时向服务器请求数据），安全级别（防 DDoS ）等。\n\n设置完后，看到了久违的小绿锁：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png)\n\n但是，点击文章，可以看到：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png)\n\n访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供`https`的二级域名，但现在已经关闭，要使用`https`需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云 COS 上，腾讯云 COS 就有支持 SSL 的图床测试域名，且提供 CDN 服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。\n\n所以，Congratulations~ 😄😄😄🎉🎉🎉~\n\n## 写在后面\n\n总有一些奇思妙想，所以本文仍在不断更新...\n\n博客是在 hollow 主题的[创作家](https://github.com/zchen9/hexo-theme-hollow)的基础上进行修改的，对此表示最真挚的感谢，开源万岁。\n\n如果要自己写主题，[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)记得多看看。\n\n对于域名购买和 Cloudflare 、腾讯云的使用， Google 可以搜到许多精彩且详细的文章，此处就不再赘述了。\n\n### 对于这次实践的总结：\n\n* 虽然是 Node.js 小白，但勉强做得出来，因为一行 nodejs 的代码都没写到\n* HTML、CSS、JS 可以做很多事情\n* 需要学习下 ejs、stylus ，都不是很难\n* 多看看别人的代码，很受启发","slug":"hello-world","published":1,"updated":"2018-11-06T12:30:26.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dn0006qu0x8akg57t0","content":"<p>决定给博客的名字起为<strong>童年 CHILDHOOD</strong>。</p>\n<p><strong>如童年般纯真，热爱，不朽。</strong></p>\n<p>趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前 Hexo 的 yilia 主题。所以换个博客主题，Hello World Again 。</p>\n<a id=\"more\"></a>\n<h2 id=\"开始捣鼓\"><a href=\"#开始捣鼓\" class=\"headerlink\" title=\"开始捣鼓\"></a>开始捣鼓</h2><p>不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了 hollow 主题，并在其上进行修改。</p>\n<h3 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h3><p>主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了 yilia ，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。</p>\n<p>hollow 主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。</p>\n<h3 id=\"Tags\"><a href=\"#Tags\" class=\"headerlink\" title=\"Tags\"></a>Tags</h3><p>进入标签页面在主页右上角的 <em>井号</em> 按钮，标签页面是显示所有标签。</p>\n<p>因为暂时不支持站内搜索（还在构思中…），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。</p>\n<p>我是通过修改page.ejs来达到目的。</p>\n<pre><code class=\"html\">&lt;section class=&quot;article-container&quot;&gt;\n&lt;!-- Back Home --&gt;\n&lt;%- partial(&#39;_partial/backhome&#39;) %&gt;\n\n&lt;!-- Page Header --&gt;\n&lt;header class=&quot;intro-header&quot;&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;div class=&quot;post-heading&quot;&gt;\n                    &lt;h1&gt;TAGS&lt;/h1&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/header&gt;\n\n&lt;!-- Post Content --&gt;\n&lt;article&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;!-- Post Main Content --&gt;\n            &lt;div class=&quot;post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;% site.tags.each(function(category){ %&gt;\n                    &lt;a class=&quot;category&quot; href=&quot;&lt;%-category.name%&gt;&quot;&gt;&lt;%-category.name%&gt;&lt;/a&gt;\n                &lt;% }); %&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/article&gt;\n&lt;/section&gt;\n&lt;!-- Back to top --&gt;\n&lt;%- partial(&#39;_partial/backtop&#39;) %&gt;\n</code></pre>\n<p>修改完 page.ejs 后，执行 <code>hexo new page &quot;tags&quot;</code> 就可以创建 tags 页了。然后调整格式就可以了。</p>\n<h3 id=\"About（最近修改中…）\"><a href=\"#About（最近修改中…）\" class=\"headerlink\" title=\"About（最近修改中…）\"></a>About（最近修改中…）</h3><p>这个页面是自己添加的。</p>\n<p>这个页面是最复杂的。首先Hexo只支持 <code>index</code>,<code>page</code>,<code>post</code>,<code>layout</code>,<code>archive</code> 这几种自定义页面，所以修改了<code>page</code>后作为 category 页面之后就不能通过修改项目页面模板来添加新的自定义页面了。</p>\n<p>但是好在 Hexo 还是比较人性化的。</p>\n<p>除了修改 Hexo 的模板，有两种方法可以实现自定义页面</p>\n<ol>\n<li>先执行<code>hexo new page &quot;xxx&quot;</code>，在 source 中出现 xxx 文件夹，其中有 xxx.md ，然后在 xxx.md 前加上<code>layout:false</code>，可以绕过 Hexo 解析，直接将 md 中的内容显示出来，这样就可以在 md 里面写 html 代码了。详见<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">Hexo文档</a></li>\n<li>执行<code>hexo new page &quot;xxx&quot;</code>，同样得到 xxx 文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建 html，css，js，whatever you want 。然后记得在博客的主 _config.yml 中的 skip_render 项添加 xxx/** ，就可以了。</li>\n</ol>\n<h3 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h3><p>评论就不加啦，毕竟清清爽爽还是最爱啊。</p>\n<p>而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。</p>\n<p>厌倦了多说等评论管理平台的话，推荐一个 <a href=\"https://github.com/imsun/gitment\" target=\"_blank\" rel=\"external\">Gitment</a>，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在 Github 的 issue 里面，很适合托管在第三方服务器空间的博客使用。</p>\n<p>有问题在微博等社交平台联系吧。</p>\n<h3 id=\"域名和全站-HTTPS\"><a href=\"#域名和全站-HTTPS\" class=\"headerlink\" title=\"域名和全站 HTTPS\"></a>域名和全站 HTTPS</h3><p>域名在万网上购买，实名认证，解析到 github page 。都是很简单的操作。</p>\n<p>在实现全站 HTTPS 的时候走了不少弯路。主要想实现的有如下几点：</p>\n<ul>\n<li>[x] 全站小绿锁</li>\n</ul>\n<ul>\n<li>[x] 怕 HTTPS 慢，所以上 CDN</li>\n</ul>\n<ul>\n<li>[ ] <del>自定义 SSL 证书</del> (无解)</li>\n</ul>\n<p>因为博客是托管在 Github 上的，要强制 HTTPS，Coding 可以做到，但是没有必要再部署一套到 Coding 上。所以就想到使用 CDN 来实现，顺便解决网页的访问速度问题。</p>\n<p>CDN 有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义 SSL 证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。</p>\n<p>工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的 CDN 厂商 <a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"external\">Cloudflare</a> 来解析我的域名，Cloudflare 和百度云合作，在国内也有 CDN 服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。</p>\n<p>在 Cloudflare 成功解析后，在 Page rules 中定义重定向，将<code>http</code> 301 永久重定向到<code>https</code>。Cloudflare 还可以设置缓存时间，设置用户与 DNS 、DNS 与我们博客的服务器之间是否使用 SSL ，压缩 CSS、JS ，永久在线（不定时向服务器请求数据），安全级别（防 DDoS ）等。</p>\n<p>设置完后，看到了久违的小绿锁：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png\" alt=\"\"></p>\n<p>但是，点击文章，可以看到：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png\" alt=\"\"></p>\n<p>访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供<code>https</code>的二级域名，但现在已经关闭，要使用<code>https</code>需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云 COS 上，腾讯云 COS 就有支持 SSL 的图床测试域名，且提供 CDN 服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。</p>\n<p>所以，Congratulations~ 😄😄😄🎉🎉🎉~</p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>总有一些奇思妙想，所以本文仍在不断更新…</p>\n<p>博客是在 hollow 主题的<a href=\"https://github.com/zchen9/hexo-theme-hollow\" target=\"_blank\" rel=\"external\">创作家</a>的基础上进行修改的，对此表示最真挚的感谢，开源万岁。</p>\n<p>如果要自己写主题，<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">Hexo文档</a>记得多看看。</p>\n<p>对于域名购买和 Cloudflare 、腾讯云的使用， Google 可以搜到许多精彩且详细的文章，此处就不再赘述了。</p>\n<h3 id=\"对于这次实践的总结：\"><a href=\"#对于这次实践的总结：\" class=\"headerlink\" title=\"对于这次实践的总结：\"></a>对于这次实践的总结：</h3><ul>\n<li>虽然是 Node.js 小白，但勉强做得出来，因为一行 nodejs 的代码都没写到</li>\n<li>HTML、CSS、JS 可以做很多事情</li>\n<li>需要学习下 ejs、stylus ，都不是很难</li>\n<li>多看看别人的代码，很受启发</li>\n</ul>\n","excerpt":"<p>决定给博客的名字起为<strong>童年 CHILDHOOD</strong>。</p>\n<p><strong>如童年般纯真，热爱，不朽。</strong></p>\n<p>趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前 Hexo 的 yilia 主题。所以换个博客主题，Hello World Again 。</p>","more":"<h2 id=\"开始捣鼓\"><a href=\"#开始捣鼓\" class=\"headerlink\" title=\"开始捣鼓\"></a>开始捣鼓</h2><p>不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了 hollow 主题，并在其上进行修改。</p>\n<h3 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h3><p>主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了 yilia ，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。</p>\n<p>hollow 主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。</p>\n<h3 id=\"Tags\"><a href=\"#Tags\" class=\"headerlink\" title=\"Tags\"></a>Tags</h3><p>进入标签页面在主页右上角的 <em>井号</em> 按钮，标签页面是显示所有标签。</p>\n<p>因为暂时不支持站内搜索（还在构思中…），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。</p>\n<p>我是通过修改page.ejs来达到目的。</p>\n<pre><code class=\"html\">&lt;section class=&quot;article-container&quot;&gt;\n&lt;!-- Back Home --&gt;\n&lt;%- partial(&#39;_partial/backhome&#39;) %&gt;\n\n&lt;!-- Page Header --&gt;\n&lt;header class=&quot;intro-header&quot;&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;div class=&quot;post-heading&quot;&gt;\n                    &lt;h1&gt;TAGS&lt;/h1&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/header&gt;\n\n&lt;!-- Post Content --&gt;\n&lt;article&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;!-- Post Main Content --&gt;\n            &lt;div class=&quot;post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;% site.tags.each(function(category){ %&gt;\n                    &lt;a class=&quot;category&quot; href=&quot;&lt;%-category.name%&gt;&quot;&gt;&lt;%-category.name%&gt;&lt;/a&gt;\n                &lt;% }); %&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/article&gt;\n&lt;/section&gt;\n&lt;!-- Back to top --&gt;\n&lt;%- partial(&#39;_partial/backtop&#39;) %&gt;\n</code></pre>\n<p>修改完 page.ejs 后，执行 <code>hexo new page &quot;tags&quot;</code> 就可以创建 tags 页了。然后调整格式就可以了。</p>\n<h3 id=\"About（最近修改中…）\"><a href=\"#About（最近修改中…）\" class=\"headerlink\" title=\"About（最近修改中…）\"></a>About（最近修改中…）</h3><p>这个页面是自己添加的。</p>\n<p>这个页面是最复杂的。首先Hexo只支持 <code>index</code>,<code>page</code>,<code>post</code>,<code>layout</code>,<code>archive</code> 这几种自定义页面，所以修改了<code>page</code>后作为 category 页面之后就不能通过修改项目页面模板来添加新的自定义页面了。</p>\n<p>但是好在 Hexo 还是比较人性化的。</p>\n<p>除了修改 Hexo 的模板，有两种方法可以实现自定义页面</p>\n<ol>\n<li>先执行<code>hexo new page &quot;xxx&quot;</code>，在 source 中出现 xxx 文件夹，其中有 xxx.md ，然后在 xxx.md 前加上<code>layout:false</code>，可以绕过 Hexo 解析，直接将 md 中的内容显示出来，这样就可以在 md 里面写 html 代码了。详见<a href=\"https://hexo.io/zh-cn/docs/writing.html\">Hexo文档</a></li>\n<li>执行<code>hexo new page &quot;xxx&quot;</code>，同样得到 xxx 文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建 html，css，js，whatever you want 。然后记得在博客的主 _config.yml 中的 skip_render 项添加 xxx/** ，就可以了。</li>\n</ol>\n<h3 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h3><p>评论就不加啦，毕竟清清爽爽还是最爱啊。</p>\n<p>而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。</p>\n<p>厌倦了多说等评论管理平台的话，推荐一个 <a href=\"https://github.com/imsun/gitment\">Gitment</a>，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在 Github 的 issue 里面，很适合托管在第三方服务器空间的博客使用。</p>\n<p>有问题在微博等社交平台联系吧。</p>\n<h3 id=\"域名和全站-HTTPS\"><a href=\"#域名和全站-HTTPS\" class=\"headerlink\" title=\"域名和全站 HTTPS\"></a>域名和全站 HTTPS</h3><p>域名在万网上购买，实名认证，解析到 github page 。都是很简单的操作。</p>\n<p>在实现全站 HTTPS 的时候走了不少弯路。主要想实现的有如下几点：</p>\n<ul>\n<li>[x] 全站小绿锁</li>\n</ul>\n<ul>\n<li>[x] 怕 HTTPS 慢，所以上 CDN</li>\n</ul>\n<ul>\n<li>[ ] <del>自定义 SSL 证书</del> (无解)</li>\n</ul>\n<p>因为博客是托管在 Github 上的，要强制 HTTPS，Coding 可以做到，但是没有必要再部署一套到 Coding 上。所以就想到使用 CDN 来实现，顺便解决网页的访问速度问题。</p>\n<p>CDN 有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义 SSL 证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。</p>\n<p>工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的 CDN 厂商 <a href=\"https://www.cloudflare.com/\">Cloudflare</a> 来解析我的域名，Cloudflare 和百度云合作，在国内也有 CDN 服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。</p>\n<p>在 Cloudflare 成功解析后，在 Page rules 中定义重定向，将<code>http</code> 301 永久重定向到<code>https</code>。Cloudflare 还可以设置缓存时间，设置用户与 DNS 、DNS 与我们博客的服务器之间是否使用 SSL ，压缩 CSS、JS ，永久在线（不定时向服务器请求数据），安全级别（防 DDoS ）等。</p>\n<p>设置完后，看到了久违的小绿锁：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png\" alt=\"\"></p>\n<p>但是，点击文章，可以看到：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png\" alt=\"\"></p>\n<p>访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供<code>https</code>的二级域名，但现在已经关闭，要使用<code>https</code>需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云 COS 上，腾讯云 COS 就有支持 SSL 的图床测试域名，且提供 CDN 服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。</p>\n<p>所以，Congratulations~ 😄😄😄🎉🎉🎉~</p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>总有一些奇思妙想，所以本文仍在不断更新…</p>\n<p>博客是在 hollow 主题的<a href=\"https://github.com/zchen9/hexo-theme-hollow\">创作家</a>的基础上进行修改的，对此表示最真挚的感谢，开源万岁。</p>\n<p>如果要自己写主题，<a href=\"https://hexo.io/zh-cn/docs/writing.html\">Hexo文档</a>记得多看看。</p>\n<p>对于域名购买和 Cloudflare 、腾讯云的使用， Google 可以搜到许多精彩且详细的文章，此处就不再赘述了。</p>\n<h3 id=\"对于这次实践的总结：\"><a href=\"#对于这次实践的总结：\" class=\"headerlink\" title=\"对于这次实践的总结：\"></a>对于这次实践的总结：</h3><ul>\n<li>虽然是 Node.js 小白，但勉强做得出来，因为一行 nodejs 的代码都没写到</li>\n<li>HTML、CSS、JS 可以做很多事情</li>\n<li>需要学习下 ejs、stylus ，都不是很难</li>\n<li>多看看别人的代码，很受启发</li>\n</ul>"},{"title":"iOS下重要的多线程GCD","date":"2017-03-23T04:15:06.000Z","typora-copy-images-to":"ipic","_content":"\n**多线程**是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP 的被使用率和被使用频率也会更加高。    \n此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。\n\n<!--more-->\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n## 一些概念\n\n### 串行（Serial）与 并发（Concurrent）\n- 任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。\n- 任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。\n\n### 同步（Synchronous）与 异步 （Asynchronous）\n- 同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 \n- 异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。\n\n### 临界区（Critical Section）\n一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。\n\n### 死锁（Deadlock）    \n停止等待事情的线程会导致多个线程相互维持等待，即死锁。    \n两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。\n\n### 线程安全（Thread Safe）\n线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：[helpful and somewhat chilling list](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html)\n\n### 上下文切换（Context Switch）\n一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。\n\n### 并发（Concurrency）与 并行 （Parallelism）\n并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。\n并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： \n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n\n## 队列（queue）\n\n|  队列  |   线程   |\n| :--: | :----: |\n|  串行  | 当前线程运行 |\n|  并发  | 另开线程运行 |\n\n### 串行队列（Serial Queues）\n---\n![Serial-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_SERIAL);`    \n串行队列最典型的是**main queue**：主线程所对应的queue，主要用于更新UI。\n\n\n### 并发队列（Concurrent Queues）\n---\n![Concurrent-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_CONCURRENT);`    \n除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）    \n`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)`\n\n\n## GCD语法和适用范围\n\n### dispatch_sync\n\n![dispatch_sync_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif)\n- 串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    \n- 并发队列：√\n\n\n### dispatch_async\n\n![dispatch_async_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif)    \n- 串行队列：√    \n- 并发队列：√\n\n\n### dispatch barriers\n\n![Dispatch-Barrier](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png)    \n正如上图所示：使用dispatch\\_barriers\\_sync或dispatch\\_barries\\_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    \n- 串行队列：完全没必要....\n- 并发队列：√\n\n#### read and write 读写问题\n\n```\n- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n```\n```\n- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n```\n\n### dispatch_after\n\ndispatch\\_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch\\_after.而且正如下文将说到的：dispatch\\_after最好只在main queue中使用。\n```\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@\"Add photos with faces to Googlyify them!\"]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n}); \n```\n**只能用于Main Queue！！！！！！！！！！！！！！**\n\n### dispatch_once\n\n```\nstatic PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager->_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager; \n```\n\n### dispatch_groups\n\n```\ndispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n}); \n```\ngroup中的任务不一定在同一个queue里面。串行队列和并发队列都可用。\n- 串行队列：√    \n- 并发队列：√\n\n### dispatch_apply\n\n```\ndispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n```\n- 串行队列：没什么必要....串行队列使用跟普通的循环没有区别。\n- 并发队列：√\n\n\n## 参考文献\n\n[Grand Central Dispatch In-Depth: Part 1/2](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)\n\n[Grand Central Dispatch In-Depth: Part 2/2](https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2)","source":"_posts/iOS下重要的多线程GCD.md","raw":"---\ntitle: iOS下重要的多线程GCD\ndate: 2017-03-23 12:15:06\ntags: \n- Thread\ntypora-copy-images-to: ipic\n---\n\n**多线程**是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP 的被使用率和被使用频率也会更加高。    \n此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。\n\n<!--more-->\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n## 一些概念\n\n### 串行（Serial）与 并发（Concurrent）\n- 任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。\n- 任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。\n\n### 同步（Synchronous）与 异步 （Asynchronous）\n- 同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 \n- 异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。\n\n### 临界区（Critical Section）\n一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。\n\n### 死锁（Deadlock）    \n停止等待事情的线程会导致多个线程相互维持等待，即死锁。    \n两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。\n\n### 线程安全（Thread Safe）\n线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：[helpful and somewhat chilling list](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html)\n\n### 上下文切换（Context Switch）\n一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。\n\n### 并发（Concurrency）与 并行 （Parallelism）\n并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。\n并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： \n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n\n## 队列（queue）\n\n|  队列  |   线程   |\n| :--: | :----: |\n|  串行  | 当前线程运行 |\n|  并发  | 另开线程运行 |\n\n### 串行队列（Serial Queues）\n---\n![Serial-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_SERIAL);`    \n串行队列最典型的是**main queue**：主线程所对应的queue，主要用于更新UI。\n\n\n### 并发队列（Concurrent Queues）\n---\n![Concurrent-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_CONCURRENT);`    \n除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）    \n`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)`\n\n\n## GCD语法和适用范围\n\n### dispatch_sync\n\n![dispatch_sync_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif)\n- 串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    \n- 并发队列：√\n\n\n### dispatch_async\n\n![dispatch_async_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif)    \n- 串行队列：√    \n- 并发队列：√\n\n\n### dispatch barriers\n\n![Dispatch-Barrier](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png)    \n正如上图所示：使用dispatch\\_barriers\\_sync或dispatch\\_barries\\_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    \n- 串行队列：完全没必要....\n- 并发队列：√\n\n#### read and write 读写问题\n\n```\n- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n```\n```\n- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n```\n\n### dispatch_after\n\ndispatch\\_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch\\_after.而且正如下文将说到的：dispatch\\_after最好只在main queue中使用。\n```\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@\"Add photos with faces to Googlyify them!\"]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n}); \n```\n**只能用于Main Queue！！！！！！！！！！！！！！**\n\n### dispatch_once\n\n```\nstatic PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager->_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager; \n```\n\n### dispatch_groups\n\n```\ndispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n}); \n```\ngroup中的任务不一定在同一个queue里面。串行队列和并发队列都可用。\n- 串行队列：√    \n- 并发队列：√\n\n### dispatch_apply\n\n```\ndispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n```\n- 串行队列：没什么必要....串行队列使用跟普通的循环没有区别。\n- 并发队列：√\n\n\n## 参考文献\n\n[Grand Central Dispatch In-Depth: Part 1/2](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)\n\n[Grand Central Dispatch In-Depth: Part 2/2](https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2)","slug":"iOS下重要的多线程GCD","published":1,"updated":"2018-11-06T12:35:09.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dp0009qu0xpwbb2028","content":"<p><strong>多线程</strong>是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP 的被使用率和被使用频率也会更加高。<br>此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"串行（Serial）与-并发（Concurrent）\"><a href=\"#串行（Serial）与-并发（Concurrent）\" class=\"headerlink\" title=\"串行（Serial）与 并发（Concurrent）\"></a>串行（Serial）与 并发（Concurrent）</h3><ul>\n<li>任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。</li>\n<li>任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。</li>\n</ul>\n<h3 id=\"同步（Synchronous）与-异步-（Asynchronous）\"><a href=\"#同步（Synchronous）与-异步-（Asynchronous）\" class=\"headerlink\" title=\"同步（Synchronous）与 异步 （Asynchronous）\"></a>同步（Synchronous）与 异步 （Asynchronous）</h3><ul>\n<li>同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 </li>\n<li>异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。</li>\n</ul>\n<p>同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。</p>\n<h3 id=\"临界区（Critical-Section）\"><a href=\"#临界区（Critical-Section）\" class=\"headerlink\" title=\"临界区（Critical Section）\"></a>临界区（Critical Section）</h3><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。</p>\n<h3 id=\"死锁（Deadlock）\"><a href=\"#死锁（Deadlock）\" class=\"headerlink\" title=\"死锁（Deadlock）\"></a>死锁（Deadlock）</h3><p>停止等待事情的线程会导致多个线程相互维持等待，即死锁。<br>两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>\n<h3 id=\"线程安全（Thread-Safe）\"><a href=\"#线程安全（Thread-Safe）\" class=\"headerlink\" title=\"线程安全（Thread Safe）\"></a>线程安全（Thread Safe）</h3><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：<a href=\"https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html\" target=\"_blank\" rel=\"external\">helpful and somewhat chilling list</a></p>\n<h3 id=\"上下文切换（Context-Switch）\"><a href=\"#上下文切换（Context-Switch）\" class=\"headerlink\" title=\"上下文切换（Context Switch）\"></a>上下文切换（Context Switch）</h3><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>\n<h3 id=\"并发（Concurrency）与-并行-（Parallelism）\"><a href=\"#并发（Concurrency）与-并行-（Parallelism）\" class=\"headerlink\" title=\"并发（Concurrency）与 并行 （Parallelism）\"></a>并发（Concurrency）与 并行 （Parallelism）</h3><p>并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"队列（queue）\"><a href=\"#队列（queue）\" class=\"headerlink\" title=\"队列（queue）\"></a>队列（queue）</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">队列</th>\n<th style=\"text-align:center\">线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">串行</td>\n<td style=\"text-align:center\">当前线程运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">并发</td>\n<td style=\"text-align:center\">另开线程运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"串行队列（Serial-Queues）\"><a href=\"#串行队列（Serial-Queues）\" class=\"headerlink\" title=\"串行队列（Serial Queues）\"></a>串行队列（Serial Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png\" alt=\"Serial-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_SERIAL);</code><br>串行队列最典型的是<strong>main queue</strong>：主线程所对应的queue，主要用于更新UI。</p>\n<h3 id=\"并发队列（Concurrent-Queues）\"><a href=\"#并发队列（Concurrent-Queues）\" class=\"headerlink\" title=\"并发队列（Concurrent Queues）\"></a>并发队列（Concurrent Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png\" alt=\"Concurrent-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code><br>除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）<br><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)</code></p>\n<h2 id=\"GCD语法和适用范围\"><a href=\"#GCD语法和适用范围\" class=\"headerlink\" title=\"GCD语法和适用范围\"></a>GCD语法和适用范围</h2><h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif\" alt=\"dispatch_sync_in_action\"></p>\n<ul>\n<li>串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif\" alt=\"dispatch_async_in_action\">    </p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-barriers\"><a href=\"#dispatch-barriers\" class=\"headerlink\" title=\"dispatch barriers\"></a>dispatch barriers</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png\" alt=\"Dispatch-Barrier\"><br>正如上图所示：使用dispatch_barriers_sync或dispatch_barries_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    </p>\n<ul>\n<li>串行队列：完全没必要….</li>\n<li>并发队列：√</li>\n</ul>\n<h4 id=\"read-and-write-读写问题\"><a href=\"#read-and-write-读写问题\" class=\"headerlink\" title=\"read and write 读写问题\"></a>read and write 读写问题</h4><pre><code>- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n</code></pre><pre><code>- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n</code></pre><h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>dispatch_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch_after.而且正如下文将说到的：dispatch_after最好只在main queue中使用。</p>\n<pre><code>double delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n});\n</code></pre><p><strong>只能用于Main Queue！！！！！！！！！！！！！！</strong></p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><pre><code>static PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&amp;onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager;\n</code></pre><h3 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h3><pre><code>dispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n});\n</code></pre><p>group中的任务不一定在同一个queue里面。串行队列和并发队列都可用。</p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><pre><code>dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n</code></pre><ul>\n<li>串行队列：没什么必要….串行队列使用跟普通的循环没有区别。</li>\n<li>并发队列：√</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1\" target=\"_blank\" rel=\"external\">Grand Central Dispatch In-Depth: Part 1/2</a></p>\n<p><a href=\"https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2\" target=\"_blank\" rel=\"external\">Grand Central Dispatch In-Depth: Part 2/2</a></p>\n","excerpt":"<p><strong>多线程</strong>是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP 的被使用率和被使用频率也会更加高。<br>此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"串行（Serial）与-并发（Concurrent）\"><a href=\"#串行（Serial）与-并发（Concurrent）\" class=\"headerlink\" title=\"串行（Serial）与 并发（Concurrent）\"></a>串行（Serial）与 并发（Concurrent）</h3><ul>\n<li>任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。</li>\n<li>任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。</li>\n</ul>\n<h3 id=\"同步（Synchronous）与-异步-（Asynchronous）\"><a href=\"#同步（Synchronous）与-异步-（Asynchronous）\" class=\"headerlink\" title=\"同步（Synchronous）与 异步 （Asynchronous）\"></a>同步（Synchronous）与 异步 （Asynchronous）</h3><ul>\n<li>同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 </li>\n<li>异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。</li>\n</ul>\n<p>同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。</p>\n<h3 id=\"临界区（Critical-Section）\"><a href=\"#临界区（Critical-Section）\" class=\"headerlink\" title=\"临界区（Critical Section）\"></a>临界区（Critical Section）</h3><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。</p>\n<h3 id=\"死锁（Deadlock）\"><a href=\"#死锁（Deadlock）\" class=\"headerlink\" title=\"死锁（Deadlock）\"></a>死锁（Deadlock）</h3><p>停止等待事情的线程会导致多个线程相互维持等待，即死锁。<br>两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>\n<h3 id=\"线程安全（Thread-Safe）\"><a href=\"#线程安全（Thread-Safe）\" class=\"headerlink\" title=\"线程安全（Thread Safe）\"></a>线程安全（Thread Safe）</h3><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：<a href=\"https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html\">helpful and somewhat chilling list</a></p>\n<h3 id=\"上下文切换（Context-Switch）\"><a href=\"#上下文切换（Context-Switch）\" class=\"headerlink\" title=\"上下文切换（Context Switch）\"></a>上下文切换（Context Switch）</h3><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>\n<h3 id=\"并发（Concurrency）与-并行-（Parallelism）\"><a href=\"#并发（Concurrency）与-并行-（Parallelism）\" class=\"headerlink\" title=\"并发（Concurrency）与 并行 （Parallelism）\"></a>并发（Concurrency）与 并行 （Parallelism）</h3><p>并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"队列（queue）\"><a href=\"#队列（queue）\" class=\"headerlink\" title=\"队列（queue）\"></a>队列（queue）</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">队列</th>\n<th style=\"text-align:center\">线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">串行</td>\n<td style=\"text-align:center\">当前线程运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">并发</td>\n<td style=\"text-align:center\">另开线程运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"串行队列（Serial-Queues）\"><a href=\"#串行队列（Serial-Queues）\" class=\"headerlink\" title=\"串行队列（Serial Queues）\"></a>串行队列（Serial Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png\" alt=\"Serial-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_SERIAL);</code><br>串行队列最典型的是<strong>main queue</strong>：主线程所对应的queue，主要用于更新UI。</p>\n<h3 id=\"并发队列（Concurrent-Queues）\"><a href=\"#并发队列（Concurrent-Queues）\" class=\"headerlink\" title=\"并发队列（Concurrent Queues）\"></a>并发队列（Concurrent Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png\" alt=\"Concurrent-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code><br>除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）<br><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)</code></p>\n<h2 id=\"GCD语法和适用范围\"><a href=\"#GCD语法和适用范围\" class=\"headerlink\" title=\"GCD语法和适用范围\"></a>GCD语法和适用范围</h2><h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif\" alt=\"dispatch_sync_in_action\"></p>\n<ul>\n<li>串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif\" alt=\"dispatch_async_in_action\">    </p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-barriers\"><a href=\"#dispatch-barriers\" class=\"headerlink\" title=\"dispatch barriers\"></a>dispatch barriers</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png\" alt=\"Dispatch-Barrier\"><br>正如上图所示：使用dispatch_barriers_sync或dispatch_barries_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    </p>\n<ul>\n<li>串行队列：完全没必要….</li>\n<li>并发队列：√</li>\n</ul>\n<h4 id=\"read-and-write-读写问题\"><a href=\"#read-and-write-读写问题\" class=\"headerlink\" title=\"read and write 读写问题\"></a>read and write 读写问题</h4><pre><code>- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n</code></pre><pre><code>- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n</code></pre><h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>dispatch_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch_after.而且正如下文将说到的：dispatch_after最好只在main queue中使用。</p>\n<pre><code>double delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n});\n</code></pre><p><strong>只能用于Main Queue！！！！！！！！！！！！！！</strong></p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><pre><code>static PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&amp;onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager;\n</code></pre><h3 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h3><pre><code>dispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n});\n</code></pre><p>group中的任务不一定在同一个queue里面。串行队列和并发队列都可用。</p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><pre><code>dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n</code></pre><ul>\n<li>串行队列：没什么必要….串行队列使用跟普通的循环没有区别。</li>\n<li>并发队列：√</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1\">Grand Central Dispatch In-Depth: Part 1/2</a></p>\n<p><a href=\"https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2\">Grand Central Dispatch In-Depth: Part 2/2</a></p>"},{"title":"iOS Touch Event传递和响应链","date":"2017-02-27T10:54:59.000Z","id":"8539A86063B11E16","typora-copy-images-to":"ipic","_content":"\n本来不想重复造轮子，因为网上已经很多关于 iOS 触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～\n\n<!-- more -->\n\n毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递( Event Delivery )，从 UIApplication 到响应事件的 UIView 是「从下往上」，反过来自然就是「从上往下」了。\n\n## 从下往上——寻找 HitTest View\n\n当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象( Event Object )，携带着一些处理信息，eg: 点击位置、事件类型等，然后将这个对象存放在 UIApplication 的事件队列中，等待处理。\n\n我们开发中使用的最多的是触碰事件( Touch Event )，也只有触碰事件才需要 iOS 为我们寻找 **HitTest View** ，即**寻找响应该事件的 View **，这一过程，官方文档里称为 ***Hit-Testing*** 。\n\n了解这一过程，先了解 UIView 的两个可重载的方法：\n\n1. `- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event`\n\n   传入的参数类型是`CGPoint point`和`UIEvent *event` ，分别表示拥护触碰事件的**触碰点**和对应的**事件**，event 可为`nil`，返回的是`Boolean`表示 point 是否在当前 View 的Bounds中。\n\n2. `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`\n\n   同样，传入的参数类型是`CGPoint point`和`UIEvent *event` ，event 可为`nil`(我们本次讨论的是触碰事件的 Hit-Testing ，自然此参数不会为空)，此方法返回的是 point 所在的 View 。\n\n\n\n`hitTest:withEvent:`内部会先调用`pointInside:withEvent:`，来检测触碰点是否在当前View中\n\n- 若返回`NO`,则直接返回`nil`，且所有的 SubView 都不会响应当前事件。所以，敲重点啦，对于`clipsToBounds`设置为`NO`，允许 SubView 向外延伸的 View ，需要重载`pointInside:withEvent:`，例如：\n\n  ![TouchEvent_WechatIMG3](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg)\n\n  ```objective-c\n  - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n    \t//以下是伪代码  \n    \tif (point inside blueArea) return true;\n    \telse return false;\n  }\n  ```\n\n  如果没有重载`pointInside:withEvent:`，那么用户点击上图触碰点，SubView 将不响应事件。\n\n\n- 若返回`YES`，则调用所有 SubView 的`hitTest:withEvent:`，继续寻找 HitTest View 。在视图层级树(这样翻译?!  view hierarchy )中**最后添加的叶结点**且**包含触碰点**的 View 就会光荣地成为 **HitTest View** (如下图最后一个 UIView )，首先接受事件，并做下一步操作——寻找响应对象。\n\n  ![TouchEvent_WechatIMG1](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg)\n\n\n\n我们也可以在中途截断系统的 Hit-Testing ，如果你想让某个 View 的所有 SubView 都不响应事件，最简单的就是重载该 View 的`hitTest:withEvent:`，返回 View （自己响应点击事件）或者`nil`（都不响应）。\n\n```objective-c\n-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n  \treturn self;\t// 自己成为HitTest View\n}\n```\n\n## 从上往下——寻找响应对象\n\n![1387344-cd500e5bd93d9606](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png)\n\n这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：\n\n当上一步找到的 HitTest View 没能响应事件时( eg: userInteractionEnabled 为 NO 或者没有定义响应事件的方法)，那么事件就会被传递到 SuperView 或着 Controller 。直至 Applicaion 都不能处理该事件则忽略。\n\n需要注意的是：这里的传递只会给 SuperView 或着 Controller ，并不会传递给与自己相同级别的 View ，除非你自己控制。\n\niOS10的 UIResponder 中定义了两个新的 Property ：\n\n1. `nextResponder(Swift是next)`：这个比较蛋疼，因为 UIResponder 中它默认返回的是nil，所以如果我们想让特定的 Responder 响应事件，我们需要在我们的类中重载 Get 方法，返回自己想要的下一个 Responder 。\n2. `isFirstResponder`：判断当前View或 Controller 是否为即将响应事件的 Responder 。不能明白？！那么想想这两个方法：`becomeFirstResponder`和`resignFirstResponder`：）\n\n## 总结\n\n废话了这么多，三点：\n\n1. iOS 的 Touch Event 先「从下往上」寻找 HitTest View ( FirstResponder )，再「从上往下」寻找真正响应该事件的 Responder 。\n2. 可以通过重载`hitTest:withEvent:`，决定 HitTest View ，即最开始**接收（敲重点，只是接收）**事件的 Responder 。\n3. Responder 不一定会响应事件，看有没有响应事件的方法。\n\n\n\n所以，以后如果有人问你：两个View重叠在一起，在上面的 View 将下面的 View 完全覆盖，且上面的 View 不能响应事件，下面的 View 会响应吗？\n\n你不如先反问一句，两个 View 是否为 SuperView 和 SubView 的关系？！\n\n再分门别类地回答～\n\n以上\n\n\n\n## 参考文献\n\n[Event Handling Guide for iOS](https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1)\n\n","source":"_posts/iOS-Event传递和响应链.md","raw":"---\ntitle: iOS Touch Event传递和响应链\ndate: 2017-02-27 18:54:59\nid: 8539A86063B11E16\ntags: \n- UIView \ntypora-copy-images-to: ipic\n---\n\n本来不想重复造轮子，因为网上已经很多关于 iOS 触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～\n\n<!-- more -->\n\n毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递( Event Delivery )，从 UIApplication 到响应事件的 UIView 是「从下往上」，反过来自然就是「从上往下」了。\n\n## 从下往上——寻找 HitTest View\n\n当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象( Event Object )，携带着一些处理信息，eg: 点击位置、事件类型等，然后将这个对象存放在 UIApplication 的事件队列中，等待处理。\n\n我们开发中使用的最多的是触碰事件( Touch Event )，也只有触碰事件才需要 iOS 为我们寻找 **HitTest View** ，即**寻找响应该事件的 View **，这一过程，官方文档里称为 ***Hit-Testing*** 。\n\n了解这一过程，先了解 UIView 的两个可重载的方法：\n\n1. `- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event`\n\n   传入的参数类型是`CGPoint point`和`UIEvent *event` ，分别表示拥护触碰事件的**触碰点**和对应的**事件**，event 可为`nil`，返回的是`Boolean`表示 point 是否在当前 View 的Bounds中。\n\n2. `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`\n\n   同样，传入的参数类型是`CGPoint point`和`UIEvent *event` ，event 可为`nil`(我们本次讨论的是触碰事件的 Hit-Testing ，自然此参数不会为空)，此方法返回的是 point 所在的 View 。\n\n\n\n`hitTest:withEvent:`内部会先调用`pointInside:withEvent:`，来检测触碰点是否在当前View中\n\n- 若返回`NO`,则直接返回`nil`，且所有的 SubView 都不会响应当前事件。所以，敲重点啦，对于`clipsToBounds`设置为`NO`，允许 SubView 向外延伸的 View ，需要重载`pointInside:withEvent:`，例如：\n\n  ![TouchEvent_WechatIMG3](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg)\n\n  ```objective-c\n  - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n    \t//以下是伪代码  \n    \tif (point inside blueArea) return true;\n    \telse return false;\n  }\n  ```\n\n  如果没有重载`pointInside:withEvent:`，那么用户点击上图触碰点，SubView 将不响应事件。\n\n\n- 若返回`YES`，则调用所有 SubView 的`hitTest:withEvent:`，继续寻找 HitTest View 。在视图层级树(这样翻译?!  view hierarchy )中**最后添加的叶结点**且**包含触碰点**的 View 就会光荣地成为 **HitTest View** (如下图最后一个 UIView )，首先接受事件，并做下一步操作——寻找响应对象。\n\n  ![TouchEvent_WechatIMG1](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg)\n\n\n\n我们也可以在中途截断系统的 Hit-Testing ，如果你想让某个 View 的所有 SubView 都不响应事件，最简单的就是重载该 View 的`hitTest:withEvent:`，返回 View （自己响应点击事件）或者`nil`（都不响应）。\n\n```objective-c\n-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n  \treturn self;\t// 自己成为HitTest View\n}\n```\n\n## 从上往下——寻找响应对象\n\n![1387344-cd500e5bd93d9606](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png)\n\n这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：\n\n当上一步找到的 HitTest View 没能响应事件时( eg: userInteractionEnabled 为 NO 或者没有定义响应事件的方法)，那么事件就会被传递到 SuperView 或着 Controller 。直至 Applicaion 都不能处理该事件则忽略。\n\n需要注意的是：这里的传递只会给 SuperView 或着 Controller ，并不会传递给与自己相同级别的 View ，除非你自己控制。\n\niOS10的 UIResponder 中定义了两个新的 Property ：\n\n1. `nextResponder(Swift是next)`：这个比较蛋疼，因为 UIResponder 中它默认返回的是nil，所以如果我们想让特定的 Responder 响应事件，我们需要在我们的类中重载 Get 方法，返回自己想要的下一个 Responder 。\n2. `isFirstResponder`：判断当前View或 Controller 是否为即将响应事件的 Responder 。不能明白？！那么想想这两个方法：`becomeFirstResponder`和`resignFirstResponder`：）\n\n## 总结\n\n废话了这么多，三点：\n\n1. iOS 的 Touch Event 先「从下往上」寻找 HitTest View ( FirstResponder )，再「从上往下」寻找真正响应该事件的 Responder 。\n2. 可以通过重载`hitTest:withEvent:`，决定 HitTest View ，即最开始**接收（敲重点，只是接收）**事件的 Responder 。\n3. Responder 不一定会响应事件，看有没有响应事件的方法。\n\n\n\n所以，以后如果有人问你：两个View重叠在一起，在上面的 View 将下面的 View 完全覆盖，且上面的 View 不能响应事件，下面的 View 会响应吗？\n\n你不如先反问一句，两个 View 是否为 SuperView 和 SubView 的关系？！\n\n再分门别类地回答～\n\n以上\n\n\n\n## 参考文献\n\n[Event Handling Guide for iOS](https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1)\n\n","slug":"iOS-Event传递和响应链","published":1,"updated":"2018-11-06T12:34:59.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6ds000aqu0x2w7fu763","content":"<p>本来不想重复造轮子，因为网上已经很多关于 iOS 触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～</p>\n<a id=\"more\"></a>\n<p>毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递( Event Delivery )，从 UIApplication 到响应事件的 UIView 是「从下往上」，反过来自然就是「从上往下」了。</p>\n<h2 id=\"从下往上——寻找-HitTest-View\"><a href=\"#从下往上——寻找-HitTest-View\" class=\"headerlink\" title=\"从下往上——寻找 HitTest View\"></a>从下往上——寻找 HitTest View</h2><p>当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象( Event Object )，携带着一些处理信息，eg: 点击位置、事件类型等，然后将这个对象存放在 UIApplication 的事件队列中，等待处理。</p>\n<p>我们开发中使用的最多的是触碰事件( Touch Event )，也只有触碰事件才需要 iOS 为我们寻找 <strong>HitTest View</strong> ，即<strong>寻找响应该事件的 View </strong>，这一过程，官方文档里称为 <strong><em>Hit-Testing</em></strong> 。</p>\n<p>了解这一过程，先了解 UIView 的两个可重载的方法：</p>\n<ol>\n<li><p><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，分别表示拥护触碰事件的<strong>触碰点</strong>和对应的<strong>事件</strong>，event 可为<code>nil</code>，返回的是<code>Boolean</code>表示 point 是否在当前 View 的Bounds中。</p>\n</li>\n<li><p><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>同样，传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，event 可为<code>nil</code>(我们本次讨论的是触碰事件的 Hit-Testing ，自然此参数不会为空)，此方法返回的是 point 所在的 View 。</p>\n</li>\n</ol>\n<p><code>hitTest:withEvent:</code>内部会先调用<code>pointInside:withEvent:</code>，来检测触碰点是否在当前View中</p>\n<ul>\n<li><p>若返回<code>NO</code>,则直接返回<code>nil</code>，且所有的 SubView 都不会响应当前事件。所以，敲重点啦，对于<code>clipsToBounds</code>设置为<code>NO</code>，允许 SubView 向外延伸的 View ，需要重载<code>pointInside:withEvent:</code>，例如：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg\" alt=\"TouchEvent_WechatIMG3\"></p>\n<pre><code class=\"objective-c\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n      //以下是伪代码  \n      if (point inside blueArea) return true;\n      else return false;\n}\n</code></pre>\n<p>如果没有重载<code>pointInside:withEvent:</code>，那么用户点击上图触碰点，SubView 将不响应事件。</p>\n</li>\n</ul>\n<ul>\n<li><p>若返回<code>YES</code>，则调用所有 SubView 的<code>hitTest:withEvent:</code>，继续寻找 HitTest View 。在视图层级树(这样翻译?!  view hierarchy )中<strong>最后添加的叶结点</strong>且<strong>包含触碰点</strong>的 View 就会光荣地成为 <strong>HitTest View</strong> (如下图最后一个 UIView )，首先接受事件，并做下一步操作——寻找响应对象。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg\" alt=\"TouchEvent_WechatIMG1\"></p>\n</li>\n</ul>\n<p>我们也可以在中途截断系统的 Hit-Testing ，如果你想让某个 View 的所有 SubView 都不响应事件，最简单的就是重载该 View 的<code>hitTest:withEvent:</code>，返回 View （自己响应点击事件）或者<code>nil</code>（都不响应）。</p>\n<pre><code class=\"objective-c\">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n      return self;    // 自己成为HitTest View\n}\n</code></pre>\n<h2 id=\"从上往下——寻找响应对象\"><a href=\"#从上往下——寻找响应对象\" class=\"headerlink\" title=\"从上往下——寻找响应对象\"></a>从上往下——寻找响应对象</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png\" alt=\"1387344-cd500e5bd93d9606\"></p>\n<p>这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：</p>\n<p>当上一步找到的 HitTest View 没能响应事件时( eg: userInteractionEnabled 为 NO 或者没有定义响应事件的方法)，那么事件就会被传递到 SuperView 或着 Controller 。直至 Applicaion 都不能处理该事件则忽略。</p>\n<p>需要注意的是：这里的传递只会给 SuperView 或着 Controller ，并不会传递给与自己相同级别的 View ，除非你自己控制。</p>\n<p>iOS10的 UIResponder 中定义了两个新的 Property ：</p>\n<ol>\n<li><code>nextResponder(Swift是next)</code>：这个比较蛋疼，因为 UIResponder 中它默认返回的是nil，所以如果我们想让特定的 Responder 响应事件，我们需要在我们的类中重载 Get 方法，返回自己想要的下一个 Responder 。</li>\n<li><code>isFirstResponder</code>：判断当前View或 Controller 是否为即将响应事件的 Responder 。不能明白？！那么想想这两个方法：<code>becomeFirstResponder</code>和<code>resignFirstResponder</code>：）</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>废话了这么多，三点：</p>\n<ol>\n<li>iOS 的 Touch Event 先「从下往上」寻找 HitTest View ( FirstResponder )，再「从上往下」寻找真正响应该事件的 Responder 。</li>\n<li>可以通过重载<code>hitTest:withEvent:</code>，决定 HitTest View ，即最开始<strong>接收（敲重点，只是接收）</strong>事件的 Responder 。</li>\n<li>Responder 不一定会响应事件，看有没有响应事件的方法。</li>\n</ol>\n<p>所以，以后如果有人问你：两个View重叠在一起，在上面的 View 将下面的 View 完全覆盖，且上面的 View 不能响应事件，下面的 View 会响应吗？</p>\n<p>你不如先反问一句，两个 View 是否为 SuperView 和 SubView 的关系？！</p>\n<p>再分门别类地回答～</p>\n<p>以上</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1\" target=\"_blank\" rel=\"external\">Event Handling Guide for iOS</a></p>\n","excerpt":"<p>本来不想重复造轮子，因为网上已经很多关于 iOS 触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～</p>","more":"<p>毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递( Event Delivery )，从 UIApplication 到响应事件的 UIView 是「从下往上」，反过来自然就是「从上往下」了。</p>\n<h2 id=\"从下往上——寻找-HitTest-View\"><a href=\"#从下往上——寻找-HitTest-View\" class=\"headerlink\" title=\"从下往上——寻找 HitTest View\"></a>从下往上——寻找 HitTest View</h2><p>当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象( Event Object )，携带着一些处理信息，eg: 点击位置、事件类型等，然后将这个对象存放在 UIApplication 的事件队列中，等待处理。</p>\n<p>我们开发中使用的最多的是触碰事件( Touch Event )，也只有触碰事件才需要 iOS 为我们寻找 <strong>HitTest View</strong> ，即<strong>寻找响应该事件的 View </strong>，这一过程，官方文档里称为 <strong><em>Hit-Testing</em></strong> 。</p>\n<p>了解这一过程，先了解 UIView 的两个可重载的方法：</p>\n<ol>\n<li><p><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，分别表示拥护触碰事件的<strong>触碰点</strong>和对应的<strong>事件</strong>，event 可为<code>nil</code>，返回的是<code>Boolean</code>表示 point 是否在当前 View 的Bounds中。</p>\n</li>\n<li><p><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>同样，传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，event 可为<code>nil</code>(我们本次讨论的是触碰事件的 Hit-Testing ，自然此参数不会为空)，此方法返回的是 point 所在的 View 。</p>\n</li>\n</ol>\n<p><code>hitTest:withEvent:</code>内部会先调用<code>pointInside:withEvent:</code>，来检测触碰点是否在当前View中</p>\n<ul>\n<li><p>若返回<code>NO</code>,则直接返回<code>nil</code>，且所有的 SubView 都不会响应当前事件。所以，敲重点啦，对于<code>clipsToBounds</code>设置为<code>NO</code>，允许 SubView 向外延伸的 View ，需要重载<code>pointInside:withEvent:</code>，例如：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg\" alt=\"TouchEvent_WechatIMG3\"></p>\n<pre><code class=\"objective-c\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n      //以下是伪代码  \n      if (point inside blueArea) return true;\n      else return false;\n}\n</code></pre>\n<p>如果没有重载<code>pointInside:withEvent:</code>，那么用户点击上图触碰点，SubView 将不响应事件。</p>\n</li>\n</ul>\n<ul>\n<li><p>若返回<code>YES</code>，则调用所有 SubView 的<code>hitTest:withEvent:</code>，继续寻找 HitTest View 。在视图层级树(这样翻译?!  view hierarchy )中<strong>最后添加的叶结点</strong>且<strong>包含触碰点</strong>的 View 就会光荣地成为 <strong>HitTest View</strong> (如下图最后一个 UIView )，首先接受事件，并做下一步操作——寻找响应对象。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg\" alt=\"TouchEvent_WechatIMG1\"></p>\n</li>\n</ul>\n<p>我们也可以在中途截断系统的 Hit-Testing ，如果你想让某个 View 的所有 SubView 都不响应事件，最简单的就是重载该 View 的<code>hitTest:withEvent:</code>，返回 View （自己响应点击事件）或者<code>nil</code>（都不响应）。</p>\n<pre><code class=\"objective-c\">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n      return self;    // 自己成为HitTest View\n}\n</code></pre>\n<h2 id=\"从上往下——寻找响应对象\"><a href=\"#从上往下——寻找响应对象\" class=\"headerlink\" title=\"从上往下——寻找响应对象\"></a>从上往下——寻找响应对象</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png\" alt=\"1387344-cd500e5bd93d9606\"></p>\n<p>这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：</p>\n<p>当上一步找到的 HitTest View 没能响应事件时( eg: userInteractionEnabled 为 NO 或者没有定义响应事件的方法)，那么事件就会被传递到 SuperView 或着 Controller 。直至 Applicaion 都不能处理该事件则忽略。</p>\n<p>需要注意的是：这里的传递只会给 SuperView 或着 Controller ，并不会传递给与自己相同级别的 View ，除非你自己控制。</p>\n<p>iOS10的 UIResponder 中定义了两个新的 Property ：</p>\n<ol>\n<li><code>nextResponder(Swift是next)</code>：这个比较蛋疼，因为 UIResponder 中它默认返回的是nil，所以如果我们想让特定的 Responder 响应事件，我们需要在我们的类中重载 Get 方法，返回自己想要的下一个 Responder 。</li>\n<li><code>isFirstResponder</code>：判断当前View或 Controller 是否为即将响应事件的 Responder 。不能明白？！那么想想这两个方法：<code>becomeFirstResponder</code>和<code>resignFirstResponder</code>：）</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>废话了这么多，三点：</p>\n<ol>\n<li>iOS 的 Touch Event 先「从下往上」寻找 HitTest View ( FirstResponder )，再「从上往下」寻找真正响应该事件的 Responder 。</li>\n<li>可以通过重载<code>hitTest:withEvent:</code>，决定 HitTest View ，即最开始<strong>接收（敲重点，只是接收）</strong>事件的 Responder 。</li>\n<li>Responder 不一定会响应事件，看有没有响应事件的方法。</li>\n</ol>\n<p>所以，以后如果有人问你：两个View重叠在一起，在上面的 View 将下面的 View 完全覆盖，且上面的 View 不能响应事件，下面的 View 会响应吗？</p>\n<p>你不如先反问一句，两个 View 是否为 SuperView 和 SubView 的关系？！</p>\n<p>再分门别类地回答～</p>\n<p>以上</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1\">Event Handling Guide for iOS</a></p>"},{"title":"iOS脚本打包 - xcodebuild","date":"2018-04-02T03:39:08.000Z","typora-copy-images-to":"ipic","_content":"\nxcodebuild 和 xcrun 是 Xcode 为开发者提供的一套构建打包的命令。使用它们编写脚本，可以实现通过脚本自动化打包的功能。本文基于 Xcode9 ，xcrun 的打包工具被移除，因此笔者主要使用 xcodebuild 来完成打包工作。\n\n<!--more-->\n\n在日常开发中，无论是提交给测试部测试还是最终打包上线，都需要将工程打包成 ipa 文件，通常我们是选定 Scheme ，然后在 Xcode 中点击『 Project - Archive 』，当整个工程  archive 后，在自动弹出的 『 Organizer 』 中点击『 Export 』，选择 Ad Hoc 或 App Store ，选择证书或自动签名，等待圈圈转完，导出到指定位置，才能得到里面的 ipa 文件。虽然 Xcode 完美地帮我们完成这一项工作，但其中我们还是需要点击 5 ~ 6 次。而使用脚本来构建打包，就只需要一个命令运行脚本，在等待脚本运行结束的时候，我们可以同时进行其他的工作。\n\n同时，使用构建脚本也能更好地集成 CI 。\n\n## xcodebuild\n\n> xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.\n\n`xcodebuild`是构建工具，可以将工程中的 target 或 scheme 编译、链接成 .app 文件。要使用`xcodebuild`，需要在`.xcodeproj`存放的文件夹中执行。\n\n可以使用`man`来查看`xcodebuild`，可以看到该命令提供了一些常用概要( *SYNOPSIS* )：\n\n```shell\nxcodebuild [-project name.xcodeproj]\n           [[-target targetname] ... | -alltargets]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild [-project name.xcodeproj] -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -workspace name.xcworkspace -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]\n\nxcodebuild -showsdks\n\nxcodebuild -showBuildSettings\n           [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]\n\nxcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]\n\nxcodebuild -exportArchive -archivePath xcarchivepath -exportPath\n                destinationpath -exportOptionsPlist path\n\nxcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] ...]\n\nxcodebuild -importLocalizations -project name.xcodeproj -localizationPath path\n```\n\n前三条指令是比较常用的，其中涉及很多参数：\n\n* -project：指定要构建的 project ，当文件夹中有多个`.xcodeproj`文件时需要指定。\n* -target：指定构建哪一个 target 。默认地，若不指定此参数，xcodebuild 构建工程中的第一个 target 。\n* -alltargets：构建所有 target 。\n* -workspace：如果要构建一个 workspace （例如使用 cocoapods 管理第三方依赖文件），则需要指定 workspace ，当然后缀就是`.xcworkspace`。\n* -scheme：构建 workspace ，还必须指定 scheme ，使用此参数。\n* -destination：指定设备，如：`'platform=OS X,arch=x86_64'`指代当前 Mac 或`generic/platform=iOS`指定 Generic iOS device 。\n* -destination-timeout：搜索指定设备超时时间，默认 30S 。\n* -configuration：如果工程中没有添加其他配置，默认就是 Debug 和 Release 这两个版本。没有指定此参数和 scheme 参数，则默认为 Release 版本。\n* -arch：指定架构 armv7、armv7s、arm64 等。\n* -sdk：指定构建使用的 sdk ，后跟 sdk 的绝对路径或 sdk 名称，可通过`xcodebuild -showsdks`查看。\n* -list：查看工程的 target、configuration、scheme 。\n\n我们常用`xcodebuild`来构建项目，得到 .app 文件，但其实，`xcodebuild`也能打包出我们需要的 .ipa 文件，这就需要了解多以下几个比较重要的参数：\n\n* -exportArchive：archive 后导出，需要`-exportFormat` ，`-archivePath` 和` -exportPath`三个参数\n* -exportFormat：指定格式为 pkg ( macOS ) 或 ipa ( iOS ) 的一种\n* -archivePath：指定 archive 文件的地址，将此`.xcarchive`打包成 ipa\n* -exportPath：最后输出文件 ipa 所在的**文件夹**。\n* -exportOptionsPlist：plist 文件，其中定义了将`.xcarchive`导出成 ipa 所需要的配置参数。后面会说到。\n\n`xcodebuild`还能进行各种操作，挑选一些常用的来讲：\n\n* build：构建，默认操作。如果没有指定，则默认为 build ，将会在`SYMROOT`中生成文件夹`[configuration]-iphones`的文件夹（ configuration 见上述参数介绍）。其中有项目用到的第三方库的 framework 、`.app`文件、`.dSYM`文件。\n* archive：对应 Xcode 中的 Archive ，在 build 的基础上还将生成`.xcarchive`文件。\n* clean：对应 Xcode 中的 clean ，删除上次构建过程产生的中间文件。\n\n## xcrun\n\n```shell\nxcrun -sdk iphoneos PackageApplication \"./Release-iphoneos/${APP_NAME}.app\" -o ~/\"${IPANAME}\"\n```\n\nxcrun 更多地用来将app文件打包到 ipa 中，得以安装在用户的设备上。其中使用到 *PackageApplication* 这个工具，命令也相对简单，就不多说了。\n\n需要注意的是：从 Xcode8.3 开始，*PackageApplication* 从开发工具中被移除，因此我们用来将.app打包成ipa最常用的`xcrun`指令也变得不好用了。当然可以从旧版本的 Xcode 中将 *PackageApplication* 拷贝一份放在新的 Xcode 中，让 *PackageApplication* 继续发光发热。请见[stackoverflow](https://stackoverflow.com/questions/43068608/xcrun-error-unable-to-find-utility-packageapplication-not-a-developer-tool)。\n\n不过使用`xcrun`还可能存在一些问题：当解压 ipa 后，你会发现，在 app 文件中，`Payload`文件夹存在，但是`BCSymbolMaps`、`SwiftSupport` 和`Symbols`却找不到了，这有可能会在提交到 App Store 的时候出现问题。\n\n但是从 Xcode 中 Export xcarchive 则不会出现这样的问题，说明单纯使用 xcrun 的打包旧命令已经不被建议使用了。\n\n## Demonstration🌰\n\n笔者在使用脚本打包的时候舍弃了 xcrun ，直接用 xcodebuild 来完成工作，提供一个示例：\n\n```shell\n# 工程名\nAPP_NAME=\"KeyX_iOS\"\n# info.plist路径\nPROJECT_INFOPLIST_PATH=\"./${APP_NAME}/Supporting Files/Info.plist\"\n# exportOptions.plist路径\nEXPORT_PLIST=\"./KeyXExportOptions.plist\"\necho \"==============some message==============\"\necho \"info.plist路径 = ${PROJECT_INFOPLIST_PATH}\"\n# 取版本号\nBUNDLE_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c \"print CFBundleShortVersionString\" \"${PROJECT_INFOPLIST_PATH}\")\necho \"版本号 = ${BUNDLE_SHORT_VERSION}\"\n# 取build值\nBUNDLE_VERSION=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" \"${PROJECT_INFOPLIST_PATH}\")\necho \"开发版本 = ${BUNDLE_VERSION}\"\nDATE=\"$(date +%Y%m%d)\"\nIPA_NAME=\"${APP_NAME}_V${BUNDLE_SHORT_VERSION}.${BUNDLE_VERSION}_${DATE}.ipa\"\n# ipa文件路径，保存起来以便后面使用\nIPA_PATH=\"$PWD/${IPA_NAME}\"\necho \"要上传的ipa文件路径 = ${IPA_PATH}\"\necho \"${IPA_PATH}\">> ipa_path\n# 下面3行是集成有Cocopods的用法\necho \"=============pod install===============\"\npod install\n\necho \"================clean==================\"\nxcodebuild \\\n\t-workspace \"${APP_NAME}.xcworkspace\" \\\n\t-scheme \"${APP_NAME}\"  \\\n\t-configuration 'Release' \\\n\tclean\n\necho \"===============archive=================\"\nxcodebuild \\\n\t-workspace \"${APP_NAME}.xcworkspace\" \\\n\t-scheme \"${APP_NAME}\" \\\n\t-sdk iphoneos \\\n\t-configuration 'Release' \\\n\t-archivePath \"${APP_NAME}.xcarchive\" \\\n\tPROVISIONING_PROFILE_SPECIFIER=\"PROVISIONING_PROFILE_NAME_OR_ID\" \\\n\tDEVELOPMENT_TEAM=\"TEAMID\" \\\n\t-allowProvisioningUpdates \\\n\tSYMROOT='$PWD' \\\n\tarchive\n\n# 将app打包成ipa\necho \"================export=================\"\nxcodebuild \\\n\t-exportArchive \\\n\t-archivePath \"${APP_NAME}.xcarchive\" \\\n\t-exportOptionsPlist \"${EXPORT_PLIST}\" \\\n\t-exportPath \"$PWD\"\n\n# 将ipa的名称修改成我们自定义的名称 IPA_NAME\nmv \"${APP_NAME}.ipa\" \"${IPA_NAME}\"\n```\n\n需要注意几点：\n\n1. archive 前 clean 是一个比较好的习惯，清除上次构建形成的中间文件。\n2. archive 时配置了`PROVISIONING_PROFILE_SPECIFIER`和`DEVELOPMENT_TEAM`，用于指定 archive 的签名使用的证书，需要使用 development 用的 Provisioning Profile ，不可以用 app store 或 ad-hoc 的。\n3. 第 2 点中那两个配置，如果去掉，则默认读取 xcodeproj 中的配置。此时可以在 Xcode 的`Target->Signing->Automaticall manage signing`打勾由 Xcode 设置开发证书，或自己设置开发用的 Provisioning Profiles 并确保配置无误（ manual signing ）。\n4. 还是第 2 点的配置，在命令中可以配置的命令请见[这里](https://help.apple.com/xcode/mac/current/#/itcaec37c2a6?sub=dev186481df2)。\n5. `allowProvisioningUpdates`是 Xcode9 才引入的，允许`xcodebuild`自动更新 Provisioning profile 等。\n\n### -exportOptionsPlist 参数\n\nExportOptions.plist 存在很久了，只是一直没有被拿来使用。在 xcodebuild 打包的时候，这个参数指定 ExportOptions.plist 的位置，用来告诉`xcodebuild`怎么将`.xcarchive`文件打包。\n\n下面是笔者所使用的 plist 文件：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gq8g9.png)\n\nprovisioningProfiles 中，key 是 bundleid ， value 是对应的 provisioningProfile 的名称或 ID 。\n\n有哪些键可以通过`xcodebuild -help`，然后拉到最下面查看。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l89oh.png)\n\n如果还是觉得创建麻烦，可以先在 Xcode 中手动打包一遍，在 Export 后的文件夹中找到`ExportOptions.plist`，这就是适用于项目的 plist 文件了。\n\n## Troubleshotting\n\n编写此章节，是为了记录打包时出现的错误，长期更新：\n\n### 1.ipatool-json-filepath-XXXXXX \"No value\".\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m5j01.png)\n\n笔者遇到此问题的时候，是因为 archive 失败，但是路径中还是出现了`.xcarchive`文件，继续往下 export 的时候就报错了，此时不妨尝试一下，只是 archive 是否有问题？具体原因笔者尚未发现。\n\n## Reference\n\n[1.Building from the Command Line with Xcode FAQ](https://developer.apple.com/library/content/technotes/tn2339/_index.html)\n\n[2.Using -exportArchive instead of Package Application to export an IPA](http://subathrathanabalan.com/2016/01/07/building-ipa-export-archive/)\n\n[3.XCArchive to ipa](https://encyclopediaofdaniel.com/blog/xcarchive-to-ipa/)\n\n[4.Xcode Help](https://help.apple.com/xcode/mac/current/#/dev3a05256b8)","source":"_posts/iOS脚本打包.md","raw":"---\ntitle: iOS脚本打包 - xcodebuild\ndate: 2018-04-02 11:39:08\ntags: \n- Distribution\ntypora-copy-images-to: ipic\n---\n\nxcodebuild 和 xcrun 是 Xcode 为开发者提供的一套构建打包的命令。使用它们编写脚本，可以实现通过脚本自动化打包的功能。本文基于 Xcode9 ，xcrun 的打包工具被移除，因此笔者主要使用 xcodebuild 来完成打包工作。\n\n<!--more-->\n\n在日常开发中，无论是提交给测试部测试还是最终打包上线，都需要将工程打包成 ipa 文件，通常我们是选定 Scheme ，然后在 Xcode 中点击『 Project - Archive 』，当整个工程  archive 后，在自动弹出的 『 Organizer 』 中点击『 Export 』，选择 Ad Hoc 或 App Store ，选择证书或自动签名，等待圈圈转完，导出到指定位置，才能得到里面的 ipa 文件。虽然 Xcode 完美地帮我们完成这一项工作，但其中我们还是需要点击 5 ~ 6 次。而使用脚本来构建打包，就只需要一个命令运行脚本，在等待脚本运行结束的时候，我们可以同时进行其他的工作。\n\n同时，使用构建脚本也能更好地集成 CI 。\n\n## xcodebuild\n\n> xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.\n\n`xcodebuild`是构建工具，可以将工程中的 target 或 scheme 编译、链接成 .app 文件。要使用`xcodebuild`，需要在`.xcodeproj`存放的文件夹中执行。\n\n可以使用`man`来查看`xcodebuild`，可以看到该命令提供了一些常用概要( *SYNOPSIS* )：\n\n```shell\nxcodebuild [-project name.xcodeproj]\n           [[-target targetname] ... | -alltargets]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild [-project name.xcodeproj] -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -workspace name.xcworkspace -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]\n\nxcodebuild -showsdks\n\nxcodebuild -showBuildSettings\n           [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]\n\nxcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]\n\nxcodebuild -exportArchive -archivePath xcarchivepath -exportPath\n                destinationpath -exportOptionsPlist path\n\nxcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] ...]\n\nxcodebuild -importLocalizations -project name.xcodeproj -localizationPath path\n```\n\n前三条指令是比较常用的，其中涉及很多参数：\n\n* -project：指定要构建的 project ，当文件夹中有多个`.xcodeproj`文件时需要指定。\n* -target：指定构建哪一个 target 。默认地，若不指定此参数，xcodebuild 构建工程中的第一个 target 。\n* -alltargets：构建所有 target 。\n* -workspace：如果要构建一个 workspace （例如使用 cocoapods 管理第三方依赖文件），则需要指定 workspace ，当然后缀就是`.xcworkspace`。\n* -scheme：构建 workspace ，还必须指定 scheme ，使用此参数。\n* -destination：指定设备，如：`'platform=OS X,arch=x86_64'`指代当前 Mac 或`generic/platform=iOS`指定 Generic iOS device 。\n* -destination-timeout：搜索指定设备超时时间，默认 30S 。\n* -configuration：如果工程中没有添加其他配置，默认就是 Debug 和 Release 这两个版本。没有指定此参数和 scheme 参数，则默认为 Release 版本。\n* -arch：指定架构 armv7、armv7s、arm64 等。\n* -sdk：指定构建使用的 sdk ，后跟 sdk 的绝对路径或 sdk 名称，可通过`xcodebuild -showsdks`查看。\n* -list：查看工程的 target、configuration、scheme 。\n\n我们常用`xcodebuild`来构建项目，得到 .app 文件，但其实，`xcodebuild`也能打包出我们需要的 .ipa 文件，这就需要了解多以下几个比较重要的参数：\n\n* -exportArchive：archive 后导出，需要`-exportFormat` ，`-archivePath` 和` -exportPath`三个参数\n* -exportFormat：指定格式为 pkg ( macOS ) 或 ipa ( iOS ) 的一种\n* -archivePath：指定 archive 文件的地址，将此`.xcarchive`打包成 ipa\n* -exportPath：最后输出文件 ipa 所在的**文件夹**。\n* -exportOptionsPlist：plist 文件，其中定义了将`.xcarchive`导出成 ipa 所需要的配置参数。后面会说到。\n\n`xcodebuild`还能进行各种操作，挑选一些常用的来讲：\n\n* build：构建，默认操作。如果没有指定，则默认为 build ，将会在`SYMROOT`中生成文件夹`[configuration]-iphones`的文件夹（ configuration 见上述参数介绍）。其中有项目用到的第三方库的 framework 、`.app`文件、`.dSYM`文件。\n* archive：对应 Xcode 中的 Archive ，在 build 的基础上还将生成`.xcarchive`文件。\n* clean：对应 Xcode 中的 clean ，删除上次构建过程产生的中间文件。\n\n## xcrun\n\n```shell\nxcrun -sdk iphoneos PackageApplication \"./Release-iphoneos/${APP_NAME}.app\" -o ~/\"${IPANAME}\"\n```\n\nxcrun 更多地用来将app文件打包到 ipa 中，得以安装在用户的设备上。其中使用到 *PackageApplication* 这个工具，命令也相对简单，就不多说了。\n\n需要注意的是：从 Xcode8.3 开始，*PackageApplication* 从开发工具中被移除，因此我们用来将.app打包成ipa最常用的`xcrun`指令也变得不好用了。当然可以从旧版本的 Xcode 中将 *PackageApplication* 拷贝一份放在新的 Xcode 中，让 *PackageApplication* 继续发光发热。请见[stackoverflow](https://stackoverflow.com/questions/43068608/xcrun-error-unable-to-find-utility-packageapplication-not-a-developer-tool)。\n\n不过使用`xcrun`还可能存在一些问题：当解压 ipa 后，你会发现，在 app 文件中，`Payload`文件夹存在，但是`BCSymbolMaps`、`SwiftSupport` 和`Symbols`却找不到了，这有可能会在提交到 App Store 的时候出现问题。\n\n但是从 Xcode 中 Export xcarchive 则不会出现这样的问题，说明单纯使用 xcrun 的打包旧命令已经不被建议使用了。\n\n## Demonstration🌰\n\n笔者在使用脚本打包的时候舍弃了 xcrun ，直接用 xcodebuild 来完成工作，提供一个示例：\n\n```shell\n# 工程名\nAPP_NAME=\"KeyX_iOS\"\n# info.plist路径\nPROJECT_INFOPLIST_PATH=\"./${APP_NAME}/Supporting Files/Info.plist\"\n# exportOptions.plist路径\nEXPORT_PLIST=\"./KeyXExportOptions.plist\"\necho \"==============some message==============\"\necho \"info.plist路径 = ${PROJECT_INFOPLIST_PATH}\"\n# 取版本号\nBUNDLE_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c \"print CFBundleShortVersionString\" \"${PROJECT_INFOPLIST_PATH}\")\necho \"版本号 = ${BUNDLE_SHORT_VERSION}\"\n# 取build值\nBUNDLE_VERSION=$(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" \"${PROJECT_INFOPLIST_PATH}\")\necho \"开发版本 = ${BUNDLE_VERSION}\"\nDATE=\"$(date +%Y%m%d)\"\nIPA_NAME=\"${APP_NAME}_V${BUNDLE_SHORT_VERSION}.${BUNDLE_VERSION}_${DATE}.ipa\"\n# ipa文件路径，保存起来以便后面使用\nIPA_PATH=\"$PWD/${IPA_NAME}\"\necho \"要上传的ipa文件路径 = ${IPA_PATH}\"\necho \"${IPA_PATH}\">> ipa_path\n# 下面3行是集成有Cocopods的用法\necho \"=============pod install===============\"\npod install\n\necho \"================clean==================\"\nxcodebuild \\\n\t-workspace \"${APP_NAME}.xcworkspace\" \\\n\t-scheme \"${APP_NAME}\"  \\\n\t-configuration 'Release' \\\n\tclean\n\necho \"===============archive=================\"\nxcodebuild \\\n\t-workspace \"${APP_NAME}.xcworkspace\" \\\n\t-scheme \"${APP_NAME}\" \\\n\t-sdk iphoneos \\\n\t-configuration 'Release' \\\n\t-archivePath \"${APP_NAME}.xcarchive\" \\\n\tPROVISIONING_PROFILE_SPECIFIER=\"PROVISIONING_PROFILE_NAME_OR_ID\" \\\n\tDEVELOPMENT_TEAM=\"TEAMID\" \\\n\t-allowProvisioningUpdates \\\n\tSYMROOT='$PWD' \\\n\tarchive\n\n# 将app打包成ipa\necho \"================export=================\"\nxcodebuild \\\n\t-exportArchive \\\n\t-archivePath \"${APP_NAME}.xcarchive\" \\\n\t-exportOptionsPlist \"${EXPORT_PLIST}\" \\\n\t-exportPath \"$PWD\"\n\n# 将ipa的名称修改成我们自定义的名称 IPA_NAME\nmv \"${APP_NAME}.ipa\" \"${IPA_NAME}\"\n```\n\n需要注意几点：\n\n1. archive 前 clean 是一个比较好的习惯，清除上次构建形成的中间文件。\n2. archive 时配置了`PROVISIONING_PROFILE_SPECIFIER`和`DEVELOPMENT_TEAM`，用于指定 archive 的签名使用的证书，需要使用 development 用的 Provisioning Profile ，不可以用 app store 或 ad-hoc 的。\n3. 第 2 点中那两个配置，如果去掉，则默认读取 xcodeproj 中的配置。此时可以在 Xcode 的`Target->Signing->Automaticall manage signing`打勾由 Xcode 设置开发证书，或自己设置开发用的 Provisioning Profiles 并确保配置无误（ manual signing ）。\n4. 还是第 2 点的配置，在命令中可以配置的命令请见[这里](https://help.apple.com/xcode/mac/current/#/itcaec37c2a6?sub=dev186481df2)。\n5. `allowProvisioningUpdates`是 Xcode9 才引入的，允许`xcodebuild`自动更新 Provisioning profile 等。\n\n### -exportOptionsPlist 参数\n\nExportOptions.plist 存在很久了，只是一直没有被拿来使用。在 xcodebuild 打包的时候，这个参数指定 ExportOptions.plist 的位置，用来告诉`xcodebuild`怎么将`.xcarchive`文件打包。\n\n下面是笔者所使用的 plist 文件：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gq8g9.png)\n\nprovisioningProfiles 中，key 是 bundleid ， value 是对应的 provisioningProfile 的名称或 ID 。\n\n有哪些键可以通过`xcodebuild -help`，然后拉到最下面查看。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l89oh.png)\n\n如果还是觉得创建麻烦，可以先在 Xcode 中手动打包一遍，在 Export 后的文件夹中找到`ExportOptions.plist`，这就是适用于项目的 plist 文件了。\n\n## Troubleshotting\n\n编写此章节，是为了记录打包时出现的错误，长期更新：\n\n### 1.ipatool-json-filepath-XXXXXX \"No value\".\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m5j01.png)\n\n笔者遇到此问题的时候，是因为 archive 失败，但是路径中还是出现了`.xcarchive`文件，继续往下 export 的时候就报错了，此时不妨尝试一下，只是 archive 是否有问题？具体原因笔者尚未发现。\n\n## Reference\n\n[1.Building from the Command Line with Xcode FAQ](https://developer.apple.com/library/content/technotes/tn2339/_index.html)\n\n[2.Using -exportArchive instead of Package Application to export an IPA](http://subathrathanabalan.com/2016/01/07/building-ipa-export-archive/)\n\n[3.XCArchive to ipa](https://encyclopediaofdaniel.com/blog/xcarchive-to-ipa/)\n\n[4.Xcode Help](https://help.apple.com/xcode/mac/current/#/dev3a05256b8)","slug":"iOS脚本打包","published":1,"updated":"2018-11-06T12:41:05.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6du000cqu0xi3zdt141","content":"<p>xcodebuild 和 xcrun 是 Xcode 为开发者提供的一套构建打包的命令。使用它们编写脚本，可以实现通过脚本自动化打包的功能。本文基于 Xcode9 ，xcrun 的打包工具被移除，因此笔者主要使用 xcodebuild 来完成打包工作。</p>\n<a id=\"more\"></a>\n<p>在日常开发中，无论是提交给测试部测试还是最终打包上线，都需要将工程打包成 ipa 文件，通常我们是选定 Scheme ，然后在 Xcode 中点击『 Project - Archive 』，当整个工程  archive 后，在自动弹出的 『 Organizer 』 中点击『 Export 』，选择 Ad Hoc 或 App Store ，选择证书或自动签名，等待圈圈转完，导出到指定位置，才能得到里面的 ipa 文件。虽然 Xcode 完美地帮我们完成这一项工作，但其中我们还是需要点击 5 ~ 6 次。而使用脚本来构建打包，就只需要一个命令运行脚本，在等待脚本运行结束的时候，我们可以同时进行其他的工作。</p>\n<p>同时，使用构建脚本也能更好地集成 CI 。</p>\n<h2 id=\"xcodebuild\"><a href=\"#xcodebuild\" class=\"headerlink\" title=\"xcodebuild\"></a>xcodebuild</h2><blockquote>\n<p>xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.</p>\n</blockquote>\n<p><code>xcodebuild</code>是构建工具，可以将工程中的 target 或 scheme 编译、链接成 .app 文件。要使用<code>xcodebuild</code>，需要在<code>.xcodeproj</code>存放的文件夹中执行。</p>\n<p>可以使用<code>man</code>来查看<code>xcodebuild</code>，可以看到该命令提供了一些常用概要( <em>SYNOPSIS</em> )：</p>\n<pre><code class=\"shell\">xcodebuild [-project name.xcodeproj]\n           [[-target targetname] ... | -alltargets]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild [-project name.xcodeproj] -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -workspace name.xcworkspace -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]\n\nxcodebuild -showsdks\n\nxcodebuild -showBuildSettings\n           [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]\n\nxcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]\n\nxcodebuild -exportArchive -archivePath xcarchivepath -exportPath\n                destinationpath -exportOptionsPlist path\n\nxcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] ...]\n\nxcodebuild -importLocalizations -project name.xcodeproj -localizationPath path\n</code></pre>\n<p>前三条指令是比较常用的，其中涉及很多参数：</p>\n<ul>\n<li>-project：指定要构建的 project ，当文件夹中有多个<code>.xcodeproj</code>文件时需要指定。</li>\n<li>-target：指定构建哪一个 target 。默认地，若不指定此参数，xcodebuild 构建工程中的第一个 target 。</li>\n<li>-alltargets：构建所有 target 。</li>\n<li>-workspace：如果要构建一个 workspace （例如使用 cocoapods 管理第三方依赖文件），则需要指定 workspace ，当然后缀就是<code>.xcworkspace</code>。</li>\n<li>-scheme：构建 workspace ，还必须指定 scheme ，使用此参数。</li>\n<li>-destination：指定设备，如：<code>&#39;platform=OS X,arch=x86_64&#39;</code>指代当前 Mac 或<code>generic/platform=iOS</code>指定 Generic iOS device 。</li>\n<li>-destination-timeout：搜索指定设备超时时间，默认 30S 。</li>\n<li>-configuration：如果工程中没有添加其他配置，默认就是 Debug 和 Release 这两个版本。没有指定此参数和 scheme 参数，则默认为 Release 版本。</li>\n<li>-arch：指定架构 armv7、armv7s、arm64 等。</li>\n<li>-sdk：指定构建使用的 sdk ，后跟 sdk 的绝对路径或 sdk 名称，可通过<code>xcodebuild -showsdks</code>查看。</li>\n<li>-list：查看工程的 target、configuration、scheme 。</li>\n</ul>\n<p>我们常用<code>xcodebuild</code>来构建项目，得到 .app 文件，但其实，<code>xcodebuild</code>也能打包出我们需要的 .ipa 文件，这就需要了解多以下几个比较重要的参数：</p>\n<ul>\n<li>-exportArchive：archive 后导出，需要<code>-exportFormat</code> ，<code>-archivePath</code> 和<code>-exportPath</code>三个参数</li>\n<li>-exportFormat：指定格式为 pkg ( macOS ) 或 ipa ( iOS ) 的一种</li>\n<li>-archivePath：指定 archive 文件的地址，将此<code>.xcarchive</code>打包成 ipa</li>\n<li>-exportPath：最后输出文件 ipa 所在的<strong>文件夹</strong>。</li>\n<li>-exportOptionsPlist：plist 文件，其中定义了将<code>.xcarchive</code>导出成 ipa 所需要的配置参数。后面会说到。</li>\n</ul>\n<p><code>xcodebuild</code>还能进行各种操作，挑选一些常用的来讲：</p>\n<ul>\n<li>build：构建，默认操作。如果没有指定，则默认为 build ，将会在<code>SYMROOT</code>中生成文件夹<code>[configuration]-iphones</code>的文件夹（ configuration 见上述参数介绍）。其中有项目用到的第三方库的 framework 、<code>.app</code>文件、<code>.dSYM</code>文件。</li>\n<li>archive：对应 Xcode 中的 Archive ，在 build 的基础上还将生成<code>.xcarchive</code>文件。</li>\n<li>clean：对应 Xcode 中的 clean ，删除上次构建过程产生的中间文件。</li>\n</ul>\n<h2 id=\"xcrun\"><a href=\"#xcrun\" class=\"headerlink\" title=\"xcrun\"></a>xcrun</h2><pre><code class=\"shell\">xcrun -sdk iphoneos PackageApplication &quot;./Release-iphoneos/${APP_NAME}.app&quot; -o ~/&quot;${IPANAME}&quot;\n</code></pre>\n<p>xcrun 更多地用来将app文件打包到 ipa 中，得以安装在用户的设备上。其中使用到 <em>PackageApplication</em> 这个工具，命令也相对简单，就不多说了。</p>\n<p>需要注意的是：从 Xcode8.3 开始，<em>PackageApplication</em> 从开发工具中被移除，因此我们用来将.app打包成ipa最常用的<code>xcrun</code>指令也变得不好用了。当然可以从旧版本的 Xcode 中将 <em>PackageApplication</em> 拷贝一份放在新的 Xcode 中，让 <em>PackageApplication</em> 继续发光发热。请见<a href=\"https://stackoverflow.com/questions/43068608/xcrun-error-unable-to-find-utility-packageapplication-not-a-developer-tool\" target=\"_blank\" rel=\"external\">stackoverflow</a>。</p>\n<p>不过使用<code>xcrun</code>还可能存在一些问题：当解压 ipa 后，你会发现，在 app 文件中，<code>Payload</code>文件夹存在，但是<code>BCSymbolMaps</code>、<code>SwiftSupport</code> 和<code>Symbols</code>却找不到了，这有可能会在提交到 App Store 的时候出现问题。</p>\n<p>但是从 Xcode 中 Export xcarchive 则不会出现这样的问题，说明单纯使用 xcrun 的打包旧命令已经不被建议使用了。</p>\n<h2 id=\"Demonstration🌰\"><a href=\"#Demonstration🌰\" class=\"headerlink\" title=\"Demonstration🌰\"></a>Demonstration🌰</h2><p>笔者在使用脚本打包的时候舍弃了 xcrun ，直接用 xcodebuild 来完成工作，提供一个示例：</p>\n<pre><code class=\"shell\"># 工程名\nAPP_NAME=&quot;KeyX_iOS&quot;\n# info.plist路径\nPROJECT_INFOPLIST_PATH=&quot;./${APP_NAME}/Supporting Files/Info.plist&quot;\n# exportOptions.plist路径\nEXPORT_PLIST=&quot;./KeyXExportOptions.plist&quot;\necho &quot;==============some message==============&quot;\necho &quot;info.plist路径 = ${PROJECT_INFOPLIST_PATH}&quot;\n# 取版本号\nBUNDLE_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${PROJECT_INFOPLIST_PATH}&quot;)\necho &quot;版本号 = ${BUNDLE_SHORT_VERSION}&quot;\n# 取build值\nBUNDLE_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;${PROJECT_INFOPLIST_PATH}&quot;)\necho &quot;开发版本 = ${BUNDLE_VERSION}&quot;\nDATE=&quot;$(date +%Y%m%d)&quot;\nIPA_NAME=&quot;${APP_NAME}_V${BUNDLE_SHORT_VERSION}.${BUNDLE_VERSION}_${DATE}.ipa&quot;\n# ipa文件路径，保存起来以便后面使用\nIPA_PATH=&quot;$PWD/${IPA_NAME}&quot;\necho &quot;要上传的ipa文件路径 = ${IPA_PATH}&quot;\necho &quot;${IPA_PATH}&quot;&gt;&gt; ipa_path\n# 下面3行是集成有Cocopods的用法\necho &quot;=============pod install===============&quot;\npod install\n\necho &quot;================clean==================&quot;\nxcodebuild \\\n    -workspace &quot;${APP_NAME}.xcworkspace&quot; \\\n    -scheme &quot;${APP_NAME}&quot;  \\\n    -configuration &#39;Release&#39; \\\n    clean\n\necho &quot;===============archive=================&quot;\nxcodebuild \\\n    -workspace &quot;${APP_NAME}.xcworkspace&quot; \\\n    -scheme &quot;${APP_NAME}&quot; \\\n    -sdk iphoneos \\\n    -configuration &#39;Release&#39; \\\n    -archivePath &quot;${APP_NAME}.xcarchive&quot; \\\n    PROVISIONING_PROFILE_SPECIFIER=&quot;PROVISIONING_PROFILE_NAME_OR_ID&quot; \\\n    DEVELOPMENT_TEAM=&quot;TEAMID&quot; \\\n    -allowProvisioningUpdates \\\n    SYMROOT=&#39;$PWD&#39; \\\n    archive\n\n# 将app打包成ipa\necho &quot;================export=================&quot;\nxcodebuild \\\n    -exportArchive \\\n    -archivePath &quot;${APP_NAME}.xcarchive&quot; \\\n    -exportOptionsPlist &quot;${EXPORT_PLIST}&quot; \\\n    -exportPath &quot;$PWD&quot;\n\n# 将ipa的名称修改成我们自定义的名称 IPA_NAME\nmv &quot;${APP_NAME}.ipa&quot; &quot;${IPA_NAME}&quot;\n</code></pre>\n<p>需要注意几点：</p>\n<ol>\n<li>archive 前 clean 是一个比较好的习惯，清除上次构建形成的中间文件。</li>\n<li>archive 时配置了<code>PROVISIONING_PROFILE_SPECIFIER</code>和<code>DEVELOPMENT_TEAM</code>，用于指定 archive 的签名使用的证书，需要使用 development 用的 Provisioning Profile ，不可以用 app store 或 ad-hoc 的。</li>\n<li>第 2 点中那两个配置，如果去掉，则默认读取 xcodeproj 中的配置。此时可以在 Xcode 的<code>Target-&gt;Signing-&gt;Automaticall manage signing</code>打勾由 Xcode 设置开发证书，或自己设置开发用的 Provisioning Profiles 并确保配置无误（ manual signing ）。</li>\n<li>还是第 2 点的配置，在命令中可以配置的命令请见<a href=\"https://help.apple.com/xcode/mac/current/#/itcaec37c2a6?sub=dev186481df2\" target=\"_blank\" rel=\"external\">这里</a>。</li>\n<li><code>allowProvisioningUpdates</code>是 Xcode9 才引入的，允许<code>xcodebuild</code>自动更新 Provisioning profile 等。</li>\n</ol>\n<h3 id=\"exportOptionsPlist-参数\"><a href=\"#exportOptionsPlist-参数\" class=\"headerlink\" title=\"-exportOptionsPlist 参数\"></a>-exportOptionsPlist 参数</h3><p>ExportOptions.plist 存在很久了，只是一直没有被拿来使用。在 xcodebuild 打包的时候，这个参数指定 ExportOptions.plist 的位置，用来告诉<code>xcodebuild</code>怎么将<code>.xcarchive</code>文件打包。</p>\n<p>下面是笔者所使用的 plist 文件：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gq8g9.png\" alt=\"\"></p>\n<p>provisioningProfiles 中，key 是 bundleid ， value 是对应的 provisioningProfile 的名称或 ID 。</p>\n<p>有哪些键可以通过<code>xcodebuild -help</code>，然后拉到最下面查看。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l89oh.png\" alt=\"\"></p>\n<p>如果还是觉得创建麻烦，可以先在 Xcode 中手动打包一遍，在 Export 后的文件夹中找到<code>ExportOptions.plist</code>，这就是适用于项目的 plist 文件了。</p>\n<h2 id=\"Troubleshotting\"><a href=\"#Troubleshotting\" class=\"headerlink\" title=\"Troubleshotting\"></a>Troubleshotting</h2><p>编写此章节，是为了记录打包时出现的错误，长期更新：</p>\n<h3 id=\"1-ipatool-json-filepath-XXXXXX-“No-value”\"><a href=\"#1-ipatool-json-filepath-XXXXXX-“No-value”\" class=\"headerlink\" title=\"1.ipatool-json-filepath-XXXXXX “No value”.\"></a>1.ipatool-json-filepath-XXXXXX “No value”.</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m5j01.png\" alt=\"\"></p>\n<p>笔者遇到此问题的时候，是因为 archive 失败，但是路径中还是出现了<code>.xcarchive</code>文件，继续往下 export 的时候就报错了，此时不妨尝试一下，只是 archive 是否有问题？具体原因笔者尚未发现。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://developer.apple.com/library/content/technotes/tn2339/_index.html\" target=\"_blank\" rel=\"external\">1.Building from the Command Line with Xcode FAQ</a></p>\n<p><a href=\"http://subathrathanabalan.com/2016/01/07/building-ipa-export-archive/\" target=\"_blank\" rel=\"external\">2.Using -exportArchive instead of Package Application to export an IPA</a></p>\n<p><a href=\"https://encyclopediaofdaniel.com/blog/xcarchive-to-ipa/\" target=\"_blank\" rel=\"external\">3.XCArchive to ipa</a></p>\n<p><a href=\"https://help.apple.com/xcode/mac/current/#/dev3a05256b8\" target=\"_blank\" rel=\"external\">4.Xcode Help</a></p>\n","excerpt":"<p>xcodebuild 和 xcrun 是 Xcode 为开发者提供的一套构建打包的命令。使用它们编写脚本，可以实现通过脚本自动化打包的功能。本文基于 Xcode9 ，xcrun 的打包工具被移除，因此笔者主要使用 xcodebuild 来完成打包工作。</p>","more":"<p>在日常开发中，无论是提交给测试部测试还是最终打包上线，都需要将工程打包成 ipa 文件，通常我们是选定 Scheme ，然后在 Xcode 中点击『 Project - Archive 』，当整个工程  archive 后，在自动弹出的 『 Organizer 』 中点击『 Export 』，选择 Ad Hoc 或 App Store ，选择证书或自动签名，等待圈圈转完，导出到指定位置，才能得到里面的 ipa 文件。虽然 Xcode 完美地帮我们完成这一项工作，但其中我们还是需要点击 5 ~ 6 次。而使用脚本来构建打包，就只需要一个命令运行脚本，在等待脚本运行结束的时候，我们可以同时进行其他的工作。</p>\n<p>同时，使用构建脚本也能更好地集成 CI 。</p>\n<h2 id=\"xcodebuild\"><a href=\"#xcodebuild\" class=\"headerlink\" title=\"xcodebuild\"></a>xcodebuild</h2><blockquote>\n<p>xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project.</p>\n</blockquote>\n<p><code>xcodebuild</code>是构建工具，可以将工程中的 target 或 scheme 编译、链接成 .app 文件。要使用<code>xcodebuild</code>，需要在<code>.xcodeproj</code>存放的文件夹中执行。</p>\n<p>可以使用<code>man</code>来查看<code>xcodebuild</code>，可以看到该命令提供了一些常用概要( <em>SYNOPSIS</em> )：</p>\n<pre><code class=\"shell\">xcodebuild [-project name.xcodeproj]\n           [[-target targetname] ... | -alltargets]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild [-project name.xcodeproj] -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -workspace name.xcworkspace -scheme schemename\n           [[-destination destinationspecifier] ...]\n           [-destination-timeout value]\n           [-configuration configurationname]\n           [-sdk [sdkfullpath | sdkname]] [action ...]\n           [buildsetting=value ...] [-userdefault=value ...]\n\nxcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]\n\nxcodebuild -showsdks\n\nxcodebuild -showBuildSettings\n           [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]]\n\nxcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace]\n\nxcodebuild -exportArchive -archivePath xcarchivepath -exportPath\n                destinationpath -exportOptionsPlist path\n\nxcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] ...]\n\nxcodebuild -importLocalizations -project name.xcodeproj -localizationPath path\n</code></pre>\n<p>前三条指令是比较常用的，其中涉及很多参数：</p>\n<ul>\n<li>-project：指定要构建的 project ，当文件夹中有多个<code>.xcodeproj</code>文件时需要指定。</li>\n<li>-target：指定构建哪一个 target 。默认地，若不指定此参数，xcodebuild 构建工程中的第一个 target 。</li>\n<li>-alltargets：构建所有 target 。</li>\n<li>-workspace：如果要构建一个 workspace （例如使用 cocoapods 管理第三方依赖文件），则需要指定 workspace ，当然后缀就是<code>.xcworkspace</code>。</li>\n<li>-scheme：构建 workspace ，还必须指定 scheme ，使用此参数。</li>\n<li>-destination：指定设备，如：<code>&#39;platform=OS X,arch=x86_64&#39;</code>指代当前 Mac 或<code>generic/platform=iOS</code>指定 Generic iOS device 。</li>\n<li>-destination-timeout：搜索指定设备超时时间，默认 30S 。</li>\n<li>-configuration：如果工程中没有添加其他配置，默认就是 Debug 和 Release 这两个版本。没有指定此参数和 scheme 参数，则默认为 Release 版本。</li>\n<li>-arch：指定架构 armv7、armv7s、arm64 等。</li>\n<li>-sdk：指定构建使用的 sdk ，后跟 sdk 的绝对路径或 sdk 名称，可通过<code>xcodebuild -showsdks</code>查看。</li>\n<li>-list：查看工程的 target、configuration、scheme 。</li>\n</ul>\n<p>我们常用<code>xcodebuild</code>来构建项目，得到 .app 文件，但其实，<code>xcodebuild</code>也能打包出我们需要的 .ipa 文件，这就需要了解多以下几个比较重要的参数：</p>\n<ul>\n<li>-exportArchive：archive 后导出，需要<code>-exportFormat</code> ，<code>-archivePath</code> 和<code>-exportPath</code>三个参数</li>\n<li>-exportFormat：指定格式为 pkg ( macOS ) 或 ipa ( iOS ) 的一种</li>\n<li>-archivePath：指定 archive 文件的地址，将此<code>.xcarchive</code>打包成 ipa</li>\n<li>-exportPath：最后输出文件 ipa 所在的<strong>文件夹</strong>。</li>\n<li>-exportOptionsPlist：plist 文件，其中定义了将<code>.xcarchive</code>导出成 ipa 所需要的配置参数。后面会说到。</li>\n</ul>\n<p><code>xcodebuild</code>还能进行各种操作，挑选一些常用的来讲：</p>\n<ul>\n<li>build：构建，默认操作。如果没有指定，则默认为 build ，将会在<code>SYMROOT</code>中生成文件夹<code>[configuration]-iphones</code>的文件夹（ configuration 见上述参数介绍）。其中有项目用到的第三方库的 framework 、<code>.app</code>文件、<code>.dSYM</code>文件。</li>\n<li>archive：对应 Xcode 中的 Archive ，在 build 的基础上还将生成<code>.xcarchive</code>文件。</li>\n<li>clean：对应 Xcode 中的 clean ，删除上次构建过程产生的中间文件。</li>\n</ul>\n<h2 id=\"xcrun\"><a href=\"#xcrun\" class=\"headerlink\" title=\"xcrun\"></a>xcrun</h2><pre><code class=\"shell\">xcrun -sdk iphoneos PackageApplication &quot;./Release-iphoneos/${APP_NAME}.app&quot; -o ~/&quot;${IPANAME}&quot;\n</code></pre>\n<p>xcrun 更多地用来将app文件打包到 ipa 中，得以安装在用户的设备上。其中使用到 <em>PackageApplication</em> 这个工具，命令也相对简单，就不多说了。</p>\n<p>需要注意的是：从 Xcode8.3 开始，<em>PackageApplication</em> 从开发工具中被移除，因此我们用来将.app打包成ipa最常用的<code>xcrun</code>指令也变得不好用了。当然可以从旧版本的 Xcode 中将 <em>PackageApplication</em> 拷贝一份放在新的 Xcode 中，让 <em>PackageApplication</em> 继续发光发热。请见<a href=\"https://stackoverflow.com/questions/43068608/xcrun-error-unable-to-find-utility-packageapplication-not-a-developer-tool\">stackoverflow</a>。</p>\n<p>不过使用<code>xcrun</code>还可能存在一些问题：当解压 ipa 后，你会发现，在 app 文件中，<code>Payload</code>文件夹存在，但是<code>BCSymbolMaps</code>、<code>SwiftSupport</code> 和<code>Symbols</code>却找不到了，这有可能会在提交到 App Store 的时候出现问题。</p>\n<p>但是从 Xcode 中 Export xcarchive 则不会出现这样的问题，说明单纯使用 xcrun 的打包旧命令已经不被建议使用了。</p>\n<h2 id=\"Demonstration🌰\"><a href=\"#Demonstration🌰\" class=\"headerlink\" title=\"Demonstration🌰\"></a>Demonstration🌰</h2><p>笔者在使用脚本打包的时候舍弃了 xcrun ，直接用 xcodebuild 来完成工作，提供一个示例：</p>\n<pre><code class=\"shell\"># 工程名\nAPP_NAME=&quot;KeyX_iOS&quot;\n# info.plist路径\nPROJECT_INFOPLIST_PATH=&quot;./${APP_NAME}/Supporting Files/Info.plist&quot;\n# exportOptions.plist路径\nEXPORT_PLIST=&quot;./KeyXExportOptions.plist&quot;\necho &quot;==============some message==============&quot;\necho &quot;info.plist路径 = ${PROJECT_INFOPLIST_PATH}&quot;\n# 取版本号\nBUNDLE_SHORT_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${PROJECT_INFOPLIST_PATH}&quot;)\necho &quot;版本号 = ${BUNDLE_SHORT_VERSION}&quot;\n# 取build值\nBUNDLE_VERSION=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;${PROJECT_INFOPLIST_PATH}&quot;)\necho &quot;开发版本 = ${BUNDLE_VERSION}&quot;\nDATE=&quot;$(date +%Y%m%d)&quot;\nIPA_NAME=&quot;${APP_NAME}_V${BUNDLE_SHORT_VERSION}.${BUNDLE_VERSION}_${DATE}.ipa&quot;\n# ipa文件路径，保存起来以便后面使用\nIPA_PATH=&quot;$PWD/${IPA_NAME}&quot;\necho &quot;要上传的ipa文件路径 = ${IPA_PATH}&quot;\necho &quot;${IPA_PATH}&quot;&gt;&gt; ipa_path\n# 下面3行是集成有Cocopods的用法\necho &quot;=============pod install===============&quot;\npod install\n\necho &quot;================clean==================&quot;\nxcodebuild \\\n    -workspace &quot;${APP_NAME}.xcworkspace&quot; \\\n    -scheme &quot;${APP_NAME}&quot;  \\\n    -configuration &#39;Release&#39; \\\n    clean\n\necho &quot;===============archive=================&quot;\nxcodebuild \\\n    -workspace &quot;${APP_NAME}.xcworkspace&quot; \\\n    -scheme &quot;${APP_NAME}&quot; \\\n    -sdk iphoneos \\\n    -configuration &#39;Release&#39; \\\n    -archivePath &quot;${APP_NAME}.xcarchive&quot; \\\n    PROVISIONING_PROFILE_SPECIFIER=&quot;PROVISIONING_PROFILE_NAME_OR_ID&quot; \\\n    DEVELOPMENT_TEAM=&quot;TEAMID&quot; \\\n    -allowProvisioningUpdates \\\n    SYMROOT=&#39;$PWD&#39; \\\n    archive\n\n# 将app打包成ipa\necho &quot;================export=================&quot;\nxcodebuild \\\n    -exportArchive \\\n    -archivePath &quot;${APP_NAME}.xcarchive&quot; \\\n    -exportOptionsPlist &quot;${EXPORT_PLIST}&quot; \\\n    -exportPath &quot;$PWD&quot;\n\n# 将ipa的名称修改成我们自定义的名称 IPA_NAME\nmv &quot;${APP_NAME}.ipa&quot; &quot;${IPA_NAME}&quot;\n</code></pre>\n<p>需要注意几点：</p>\n<ol>\n<li>archive 前 clean 是一个比较好的习惯，清除上次构建形成的中间文件。</li>\n<li>archive 时配置了<code>PROVISIONING_PROFILE_SPECIFIER</code>和<code>DEVELOPMENT_TEAM</code>，用于指定 archive 的签名使用的证书，需要使用 development 用的 Provisioning Profile ，不可以用 app store 或 ad-hoc 的。</li>\n<li>第 2 点中那两个配置，如果去掉，则默认读取 xcodeproj 中的配置。此时可以在 Xcode 的<code>Target-&gt;Signing-&gt;Automaticall manage signing</code>打勾由 Xcode 设置开发证书，或自己设置开发用的 Provisioning Profiles 并确保配置无误（ manual signing ）。</li>\n<li>还是第 2 点的配置，在命令中可以配置的命令请见<a href=\"https://help.apple.com/xcode/mac/current/#/itcaec37c2a6?sub=dev186481df2\">这里</a>。</li>\n<li><code>allowProvisioningUpdates</code>是 Xcode9 才引入的，允许<code>xcodebuild</code>自动更新 Provisioning profile 等。</li>\n</ol>\n<h3 id=\"exportOptionsPlist-参数\"><a href=\"#exportOptionsPlist-参数\" class=\"headerlink\" title=\"-exportOptionsPlist 参数\"></a>-exportOptionsPlist 参数</h3><p>ExportOptions.plist 存在很久了，只是一直没有被拿来使用。在 xcodebuild 打包的时候，这个参数指定 ExportOptions.plist 的位置，用来告诉<code>xcodebuild</code>怎么将<code>.xcarchive</code>文件打包。</p>\n<p>下面是笔者所使用的 plist 文件：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/gq8g9.png\" alt=\"\"></p>\n<p>provisioningProfiles 中，key 是 bundleid ， value 是对应的 provisioningProfile 的名称或 ID 。</p>\n<p>有哪些键可以通过<code>xcodebuild -help</code>，然后拉到最下面查看。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l89oh.png\" alt=\"\"></p>\n<p>如果还是觉得创建麻烦，可以先在 Xcode 中手动打包一遍，在 Export 后的文件夹中找到<code>ExportOptions.plist</code>，这就是适用于项目的 plist 文件了。</p>\n<h2 id=\"Troubleshotting\"><a href=\"#Troubleshotting\" class=\"headerlink\" title=\"Troubleshotting\"></a>Troubleshotting</h2><p>编写此章节，是为了记录打包时出现的错误，长期更新：</p>\n<h3 id=\"1-ipatool-json-filepath-XXXXXX-“No-value”\"><a href=\"#1-ipatool-json-filepath-XXXXXX-“No-value”\" class=\"headerlink\" title=\"1.ipatool-json-filepath-XXXXXX “No value”.\"></a>1.ipatool-json-filepath-XXXXXX “No value”.</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m5j01.png\" alt=\"\"></p>\n<p>笔者遇到此问题的时候，是因为 archive 失败，但是路径中还是出现了<code>.xcarchive</code>文件，继续往下 export 的时候就报错了，此时不妨尝试一下，只是 archive 是否有问题？具体原因笔者尚未发现。</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://developer.apple.com/library/content/technotes/tn2339/_index.html\">1.Building from the Command Line with Xcode FAQ</a></p>\n<p><a href=\"http://subathrathanabalan.com/2016/01/07/building-ipa-export-archive/\">2.Using -exportArchive instead of Package Application to export an IPA</a></p>\n<p><a href=\"https://encyclopediaofdaniel.com/blog/xcarchive-to-ipa/\">3.XCArchive to ipa</a></p>\n<p><a href=\"https://help.apple.com/xcode/mac/current/#/dev3a05256b8\">4.Xcode Help</a></p>"},{"title":"使用makefile创建静态库","date":"2017-08-08T14:17:57.000Z","id":"42F1A99632F0B88D","_content":"\n最近工作上需要将 Win 上的一个 C 库移植到 iOS 上以支持业务的开展，修改代码后需要编译成静态库供 iOS 使用，不想每次别人修改完在 Mac 上编译时还要打开 Xcode ，学习了一下makefile ，直接执行 make 命令就可以了。    \n\n<!--more-->\n\n说来惭愧，自己的 C/C++ 水平还没有到达很高的水平，最开始想到的最简单的方式就是创建`Cocoa Touch Static Library`项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    \n\n但是为了让其他同事更快捷地完成工作，学习了如何使用 makefile 来编译静态库。\n\n本文只是皮毛，主要是在此次工作中的一些历程。     \n\n## 静态库特点\n\n> - 静态库对函数库的链接是放在编译时期完成的。\n> - 程序在运行时与函数库再无关系，移植方便。\n> - 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n> - 更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。\n\n留下疑问：是否可以理解为：只需要其他库的头文件？\n\n## makefile\n\nmakefile 本身只是一个文件，用来辅助 make 命令执行时，告诉 make 命令怎么去编译和链接程序。    \n\n那编译和链接的规则是：\n\n> - 如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。\n> - 如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。\n> - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。\n\nGoogle 可以搜索到很多 makefile 的好文章，这里简略介绍一下：\n\n### 基本语句\n\n```\ntarget : prerequisites\n\tcommand\n```\n\n- target : 编译或链接最终得到的目标文件，例如 .o 结尾的中间文件、由 .o 文件链接而成的 Win 下的可执行文件， .o 文件打包而成的静态库文件\n- prerequisites : 依赖，也就是编译成 .o 的 .c 、.cpp、.m 和 .h ，链接成动态库、静态库、可执行文件的 .o\n- command : 命令，即如何将上述的依赖编译或链接成我们要的 target ，需要注意的是， command 前必须要有一个制表符 ( tab ) ，不能是一连串的空格，也不能缺失。\n\n\n\n\n\n#### Phony Target\n\nPHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    \n\n像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行`make clean`，这里的 clean 就是 makefile 中被定义的 Phony Target 。下面例子会说到。    \n\n一个 makefile 只能有一个总的 Target (编译链接得到我们最终需要的文件)，如果需要多个 Target ，可以使用 Phony Target 来实现。当然，上述说到的除编译链接之外的操作用 Phony Target 也是很好的选择。\n\n\n\n### 变量\n\n像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过`${变量}`使用，例如：\n\n```\nDEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n```\n\n\n\n### 文件名及使用\n\n当然，既然叫 makefile ，文件名最好就叫 makefile 啦， Makefile 也是可以的，但是是在 makefile 不存在的时候， make 命令才会去使用。\n\n如果再不喜欢，文件名写成 chris 也可以，只是 make 的时候加上`-f`和文件名就好了~\n\n`make -f chris`\n\n\n\n## 栗子🌰\n\n好啦，说起来简单，但是实际操作却需要些许耐心~\n\n以下是我写的一个简单的 makefile ，用于编译资源文件和打包成静态库，还有一个脚本，结合 makefile ，打包 armv7, armv7s , arm64 , i386 , x86_64 这五个平台的静态库，并使用 lipo 合成为 \" Fat Library \" 。\n\n### makefile\n\n```cmake\nOUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 如果C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \n\t\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libutil.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n\t${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n$(OBJ_D):\n\t${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n\t${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n\t${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libutil.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n\tlibtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libutil.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\t\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n\t${RM} -rf ${OUT_D}\n\nclean:\n\t${RM} -rf ${OBJ_D}\n```\n\n### Shell\n\n```shell\nLIB_NAME=libutil.a\nLIB_OS_NAME=libutil_os.a\nLIB_SIMULATOR_NAME=libutil_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(\"armv7\" \"armv7s\" \"arm64\")\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(\"armv7/libnetca_util.2.5.1_os.a\",...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(\"i386\" \"x86_64\")\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n\tmake -f makefile.ios clean\n\tmake -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_OS_COUNT}; i++))\ndo\n\tarch_make ${ARCH_OS_LIST[i]} \"OS\"\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_SIM_COUNT}; i++))\ndo\n\tarch_make ${ARCH_SIM_LIST[i]} \"Simulator\"\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp *.h ${HEADER_D}/\n\n#LIPO 合成为\"Fat Library\"\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n\n\n```\n\n## 总结\n\n1. 感觉 makefile 还是有必要学会，因为编译和链接可以由自己掌握。\n2. 此次编写 makefile 的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。\n3.  makefile 在 iOS 上的使用方面，最主要的困难还是如何指定 SDK ，毕竟移植到 iOS 的时候，Win 上或 Linux 上的代码并不是都可用，像这次就需要用到 iOS 的 SDK 里 CoreFoundation 的内容去替换一些已有的实现。\n\n\n\n","source":"_posts/使用MakeFile创建静态库.md","raw":"---\ntitle: 使用makefile创建静态库\ndate: 2017-08-08 22:17:57\nid: 42F1A99632F0B88D\ntags: \n- Library\n---\n\n最近工作上需要将 Win 上的一个 C 库移植到 iOS 上以支持业务的开展，修改代码后需要编译成静态库供 iOS 使用，不想每次别人修改完在 Mac 上编译时还要打开 Xcode ，学习了一下makefile ，直接执行 make 命令就可以了。    \n\n<!--more-->\n\n说来惭愧，自己的 C/C++ 水平还没有到达很高的水平，最开始想到的最简单的方式就是创建`Cocoa Touch Static Library`项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    \n\n但是为了让其他同事更快捷地完成工作，学习了如何使用 makefile 来编译静态库。\n\n本文只是皮毛，主要是在此次工作中的一些历程。     \n\n## 静态库特点\n\n> - 静态库对函数库的链接是放在编译时期完成的。\n> - 程序在运行时与函数库再无关系，移植方便。\n> - 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n> - 更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。\n\n留下疑问：是否可以理解为：只需要其他库的头文件？\n\n## makefile\n\nmakefile 本身只是一个文件，用来辅助 make 命令执行时，告诉 make 命令怎么去编译和链接程序。    \n\n那编译和链接的规则是：\n\n> - 如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。\n> - 如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。\n> - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。\n\nGoogle 可以搜索到很多 makefile 的好文章，这里简略介绍一下：\n\n### 基本语句\n\n```\ntarget : prerequisites\n\tcommand\n```\n\n- target : 编译或链接最终得到的目标文件，例如 .o 结尾的中间文件、由 .o 文件链接而成的 Win 下的可执行文件， .o 文件打包而成的静态库文件\n- prerequisites : 依赖，也就是编译成 .o 的 .c 、.cpp、.m 和 .h ，链接成动态库、静态库、可执行文件的 .o\n- command : 命令，即如何将上述的依赖编译或链接成我们要的 target ，需要注意的是， command 前必须要有一个制表符 ( tab ) ，不能是一连串的空格，也不能缺失。\n\n\n\n\n\n#### Phony Target\n\nPHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    \n\n像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行`make clean`，这里的 clean 就是 makefile 中被定义的 Phony Target 。下面例子会说到。    \n\n一个 makefile 只能有一个总的 Target (编译链接得到我们最终需要的文件)，如果需要多个 Target ，可以使用 Phony Target 来实现。当然，上述说到的除编译链接之外的操作用 Phony Target 也是很好的选择。\n\n\n\n### 变量\n\n像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过`${变量}`使用，例如：\n\n```\nDEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n```\n\n\n\n### 文件名及使用\n\n当然，既然叫 makefile ，文件名最好就叫 makefile 啦， Makefile 也是可以的，但是是在 makefile 不存在的时候， make 命令才会去使用。\n\n如果再不喜欢，文件名写成 chris 也可以，只是 make 的时候加上`-f`和文件名就好了~\n\n`make -f chris`\n\n\n\n## 栗子🌰\n\n好啦，说起来简单，但是实际操作却需要些许耐心~\n\n以下是我写的一个简单的 makefile ，用于编译资源文件和打包成静态库，还有一个脚本，结合 makefile ，打包 armv7, armv7s , arm64 , i386 , x86_64 这五个平台的静态库，并使用 lipo 合成为 \" Fat Library \" 。\n\n### makefile\n\n```cmake\nOUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 如果C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \n\t\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libutil.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n\t${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n$(OBJ_D):\n\t${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n\t${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n\t${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libutil.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n\tlibtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libutil.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\t\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n\t${RM} -rf ${OUT_D}\n\nclean:\n\t${RM} -rf ${OBJ_D}\n```\n\n### Shell\n\n```shell\nLIB_NAME=libutil.a\nLIB_OS_NAME=libutil_os.a\nLIB_SIMULATOR_NAME=libutil_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(\"armv7\" \"armv7s\" \"arm64\")\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(\"armv7/libnetca_util.2.5.1_os.a\",...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(\"i386\" \"x86_64\")\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n\tmake -f makefile.ios clean\n\tmake -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_OS_COUNT}; i++))\ndo\n\tarch_make ${ARCH_OS_LIST[i]} \"OS\"\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_SIM_COUNT}; i++))\ndo\n\tarch_make ${ARCH_SIM_LIST[i]} \"Simulator\"\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp *.h ${HEADER_D}/\n\n#LIPO 合成为\"Fat Library\"\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n\n\n```\n\n## 总结\n\n1. 感觉 makefile 还是有必要学会，因为编译和链接可以由自己掌握。\n2. 此次编写 makefile 的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。\n3.  makefile 在 iOS 上的使用方面，最主要的困难还是如何指定 SDK ，毕竟移植到 iOS 的时候，Win 上或 Linux 上的代码并不是都可用，像这次就需要用到 iOS 的 SDK 里 CoreFoundation 的内容去替换一些已有的实现。\n\n\n\n","slug":"使用MakeFile创建静态库","published":1,"updated":"2018-11-06T13:03:37.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6du000equ0xu1xtt318","content":"<p>最近工作上需要将 Win 上的一个 C 库移植到 iOS 上以支持业务的开展，修改代码后需要编译成静态库供 iOS 使用，不想每次别人修改完在 Mac 上编译时还要打开 Xcode ，学习了一下makefile ，直接执行 make 命令就可以了。    </p>\n<a id=\"more\"></a>\n<p>说来惭愧，自己的 C/C++ 水平还没有到达很高的水平，最开始想到的最简单的方式就是创建<code>Cocoa Touch Static Library</code>项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    </p>\n<p>但是为了让其他同事更快捷地完成工作，学习了如何使用 makefile 来编译静态库。</p>\n<p>本文只是皮毛，主要是在此次工作中的一些历程。     </p>\n<h2 id=\"静态库特点\"><a href=\"#静态库特点\" class=\"headerlink\" title=\"静态库特点\"></a>静态库特点</h2><blockquote>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的。</li>\n<li>程序在运行时与函数库再无关系，移植方便。</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n<li>更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。</li>\n</ul>\n</blockquote>\n<p>留下疑问：是否可以理解为：只需要其他库的头文件？</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><p>makefile 本身只是一个文件，用来辅助 make 命令执行时，告诉 make 命令怎么去编译和链接程序。    </p>\n<p>那编译和链接的规则是：</p>\n<blockquote>\n<ul>\n<li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。</li>\n<li>如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。</li>\n<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。</li>\n</ul>\n</blockquote>\n<p>Google 可以搜索到很多 makefile 的好文章，这里简略介绍一下：</p>\n<h3 id=\"基本语句\"><a href=\"#基本语句\" class=\"headerlink\" title=\"基本语句\"></a>基本语句</h3><pre><code>target : prerequisites\n    command\n</code></pre><ul>\n<li>target : 编译或链接最终得到的目标文件，例如 .o 结尾的中间文件、由 .o 文件链接而成的 Win 下的可执行文件， .o 文件打包而成的静态库文件</li>\n<li>prerequisites : 依赖，也就是编译成 .o 的 .c 、.cpp、.m 和 .h ，链接成动态库、静态库、可执行文件的 .o</li>\n<li>command : 命令，即如何将上述的依赖编译或链接成我们要的 target ，需要注意的是， command 前必须要有一个制表符 ( tab ) ，不能是一连串的空格，也不能缺失。</li>\n</ul>\n<h4 id=\"Phony-Target\"><a href=\"#Phony-Target\" class=\"headerlink\" title=\"Phony Target\"></a>Phony Target</h4><p>PHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    </p>\n<p>像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行<code>make clean</code>，这里的 clean 就是 makefile 中被定义的 Phony Target 。下面例子会说到。    </p>\n<p>一个 makefile 只能有一个总的 Target (编译链接得到我们最终需要的文件)，如果需要多个 Target ，可以使用 Phony Target 来实现。当然，上述说到的除编译链接之外的操作用 Phony Target 也是很好的选择。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过<code>${变量}</code>使用，例如：</p>\n<pre><code>DEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n</code></pre><h3 id=\"文件名及使用\"><a href=\"#文件名及使用\" class=\"headerlink\" title=\"文件名及使用\"></a>文件名及使用</h3><p>当然，既然叫 makefile ，文件名最好就叫 makefile 啦， Makefile 也是可以的，但是是在 makefile 不存在的时候， make 命令才会去使用。</p>\n<p>如果再不喜欢，文件名写成 chris 也可以，只是 make 的时候加上<code>-f</code>和文件名就好了~</p>\n<p><code>make -f chris</code></p>\n<h2 id=\"栗子🌰\"><a href=\"#栗子🌰\" class=\"headerlink\" title=\"栗子🌰\"></a>栗子🌰</h2><p>好啦，说起来简单，但是实际操作却需要些许耐心~</p>\n<p>以下是我写的一个简单的 makefile ，用于编译资源文件和打包成静态库，还有一个脚本，结合 makefile ，打包 armv7, armv7s , arm64 , i386 , x86_64 这五个平台的静态库，并使用 lipo 合成为 “ Fat Library “ 。</p>\n<h3 id=\"makefile-1\"><a href=\"#makefile-1\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><pre><code class=\"cmake\">OUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 如果C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \n\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libutil.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n    ${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n$(OBJ_D):\n    ${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n    ${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n    ${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libutil.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n    libtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libutil.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n    ${RM} -rf ${OUT_D}\n\nclean:\n    ${RM} -rf ${OBJ_D}\n</code></pre>\n<h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><pre><code class=\"shell\">LIB_NAME=libutil.a\nLIB_OS_NAME=libutil_os.a\nLIB_SIMULATOR_NAME=libutil_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(&quot;armv7&quot; &quot;armv7s&quot; &quot;arm64&quot;)\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(&quot;armv7/libnetca_util.2.5.1_os.a&quot;,...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(&quot;i386&quot; &quot;x86_64&quot;)\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n    make -f makefile.ios clean\n    make -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_OS_COUNT}; i++))\ndo\n    arch_make ${ARCH_OS_LIST[i]} &quot;OS&quot;\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_SIM_COUNT}; i++))\ndo\n    arch_make ${ARCH_SIM_LIST[i]} &quot;Simulator&quot;\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp *.h ${HEADER_D}/\n\n#LIPO 合成为&quot;Fat Library&quot;\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>感觉 makefile 还是有必要学会，因为编译和链接可以由自己掌握。</li>\n<li>此次编写 makefile 的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。</li>\n<li>makefile 在 iOS 上的使用方面，最主要的困难还是如何指定 SDK ，毕竟移植到 iOS 的时候，Win 上或 Linux 上的代码并不是都可用，像这次就需要用到 iOS 的 SDK 里 CoreFoundation 的内容去替换一些已有的实现。</li>\n</ol>\n","excerpt":"<p>最近工作上需要将 Win 上的一个 C 库移植到 iOS 上以支持业务的开展，修改代码后需要编译成静态库供 iOS 使用，不想每次别人修改完在 Mac 上编译时还要打开 Xcode ，学习了一下makefile ，直接执行 make 命令就可以了。    </p>","more":"<p>说来惭愧，自己的 C/C++ 水平还没有到达很高的水平，最开始想到的最简单的方式就是创建<code>Cocoa Touch Static Library</code>项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    </p>\n<p>但是为了让其他同事更快捷地完成工作，学习了如何使用 makefile 来编译静态库。</p>\n<p>本文只是皮毛，主要是在此次工作中的一些历程。     </p>\n<h2 id=\"静态库特点\"><a href=\"#静态库特点\" class=\"headerlink\" title=\"静态库特点\"></a>静态库特点</h2><blockquote>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的。</li>\n<li>程序在运行时与函数库再无关系，移植方便。</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n<li>更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。</li>\n</ul>\n</blockquote>\n<p>留下疑问：是否可以理解为：只需要其他库的头文件？</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><p>makefile 本身只是一个文件，用来辅助 make 命令执行时，告诉 make 命令怎么去编译和链接程序。    </p>\n<p>那编译和链接的规则是：</p>\n<blockquote>\n<ul>\n<li>如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。</li>\n<li>如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目标程序。</li>\n<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，并链接目标程序。</li>\n</ul>\n</blockquote>\n<p>Google 可以搜索到很多 makefile 的好文章，这里简略介绍一下：</p>\n<h3 id=\"基本语句\"><a href=\"#基本语句\" class=\"headerlink\" title=\"基本语句\"></a>基本语句</h3><pre><code>target : prerequisites\n    command\n</code></pre><ul>\n<li>target : 编译或链接最终得到的目标文件，例如 .o 结尾的中间文件、由 .o 文件链接而成的 Win 下的可执行文件， .o 文件打包而成的静态库文件</li>\n<li>prerequisites : 依赖，也就是编译成 .o 的 .c 、.cpp、.m 和 .h ，链接成动态库、静态库、可执行文件的 .o</li>\n<li>command : 命令，即如何将上述的依赖编译或链接成我们要的 target ，需要注意的是， command 前必须要有一个制表符 ( tab ) ，不能是一连串的空格，也不能缺失。</li>\n</ul>\n<h4 id=\"Phony-Target\"><a href=\"#Phony-Target\" class=\"headerlink\" title=\"Phony Target\"></a>Phony Target</h4><p>PHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    </p>\n<p>像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行<code>make clean</code>，这里的 clean 就是 makefile 中被定义的 Phony Target 。下面例子会说到。    </p>\n<p>一个 makefile 只能有一个总的 Target (编译链接得到我们最终需要的文件)，如果需要多个 Target ，可以使用 Phony Target 来实现。当然，上述说到的除编译链接之外的操作用 Phony Target 也是很好的选择。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过<code>${变量}</code>使用，例如：</p>\n<pre><code>DEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n</code></pre><h3 id=\"文件名及使用\"><a href=\"#文件名及使用\" class=\"headerlink\" title=\"文件名及使用\"></a>文件名及使用</h3><p>当然，既然叫 makefile ，文件名最好就叫 makefile 啦， Makefile 也是可以的，但是是在 makefile 不存在的时候， make 命令才会去使用。</p>\n<p>如果再不喜欢，文件名写成 chris 也可以，只是 make 的时候加上<code>-f</code>和文件名就好了~</p>\n<p><code>make -f chris</code></p>\n<h2 id=\"栗子🌰\"><a href=\"#栗子🌰\" class=\"headerlink\" title=\"栗子🌰\"></a>栗子🌰</h2><p>好啦，说起来简单，但是实际操作却需要些许耐心~</p>\n<p>以下是我写的一个简单的 makefile ，用于编译资源文件和打包成静态库，还有一个脚本，结合 makefile ，打包 armv7, armv7s , arm64 , i386 , x86_64 这五个平台的静态库，并使用 lipo 合成为 “ Fat Library “ 。</p>\n<h3 id=\"makefile-1\"><a href=\"#makefile-1\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><pre><code class=\"cmake\">OUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 如果C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \n\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libutil.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n    ${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n$(OBJ_D):\n    ${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n    ${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n    ${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libutil.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n    libtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libutil.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n    ${RM} -rf ${OUT_D}\n\nclean:\n    ${RM} -rf ${OBJ_D}\n</code></pre>\n<h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><pre><code class=\"shell\">LIB_NAME=libutil.a\nLIB_OS_NAME=libutil_os.a\nLIB_SIMULATOR_NAME=libutil_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(&quot;armv7&quot; &quot;armv7s&quot; &quot;arm64&quot;)\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(&quot;armv7/libnetca_util.2.5.1_os.a&quot;,...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(&quot;i386&quot; &quot;x86_64&quot;)\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n    make -f makefile.ios clean\n    make -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_OS_COUNT}; i++))\ndo\n    arch_make ${ARCH_OS_LIST[i]} &quot;OS&quot;\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_SIM_COUNT}; i++))\ndo\n    arch_make ${ARCH_SIM_LIST[i]} &quot;Simulator&quot;\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp *.h ${HEADER_D}/\n\n#LIPO 合成为&quot;Fat Library&quot;\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>感觉 makefile 还是有必要学会，因为编译和链接可以由自己掌握。</li>\n<li>此次编写 makefile 的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。</li>\n<li>makefile 在 iOS 上的使用方面，最主要的困难还是如何指定 SDK ，毕竟移植到 iOS 的时候，Win 上或 Linux 上的代码并不是都可用，像这次就需要用到 iOS 的 SDK 里 CoreFoundation 的内容去替换一些已有的实现。</li>\n</ol>"},{"title":"对线程的简单理解","date":"2017-03-14T08:57:48.000Z","_content":"\n在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。\n\n<!--more-->\n\n## 什么是线程\n\n老生常谈，但还是先说一下概念：\n\n> *线程*，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  \n\n有两点需要注意：\n\n1. 线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈\n2. 共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。\n\n\n数据是否私有，如下表所示\n\n|     线程私有     |              线程间共享              |\n| :----------: | :-----------------------------: |\n| 局部变量<br>函数参数 | 全局变量<br>堆上的数据<br>函数内的静态变量<br>代码 |\n\n\n## 线程调度\n\n如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。\n\n但更经常地，我们可以看到类似这样的图：\n\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为*线程调度*。\n\n在线程调度中，线程有三种状态：\n\n- 运行：拥有时间片，可以执行代码\n- 就绪：在等待队列中，随时可以被执行\n- 等待：等待 IO 或者因为其他原因被阻塞，等待结束后进入就绪状态\n\n三者的状态切换如下图所示：\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg)\n线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。\n\n轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了 CPU 让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：\n\n- 在我们的编程中，我们可以手动设置优先级，最常见的，如 iOS 中 GCD 的`global queue`:\n\n\n```Objc\n// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n```\n- 操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（ **IO 密集型线程**）通常只占用很少的时间，这种线程比用完时间片的线程（ **CPU 密集型线程**）更受欢迎，在操作系统的调度中优先级更容易被提高。\n- 在调度过程中，还存在*线程饿死( Starvation )* 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。\n\n## 线程安全\n\nQ : 为什么会有线程安全问题？\n\nA : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 `i` 执行 `i++`，线程 A 和线程 B 都各自拥有自己的寄存器，对`i++`这种操作，线程 A 先将`i`的值存放在线程的寄存器中，执行计算后再赋值回去给`i`这个变量，中间如果线程 B 在 A 赋值之前先获取到`i`的值，那么最后赋值的结果肯定不正确。这就是线程不安全。\n\nQ : 怎么保证线程安全？\n\nA : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。\n\n- 原子操作（ Atomic ）\n  原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。\n- 同步与锁\n  同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。\n\n### 锁\n\n同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。\n\n最简单的（关于锁的详细内容，不在本文的讨论范围内）：\n\n```objc\nNSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n```\n\n### 信号量\n\n信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如 GCD 中：\n\n```objc\n// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n```\n\n当信号量`semaphore`小于 0 时，线程会暂停执行，直到`semaphore`重新变成 0 。\n\n### 临界区\n\n临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。\n\n信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用`signal`或`wait`来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：\n\n```objc\n@synchronized(self) {\n\t// 临界区代码\n}\n```\n\n### 可重入( Reentrant )\n\n可重入的概念，适用于函数。\n\n首先了解一下什么是 *函数被重入* ：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。\n\n可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：\n\n```objc\n- (int)sqr:(int) x {\n\treturn x * x;\n}\n```\n\n保证可重入，需要保证以下几个方面：\n\n- 不使用静态或全局非 const 的变量\n- 不返还静态或全局非 const 变量的指针\n- 仅依赖入参\n- 不调用不可重入的函数\n\n## 线程和队列的关系\n\n线程和队列的关系，一直都纠缠不清。\n\n在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。\n\n举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。\n\n串行队列：它是有序的传输带，编号是 SQ ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者 A 拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到 SQ 上，那就要等待A吃完面包了，B 分享的面包才会被消费。此时传输带 SQ 就被暂停了。\n\n并行队列：任务的执行时无需等待前面的任务执行完，编号是 CQ ，同样，我的面包吃不完，放到 CQ 上， A 正在享用，此时 B 也将面包放在 CQ 上，但是 A 无法享用（因为正在享用我的），因此 CQ 就发出警鸣，叫来了消费者 C 来将 B 的面包吃掉，以维持 CQ 的继续运转，当 A 吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。\n\n## 死锁\n\n首先，概念：\n\n> *死锁* 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  \n\n死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。\n\n上述关于*死锁* 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个 iOS 应用开发者，我使用 GCD 来说明一下：\n\n```objc\n// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n```\n\n上述代码必将造成死锁，但是此例只涉及一个线程，那就是 iOS App 的主线程（亦称 UI 线程）。我们知道，在 iOS 中，`main queue`是串行队列，其任务只能由主线程去完成。而`dispatch_sync `会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将`block`放在`main queue`中，等主线程执行完`block`中的代码后才释放主线程，然而主线程已被阻塞，无法执行`main queue`中的`block`，所以造成死锁。\n\n## 总结\n\n本文对线程做了一个简单的描述，在每个 App 都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级 iOS 文章，如有写得不好的地方，请各位斧正。\n\n","source":"_posts/对线程的简单理解.md","raw":"---\ntitle: 对线程的简单理解\ndate: 2017-03-14 16:57:48\ntags: \n- Thread\n---\n\n在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。\n\n<!--more-->\n\n## 什么是线程\n\n老生常谈，但还是先说一下概念：\n\n> *线程*，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  \n\n有两点需要注意：\n\n1. 线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈\n2. 共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。\n\n\n数据是否私有，如下表所示\n\n|     线程私有     |              线程间共享              |\n| :----------: | :-----------------------------: |\n| 局部变量<br>函数参数 | 全局变量<br>堆上的数据<br>函数内的静态变量<br>代码 |\n\n\n## 线程调度\n\n如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。\n\n但更经常地，我们可以看到类似这样的图：\n\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为*线程调度*。\n\n在线程调度中，线程有三种状态：\n\n- 运行：拥有时间片，可以执行代码\n- 就绪：在等待队列中，随时可以被执行\n- 等待：等待 IO 或者因为其他原因被阻塞，等待结束后进入就绪状态\n\n三者的状态切换如下图所示：\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg)\n线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。\n\n轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了 CPU 让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：\n\n- 在我们的编程中，我们可以手动设置优先级，最常见的，如 iOS 中 GCD 的`global queue`:\n\n\n```Objc\n// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n```\n- 操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（ **IO 密集型线程**）通常只占用很少的时间，这种线程比用完时间片的线程（ **CPU 密集型线程**）更受欢迎，在操作系统的调度中优先级更容易被提高。\n- 在调度过程中，还存在*线程饿死( Starvation )* 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。\n\n## 线程安全\n\nQ : 为什么会有线程安全问题？\n\nA : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 `i` 执行 `i++`，线程 A 和线程 B 都各自拥有自己的寄存器，对`i++`这种操作，线程 A 先将`i`的值存放在线程的寄存器中，执行计算后再赋值回去给`i`这个变量，中间如果线程 B 在 A 赋值之前先获取到`i`的值，那么最后赋值的结果肯定不正确。这就是线程不安全。\n\nQ : 怎么保证线程安全？\n\nA : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。\n\n- 原子操作（ Atomic ）\n  原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。\n- 同步与锁\n  同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。\n\n### 锁\n\n同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。\n\n最简单的（关于锁的详细内容，不在本文的讨论范围内）：\n\n```objc\nNSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n```\n\n### 信号量\n\n信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如 GCD 中：\n\n```objc\n// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n```\n\n当信号量`semaphore`小于 0 时，线程会暂停执行，直到`semaphore`重新变成 0 。\n\n### 临界区\n\n临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。\n\n信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用`signal`或`wait`来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：\n\n```objc\n@synchronized(self) {\n\t// 临界区代码\n}\n```\n\n### 可重入( Reentrant )\n\n可重入的概念，适用于函数。\n\n首先了解一下什么是 *函数被重入* ：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。\n\n可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：\n\n```objc\n- (int)sqr:(int) x {\n\treturn x * x;\n}\n```\n\n保证可重入，需要保证以下几个方面：\n\n- 不使用静态或全局非 const 的变量\n- 不返还静态或全局非 const 变量的指针\n- 仅依赖入参\n- 不调用不可重入的函数\n\n## 线程和队列的关系\n\n线程和队列的关系，一直都纠缠不清。\n\n在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。\n\n举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。\n\n串行队列：它是有序的传输带，编号是 SQ ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者 A 拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到 SQ 上，那就要等待A吃完面包了，B 分享的面包才会被消费。此时传输带 SQ 就被暂停了。\n\n并行队列：任务的执行时无需等待前面的任务执行完，编号是 CQ ，同样，我的面包吃不完，放到 CQ 上， A 正在享用，此时 B 也将面包放在 CQ 上，但是 A 无法享用（因为正在享用我的），因此 CQ 就发出警鸣，叫来了消费者 C 来将 B 的面包吃掉，以维持 CQ 的继续运转，当 A 吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。\n\n## 死锁\n\n首先，概念：\n\n> *死锁* 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  \n\n死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。\n\n上述关于*死锁* 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个 iOS 应用开发者，我使用 GCD 来说明一下：\n\n```objc\n// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n```\n\n上述代码必将造成死锁，但是此例只涉及一个线程，那就是 iOS App 的主线程（亦称 UI 线程）。我们知道，在 iOS 中，`main queue`是串行队列，其任务只能由主线程去完成。而`dispatch_sync `会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将`block`放在`main queue`中，等主线程执行完`block`中的代码后才释放主线程，然而主线程已被阻塞，无法执行`main queue`中的`block`，所以造成死锁。\n\n## 总结\n\n本文对线程做了一个简单的描述，在每个 App 都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级 iOS 文章，如有写得不好的地方，请各位斧正。\n\n","slug":"对线程的简单理解","published":1,"updated":"2018-11-06T13:07:36.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dw000gqu0xsjtk4nuw","content":"<p>在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h2><p>老生常谈，但还是先说一下概念：</p>\n<blockquote>\n<p><em>线程</em>，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  </p>\n</blockquote>\n<p>有两点需要注意：</p>\n<ol>\n<li>线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈</li>\n<li>共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。</li>\n</ol>\n<p>数据是否私有，如下表所示</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">线程私有</th>\n<th style=\"text-align:center\">线程间共享</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">局部变量<br>函数参数</td>\n<td style=\"text-align:center\">全局变量<br>堆上的数据<br>函数内的静态变量<br>代码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><p>如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。</p>\n<p>但更经常地，我们可以看到类似这样的图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<p>上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为<em>线程调度</em>。</p>\n<p>在线程调度中，线程有三种状态：</p>\n<ul>\n<li>运行：拥有时间片，可以执行代码</li>\n<li>就绪：在等待队列中，随时可以被执行</li>\n<li>等待：等待 IO 或者因为其他原因被阻塞，等待结束后进入就绪状态</li>\n</ul>\n<p>三者的状态切换如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg\" alt=\"\"><br>线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。</p>\n<p>轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了 CPU 让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：</p>\n<ul>\n<li>在我们的编程中，我们可以手动设置优先级，最常见的，如 iOS 中 GCD 的<code>global queue</code>:</li>\n</ul>\n<pre><code class=\"Objc\">// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n</code></pre>\n<ul>\n<li>操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（ <strong>IO 密集型线程</strong>）通常只占用很少的时间，这种线程比用完时间片的线程（ <strong>CPU 密集型线程</strong>）更受欢迎，在操作系统的调度中优先级更容易被提高。</li>\n<li>在调度过程中，还存在<em>线程饿死( Starvation )</em> 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。</li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><p>Q : 为什么会有线程安全问题？</p>\n<p>A : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 <code>i</code> 执行 <code>i++</code>，线程 A 和线程 B 都各自拥有自己的寄存器，对<code>i++</code>这种操作，线程 A 先将<code>i</code>的值存放在线程的寄存器中，执行计算后再赋值回去给<code>i</code>这个变量，中间如果线程 B 在 A 赋值之前先获取到<code>i</code>的值，那么最后赋值的结果肯定不正确。这就是线程不安全。</p>\n<p>Q : 怎么保证线程安全？</p>\n<p>A : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。</p>\n<ul>\n<li>原子操作（ Atomic ）<br>原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。</li>\n<li>同步与锁<br>同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。</p>\n<p>最简单的（关于锁的详细内容，不在本文的讨论范围内）：</p>\n<pre><code class=\"objc\">NSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n</code></pre>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如 GCD 中：</p>\n<pre><code class=\"objc\">// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n</code></pre>\n<p>当信号量<code>semaphore</code>小于 0 时，线程会暂停执行，直到<code>semaphore</code>重新变成 0 。</p>\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。</p>\n<p>信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用<code>signal</code>或<code>wait</code>来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：</p>\n<pre><code class=\"objc\">@synchronized(self) {\n    // 临界区代码\n}\n</code></pre>\n<h3 id=\"可重入-Reentrant\"><a href=\"#可重入-Reentrant\" class=\"headerlink\" title=\"可重入( Reentrant )\"></a>可重入( Reentrant )</h3><p>可重入的概念，适用于函数。</p>\n<p>首先了解一下什么是 <em>函数被重入</em> ：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。</p>\n<p>可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：</p>\n<pre><code class=\"objc\">- (int)sqr:(int) x {\n    return x * x;\n}\n</code></pre>\n<p>保证可重入，需要保证以下几个方面：</p>\n<ul>\n<li>不使用静态或全局非 const 的变量</li>\n<li>不返还静态或全局非 const 变量的指针</li>\n<li>仅依赖入参</li>\n<li>不调用不可重入的函数</li>\n</ul>\n<h2 id=\"线程和队列的关系\"><a href=\"#线程和队列的关系\" class=\"headerlink\" title=\"线程和队列的关系\"></a>线程和队列的关系</h2><p>线程和队列的关系，一直都纠缠不清。</p>\n<p>在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。</p>\n<p>举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。</p>\n<p>串行队列：它是有序的传输带，编号是 SQ ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者 A 拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到 SQ 上，那就要等待A吃完面包了，B 分享的面包才会被消费。此时传输带 SQ 就被暂停了。</p>\n<p>并行队列：任务的执行时无需等待前面的任务执行完，编号是 CQ ，同样，我的面包吃不完，放到 CQ 上， A 正在享用，此时 B 也将面包放在 CQ 上，但是 A 无法享用（因为正在享用我的），因此 CQ 就发出警鸣，叫来了消费者 C 来将 B 的面包吃掉，以维持 CQ 的继续运转，当 A 吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>首先，概念：</p>\n<blockquote>\n<p><em>死锁</em> 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  </p>\n</blockquote>\n<p>死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。</p>\n<p>上述关于<em>死锁</em> 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个 iOS 应用开发者，我使用 GCD 来说明一下：</p>\n<pre><code class=\"objc\">// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n</code></pre>\n<p>上述代码必将造成死锁，但是此例只涉及一个线程，那就是 iOS App 的主线程（亦称 UI 线程）。我们知道，在 iOS 中，<code>main queue</code>是串行队列，其任务只能由主线程去完成。而<code>dispatch_sync</code>会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将<code>block</code>放在<code>main queue</code>中，等主线程执行完<code>block</code>中的代码后才释放主线程，然而主线程已被阻塞，无法执行<code>main queue</code>中的<code>block</code>，所以造成死锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文对线程做了一个简单的描述，在每个 App 都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级 iOS 文章，如有写得不好的地方，请各位斧正。</p>\n","excerpt":"<p>在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。</p>","more":"<h2 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h2><p>老生常谈，但还是先说一下概念：</p>\n<blockquote>\n<p><em>线程</em>，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  </p>\n</blockquote>\n<p>有两点需要注意：</p>\n<ol>\n<li>线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈</li>\n<li>共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。</li>\n</ol>\n<p>数据是否私有，如下表所示</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">线程私有</th>\n<th style=\"text-align:center\">线程间共享</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">局部变量<br>函数参数</td>\n<td style=\"text-align:center\">全局变量<br>堆上的数据<br>函数内的静态变量<br>代码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><p>如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。</p>\n<p>但更经常地，我们可以看到类似这样的图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<p>上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为<em>线程调度</em>。</p>\n<p>在线程调度中，线程有三种状态：</p>\n<ul>\n<li>运行：拥有时间片，可以执行代码</li>\n<li>就绪：在等待队列中，随时可以被执行</li>\n<li>等待：等待 IO 或者因为其他原因被阻塞，等待结束后进入就绪状态</li>\n</ul>\n<p>三者的状态切换如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg\" alt=\"\"><br>线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。</p>\n<p>轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了 CPU 让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：</p>\n<ul>\n<li>在我们的编程中，我们可以手动设置优先级，最常见的，如 iOS 中 GCD 的<code>global queue</code>:</li>\n</ul>\n<pre><code class=\"Objc\">// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n</code></pre>\n<ul>\n<li>操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（ <strong>IO 密集型线程</strong>）通常只占用很少的时间，这种线程比用完时间片的线程（ <strong>CPU 密集型线程</strong>）更受欢迎，在操作系统的调度中优先级更容易被提高。</li>\n<li>在调度过程中，还存在<em>线程饿死( Starvation )</em> 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。</li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><p>Q : 为什么会有线程安全问题？</p>\n<p>A : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 <code>i</code> 执行 <code>i++</code>，线程 A 和线程 B 都各自拥有自己的寄存器，对<code>i++</code>这种操作，线程 A 先将<code>i</code>的值存放在线程的寄存器中，执行计算后再赋值回去给<code>i</code>这个变量，中间如果线程 B 在 A 赋值之前先获取到<code>i</code>的值，那么最后赋值的结果肯定不正确。这就是线程不安全。</p>\n<p>Q : 怎么保证线程安全？</p>\n<p>A : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。</p>\n<ul>\n<li>原子操作（ Atomic ）<br>原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。</li>\n<li>同步与锁<br>同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。</p>\n<p>最简单的（关于锁的详细内容，不在本文的讨论范围内）：</p>\n<pre><code class=\"objc\">NSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n</code></pre>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如 GCD 中：</p>\n<pre><code class=\"objc\">// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n</code></pre>\n<p>当信号量<code>semaphore</code>小于 0 时，线程会暂停执行，直到<code>semaphore</code>重新变成 0 。</p>\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。</p>\n<p>信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用<code>signal</code>或<code>wait</code>来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：</p>\n<pre><code class=\"objc\">@synchronized(self) {\n    // 临界区代码\n}\n</code></pre>\n<h3 id=\"可重入-Reentrant\"><a href=\"#可重入-Reentrant\" class=\"headerlink\" title=\"可重入( Reentrant )\"></a>可重入( Reentrant )</h3><p>可重入的概念，适用于函数。</p>\n<p>首先了解一下什么是 <em>函数被重入</em> ：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。</p>\n<p>可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：</p>\n<pre><code class=\"objc\">- (int)sqr:(int) x {\n    return x * x;\n}\n</code></pre>\n<p>保证可重入，需要保证以下几个方面：</p>\n<ul>\n<li>不使用静态或全局非 const 的变量</li>\n<li>不返还静态或全局非 const 变量的指针</li>\n<li>仅依赖入参</li>\n<li>不调用不可重入的函数</li>\n</ul>\n<h2 id=\"线程和队列的关系\"><a href=\"#线程和队列的关系\" class=\"headerlink\" title=\"线程和队列的关系\"></a>线程和队列的关系</h2><p>线程和队列的关系，一直都纠缠不清。</p>\n<p>在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。</p>\n<p>举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。</p>\n<p>串行队列：它是有序的传输带，编号是 SQ ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者 A 拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到 SQ 上，那就要等待A吃完面包了，B 分享的面包才会被消费。此时传输带 SQ 就被暂停了。</p>\n<p>并行队列：任务的执行时无需等待前面的任务执行完，编号是 CQ ，同样，我的面包吃不完，放到 CQ 上， A 正在享用，此时 B 也将面包放在 CQ 上，但是 A 无法享用（因为正在享用我的），因此 CQ 就发出警鸣，叫来了消费者 C 来将 B 的面包吃掉，以维持 CQ 的继续运转，当 A 吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>首先，概念：</p>\n<blockquote>\n<p><em>死锁</em> 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  </p>\n</blockquote>\n<p>死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。</p>\n<p>上述关于<em>死锁</em> 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个 iOS 应用开发者，我使用 GCD 来说明一下：</p>\n<pre><code class=\"objc\">// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n</code></pre>\n<p>上述代码必将造成死锁，但是此例只涉及一个线程，那就是 iOS App 的主线程（亦称 UI 线程）。我们知道，在 iOS 中，<code>main queue</code>是串行队列，其任务只能由主线程去完成。而<code>dispatch_sync</code>会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将<code>block</code>放在<code>main queue</code>中，等主线程执行完<code>block</code>中的代码后才释放主线程，然而主线程已被阻塞，无法执行<code>main queue</code>中的<code>block</code>，所以造成死锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文对线程做了一个简单的描述，在每个 App 都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级 iOS 文章，如有写得不好的地方，请各位斧正。</p>"},{"title":"我有烦恼，你有答案","date":"2017-02-19T13:01:52.000Z","typora-copy-images-to":"ipic","_content":"\n被友人种草东野圭吾，拾取碎片时间，拜读了这本书。    \n怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。\n\n<!--more-->\n\n![jyzhd_bg](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png)\n\n正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。\n\n> 这里不只卖日常生活用品\n>\n> 还提供消烦解忧的谘询\n>\n> 困惑不安的你，纠结不安的你\n>\n> 欢迎来信讨论心中的问题\n\n小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。\n\n小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。\n\n小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。\n\n小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。\n\n时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。\n\n在终篇还是没有点明时空错乱的原因，但是这已经不重要了。\n\n最后你会发现：你的赞叹，你的感动，都是东野的本事...\n\n\n\n以上\n\n写于读完《解忧杂货店》的13小时后，广州，晴\n","source":"_posts/我有烦恼，你有答案.md","raw":"---\ntitle: 我有烦恼，你有答案\ndate: 2017-02-19 21:01:52\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n\n被友人种草东野圭吾，拾取碎片时间，拜读了这本书。    \n怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。\n\n<!--more-->\n\n![jyzhd_bg](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png)\n\n正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。\n\n> 这里不只卖日常生活用品\n>\n> 还提供消烦解忧的谘询\n>\n> 困惑不安的你，纠结不安的你\n>\n> 欢迎来信讨论心中的问题\n\n小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。\n\n小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。\n\n小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。\n\n小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。\n\n时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。\n\n在终篇还是没有点明时空错乱的原因，但是这已经不重要了。\n\n最后你会发现：你的赞叹，你的感动，都是东野的本事...\n\n\n\n以上\n\n写于读完《解忧杂货店》的13小时后，广州，晴\n","slug":"我有烦恼，你有答案","published":1,"updated":"2018-03-07T08:06:17.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dx000iqu0x56e77fqw","content":"<p>被友人种草东野圭吾，拾取碎片时间，拜读了这本书。<br>怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png\" alt=\"jyzhd_bg\"></p>\n<p>正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。</p>\n<blockquote>\n<p>这里不只卖日常生活用品</p>\n<p>还提供消烦解忧的谘询</p>\n<p>困惑不安的你，纠结不安的你</p>\n<p>欢迎来信讨论心中的问题</p>\n</blockquote>\n<p>小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。</p>\n<p>小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。</p>\n<p>小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。</p>\n<p>小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。</p>\n<p>时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。</p>\n<p>在终篇还是没有点明时空错乱的原因，但是这已经不重要了。</p>\n<p>最后你会发现：你的赞叹，你的感动，都是东野的本事…</p>\n<p>以上</p>\n<p>写于读完《解忧杂货店》的13小时后，广州，晴</p>\n","excerpt":"<p>被友人种草东野圭吾，拾取碎片时间，拜读了这本书。<br>怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png\" alt=\"jyzhd_bg\"></p>\n<p>正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。</p>\n<blockquote>\n<p>这里不只卖日常生活用品</p>\n<p>还提供消烦解忧的谘询</p>\n<p>困惑不安的你，纠结不安的你</p>\n<p>欢迎来信讨论心中的问题</p>\n</blockquote>\n<p>小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。</p>\n<p>小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。</p>\n<p>小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。</p>\n<p>小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。</p>\n<p>时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。</p>\n<p>在终篇还是没有点明时空错乱的原因，但是这已经不重要了。</p>\n<p>最后你会发现：你的赞叹，你的感动，都是东野的本事…</p>\n<p>以上</p>\n<p>写于读完《解忧杂货店》的13小时后，广州，晴</p>"},{"title":"类方法的Block不会内存泄漏....吗？！","date":"2016-07-17T11:57:39.000Z","typora-copy-images-to":"ipic","_content":"\nBlock在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：    \n在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    \n\n<!--more-->\n　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。    \n　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。    \n　　\n　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！    \n　　**不是。**    \n　　**不是。**    \n　　**不是。**    \n\n## 举个栗子\n\n　　平常使用UIView的Animation之时，例如`[UIView animateWithDuration:animations:];`使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于`[UIView animateWithDuration: animations: completion:];`除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     \n\n\n``` objectivec\n- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];\t\t// 递归调用，再次执行此函数\n    }];\n}\n```\n\n　　别告诉我你没这样用过，科科。    \n\n　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    \n\n　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    \n\n1. 多次创建QRCodeScanner并销毁：\n   ![block_self](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg)    \n   QRCodeScanner被销毁后：\n   ![block_self2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg)     \n\n\n2. 将上述代码的self改成weakSelf，再来看看Instruments：\n   ![block_weakSelf](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg)     \n   QRCodeScanner被销毁后：\n   ![block_weakSelf2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg)     \n\n\n　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了`[self startAnimation];`因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(\n\n　　此文有点晦涩，附上[DEMO地址](<https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo>)\n\n\n## 总结\n\n1. 关于Block的内存泄漏不只是循环引用会引起。\n2. 不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上\\_\\_weak。你说，在Block被调用的时候self被释放了怎么办？！去看看\\_\\_strong的资料吧。\n3. ~~很多iOS的类方法传入的Block是\\_NSConcreteStackBlock，可见\\_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)~~确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：\n   1.手动调用copy    \n   2.Block是函数的返回值    \n   3.Block被强引用，Block被赋值给__strong或者id类型    \n   4.调用系统API入参中含有usingBlcok的方法    \n   系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。\n4. 关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题[Objective-C Blocks Quiz](http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/)\n\n","source":"_posts/类方法Block内存泄漏.md","raw":"---\ntitle: 类方法的Block不会内存泄漏....吗？！\ndate: 2016-7-17 19:57:39\ntags: \n- Block\ntypora-copy-images-to: ipic\n---\n\nBlock在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：    \n在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    \n\n<!--more-->\n　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。    \n　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。    \n　　\n　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！    \n　　**不是。**    \n　　**不是。**    \n　　**不是。**    \n\n## 举个栗子\n\n　　平常使用UIView的Animation之时，例如`[UIView animateWithDuration:animations:];`使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于`[UIView animateWithDuration: animations: completion:];`除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     \n\n\n``` objectivec\n- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];\t\t// 递归调用，再次执行此函数\n    }];\n}\n```\n\n　　别告诉我你没这样用过，科科。    \n\n　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    \n\n　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    \n\n1. 多次创建QRCodeScanner并销毁：\n   ![block_self](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg)    \n   QRCodeScanner被销毁后：\n   ![block_self2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg)     \n\n\n2. 将上述代码的self改成weakSelf，再来看看Instruments：\n   ![block_weakSelf](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg)     \n   QRCodeScanner被销毁后：\n   ![block_weakSelf2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg)     \n\n\n　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了`[self startAnimation];`因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(\n\n　　此文有点晦涩，附上[DEMO地址](<https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo>)\n\n\n## 总结\n\n1. 关于Block的内存泄漏不只是循环引用会引起。\n2. 不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上\\_\\_weak。你说，在Block被调用的时候self被释放了怎么办？！去看看\\_\\_strong的资料吧。\n3. ~~很多iOS的类方法传入的Block是\\_NSConcreteStackBlock，可见\\_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)~~确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：\n   1.手动调用copy    \n   2.Block是函数的返回值    \n   3.Block被强引用，Block被赋值给__strong或者id类型    \n   4.调用系统API入参中含有usingBlcok的方法    \n   系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。\n4. 关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题[Objective-C Blocks Quiz](http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/)\n\n","slug":"类方法Block内存泄漏","published":1,"updated":"2018-11-09T07:16:29.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dy000kqu0x82swjzfm","content":"<p>Block在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：<br>在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    </p>\n<a id=\"more\"></a>\n<p>　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。<br>　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。<br>　　<br>　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！<br>　　<strong>不是。</strong><br>　　<strong>不是。</strong><br>　　<strong>不是。</strong>    </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>　　平常使用UIView的Animation之时，例如<code>[UIView animateWithDuration:animations:];</code>使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于<code>[UIView animateWithDuration: animations: completion:];</code>除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     </p>\n<pre><code class=\"objectivec\">- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];        // 递归调用，再次执行此函数\n    }];\n}\n</code></pre>\n<p>　　别告诉我你没这样用过，科科。    </p>\n<p>　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    </p>\n<p>　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    </p>\n<ol>\n<li>多次创建QRCodeScanner并销毁：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg\" alt=\"block_self\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg\" alt=\"block_self2\">     </li>\n</ol>\n<ol>\n<li>将上述代码的self改成weakSelf，再来看看Instruments：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg\" alt=\"block_weakSelf\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg\" alt=\"block_weakSelf2\">     </li>\n</ol>\n<p>　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了<code>[self startAnimation];</code>因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(</p>\n<p>　　此文有点晦涩，附上<a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo\" target=\"_blank\" rel=\"external\">DEMO地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>关于Block的内存泄漏不只是循环引用会引起。</li>\n<li>不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上__weak。你说，在Block被调用的时候self被释放了怎么办？！去看看__strong的资料吧。</li>\n<li><del>很多iOS的类方法传入的Block是_NSConcreteStackBlock，可见_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)</del>确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：<br>1.手动调用copy<br>2.Block是函数的返回值<br>3.Block被强引用，Block被赋值给__strong或者id类型<br>4.调用系统API入参中含有usingBlcok的方法<br>系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。</li>\n<li>关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题<a href=\"http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/\" target=\"_blank\" rel=\"external\">Objective-C Blocks Quiz</a></li>\n</ol>\n","excerpt":"<p>Block在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：<br>在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    </p>","more":"<p>　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。<br>　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。<br>　　<br>　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！<br>　　<strong>不是。</strong><br>　　<strong>不是。</strong><br>　　<strong>不是。</strong>    </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>　　平常使用UIView的Animation之时，例如<code>[UIView animateWithDuration:animations:];</code>使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于<code>[UIView animateWithDuration: animations: completion:];</code>除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     </p>\n<pre><code class=\"objectivec\">- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];        // 递归调用，再次执行此函数\n    }];\n}\n</code></pre>\n<p>　　别告诉我你没这样用过，科科。    </p>\n<p>　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    </p>\n<p>　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    </p>\n<ol>\n<li>多次创建QRCodeScanner并销毁：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg\" alt=\"block_self\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg\" alt=\"block_self2\">     </li>\n</ol>\n<ol>\n<li>将上述代码的self改成weakSelf，再来看看Instruments：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg\" alt=\"block_weakSelf\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg\" alt=\"block_weakSelf2\">     </li>\n</ol>\n<p>　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了<code>[self startAnimation];</code>因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(</p>\n<p>　　此文有点晦涩，附上<a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo\">DEMO地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>关于Block的内存泄漏不只是循环引用会引起。</li>\n<li>不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上__weak。你说，在Block被调用的时候self被释放了怎么办？！去看看__strong的资料吧。</li>\n<li><del>很多iOS的类方法传入的Block是_NSConcreteStackBlock，可见_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)</del>确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：<br>1.手动调用copy<br>2.Block是函数的返回值<br>3.Block被强引用，Block被赋值给__strong或者id类型<br>4.调用系统API入参中含有usingBlcok的方法<br>系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。</li>\n<li>关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题<a href=\"http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/\">Objective-C Blocks Quiz</a></li>\n</ol>"},{"title":"简简单单说说PKI On iOS","date":"2016-04-09T12:16:05.000Z","typora-copy-images-to":"ipic","_content":"\n\nHacker,问你惊未Σ( ° △ °|||)︴\n\n<!--more-->\n\n![Crypto_Sherlock](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg) \n\n\n看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··   \n​    \n今天来聊聊阿澤君的故事，顺便谈谈\n\n1. CommonCryto中关于DES、AES的部分内容\n2. iOS的Security框架里关于RSA加密的部分内容....\n\n阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    \n\n![focusOnCom](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg)    \n\n很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。\n\n![bucuowo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg)\n\n\n# 对称加密    \n\n采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。\n\n## DES\nDES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    \n\n![Crypto_DES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg)\n\n### 3DES\n\n3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：  \n3DES加密过程为：C=Ek3(Dk2(Ek1(P)))    \n3DES解密过程为：P=Dk1(EK2(Dk3(C)))    \n若**Ek1 == Ek2 == Ek3**，就是简单的DES了。\n\n## AES\n![Crypto_AES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png)    \n图片来自网络，若有侵犯到权利之处，请告知，谢谢~    \n\nAES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。    \n算法详细已经有其他人写了，我就不再造轮子了。[密码算法详解——AES](http://www.blogfshare.com/aes-rijndael.html)    \n还有算法及解密算法的[模式介绍](http://blog.csdn.net/searchsun/article/details/2516191)，可以了解了解~    \n\n## RC4\n\n不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。\n\n## CommonCrypto\n\n对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    \n\n### CommonCrypto的一些主要的结构体\n\n1. CCOperation：定义操作：加密或解密\n\n``` \nenum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n```\n\n2. CCAlgorithm：加解密算法，很明显就不详细说明了。\n\n``` objc\nenum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n```\n\n3. CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到\n\n``` objc\nenum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n```\n\n4. KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度\n\n``` objc\nenum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n```\n\n### 通过代码实现\n\n#### 导入CommonCrypto的头文件。\n\n``` objc\n#import <CommonCrypto/CommonCrypto.h>\n```\n\n#### symCrypt\n\n``` objc\n/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@\"[ERROR] failed to encrypt|CCCryptoStatus: %d\", *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n```\n\n1. 根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength\n2. 加密后的数据总小于等于数据长度加上block的大小\n3. 申请bufferSize的空间以保存加密或解密后的数据\n4. 调用CCCrypt函数实现加解密。\n``` objc\nCCCryptorStatus CCCrypt(\n    CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n    CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n    const void *key,        /* 密钥 */\n    size_t keyLength,       /* 密钥长度 */\n    const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n    const void *dataIn,     /* 要加密或解密的数据 */\n    size_t dataInLength,    /* 数据长度 */\n    void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n    size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n    size_t *dataOutMoved    /* 结果所占的长度 */\n    )    \n    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n```\n5. 若成功，则将(void *)类型的数据封装到NSData中。\n6. 释放申请的buffer内存\n7. 返回。\n\n#### fixKeyLength\n\n``` objc\n/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength < kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength < kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n```\n\n#### blockSizeByAlgorithm\n\n``` objc \n/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n```\n\n上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：\n　　DESCipherActor.h\n　　``` objc\n​    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n​    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n　　```\n　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传[Github](https://github.com/objchris/PKIDemo)\n\n\n　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！    \n　　What the ****！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        \n\n![desk](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg)    \n\n　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决...\n\n\n# 非对称加密\n\n对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n如甲乙双方需要加密通信：\n\n1. 乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。\n2. 得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。\n3. 乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。\n\n　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。\n　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。\n　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）\n\n![yaoMing](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png)\n\n## RSA\n\n### 算法原理\n\n1. 选取两个质数p和q, 计算`n = p * q` 。p和q要尽量大\n2. 根据质数`φ(p)=p-1`和欧拉方程满足乘法结合率的规律求出φ(n),即`φ(n)=(p-1)(q-1)`\n3. 选取质数e作为公钥指数, e的范围`1<e<φ(n)`,且 e 与 φ(n) 互质\n4. 出e对φ(n)的模反元素d，求解公式：`ed ≡ 1 (mod φ(n))`即可得出\n   这样计算后(n,e)是公钥，(n,d)是私钥。\n>公钥加密公式    \n>m^e ≡ c (mod n) 即 c = m^e mod n     \n>私钥解密公式    \n>c^d ≡ m (mod n) 即 m = c^d mod n    \n\nRSA加密常用的填充方式有下面3种：    \n\n1. RSA_PKCS1_PADDING 填充模式，最常用的模式    \n   输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n   根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     \n2. RSA_PKCS1_OAEP_PADDING    \n   输入：RSA_size(rsa) – 41    \n   输出：和modulus一样长    \n3. for RSA_NO_PADDING 不填充    \n   输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n\n特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：    \n[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)\n\n### iOS Security.framework\n\n#### encryptWithPublicKey\n\n``` objc\n- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@\"dataLength: %zu\", dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) < dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) < toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n```\n\n1. 根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）\n2. 创建MutableData用以下面操作添加Data\n3. 判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。\n4. while循环多次操作\n5. 使用SecKeyEncrypt进行加解密\n``` objc\nOSStatus SecKeyEncrypt(\n    SecKeyRef           key,                //加解密使用的密钥\n    SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n    const uint8_t       *plainText,          //明文\n    size_t              plainTextLen,        //明文长度\n    uint8_t             *cipherText,        //返回的密文\n    size_t              *cipherTextLen)     //返回的密文长度\n    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n```\n6. 将已经加解密过的数据剔除\n7. 往MutableData中添加数据\n8. 计算总的BufferSize，这里只是做个统计\n9. 将得到的数据进行Base64转码\n10. 记得释放cipherBuffer\n\n\n#### decryptWithPrivateKey\n\n``` objc \n- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer < cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer < toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n```\n\n解密和加密的方式基本一样，此处不多加赘述。\n[Demo](<https://github.com/objchris/ChrisDerDemos/tree/master/PKIDemo>)\n\n\n**Hacker君，问你惊未，哈哈哈哈哈。**    \n非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    \n\n![hahahahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)    \n从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　\n\n题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。    \n更多的算法，eg：数字摘要、数字签名、口令认证等等都在[Github](https://github.com/objchris/PKIDemo)上了，有兴趣请移步。     \n关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！\n","source":"_posts/简简单单说说PKIOniOS.md","raw":"---\ntitle: 简简单单说说PKI On iOS\ndate: 2016-04-09 20:16:05\ntags: \n- Security\ntypora-copy-images-to: ipic\n---\n\n\nHacker,问你惊未Σ( ° △ °|||)︴\n\n<!--more-->\n\n![Crypto_Sherlock](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg) \n\n\n看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··   \n​    \n今天来聊聊阿澤君的故事，顺便谈谈\n\n1. CommonCryto中关于DES、AES的部分内容\n2. iOS的Security框架里关于RSA加密的部分内容....\n\n阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    \n\n![focusOnCom](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg)    \n\n很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。\n\n![bucuowo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg)\n\n\n# 对称加密    \n\n采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。\n\n## DES\nDES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    \n\n![Crypto_DES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg)\n\n### 3DES\n\n3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：  \n3DES加密过程为：C=Ek3(Dk2(Ek1(P)))    \n3DES解密过程为：P=Dk1(EK2(Dk3(C)))    \n若**Ek1 == Ek2 == Ek3**，就是简单的DES了。\n\n## AES\n![Crypto_AES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png)    \n图片来自网络，若有侵犯到权利之处，请告知，谢谢~    \n\nAES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。    \n算法详细已经有其他人写了，我就不再造轮子了。[密码算法详解——AES](http://www.blogfshare.com/aes-rijndael.html)    \n还有算法及解密算法的[模式介绍](http://blog.csdn.net/searchsun/article/details/2516191)，可以了解了解~    \n\n## RC4\n\n不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。\n\n## CommonCrypto\n\n对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    \n\n### CommonCrypto的一些主要的结构体\n\n1. CCOperation：定义操作：加密或解密\n\n``` \nenum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n```\n\n2. CCAlgorithm：加解密算法，很明显就不详细说明了。\n\n``` objc\nenum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n```\n\n3. CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到\n\n``` objc\nenum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n```\n\n4. KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度\n\n``` objc\nenum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n```\n\n### 通过代码实现\n\n#### 导入CommonCrypto的头文件。\n\n``` objc\n#import <CommonCrypto/CommonCrypto.h>\n```\n\n#### symCrypt\n\n``` objc\n/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@\"[ERROR] failed to encrypt|CCCryptoStatus: %d\", *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n```\n\n1. 根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength\n2. 加密后的数据总小于等于数据长度加上block的大小\n3. 申请bufferSize的空间以保存加密或解密后的数据\n4. 调用CCCrypt函数实现加解密。\n``` objc\nCCCryptorStatus CCCrypt(\n    CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n    CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n    const void *key,        /* 密钥 */\n    size_t keyLength,       /* 密钥长度 */\n    const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n    const void *dataIn,     /* 要加密或解密的数据 */\n    size_t dataInLength,    /* 数据长度 */\n    void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n    size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n    size_t *dataOutMoved    /* 结果所占的长度 */\n    )    \n    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n```\n5. 若成功，则将(void *)类型的数据封装到NSData中。\n6. 释放申请的buffer内存\n7. 返回。\n\n#### fixKeyLength\n\n``` objc\n/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength < kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength < kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n```\n\n#### blockSizeByAlgorithm\n\n``` objc \n/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n```\n\n上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：\n　　DESCipherActor.h\n　　``` objc\n​    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n​    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n　　```\n　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传[Github](https://github.com/objchris/PKIDemo)\n\n\n　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！    \n　　What the ****！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        \n\n![desk](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg)    \n\n　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决...\n\n\n# 非对称加密\n\n对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n如甲乙双方需要加密通信：\n\n1. 乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。\n2. 得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。\n3. 乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。\n\n　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。\n　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。\n　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）\n\n![yaoMing](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png)\n\n## RSA\n\n### 算法原理\n\n1. 选取两个质数p和q, 计算`n = p * q` 。p和q要尽量大\n2. 根据质数`φ(p)=p-1`和欧拉方程满足乘法结合率的规律求出φ(n),即`φ(n)=(p-1)(q-1)`\n3. 选取质数e作为公钥指数, e的范围`1<e<φ(n)`,且 e 与 φ(n) 互质\n4. 出e对φ(n)的模反元素d，求解公式：`ed ≡ 1 (mod φ(n))`即可得出\n   这样计算后(n,e)是公钥，(n,d)是私钥。\n>公钥加密公式    \n>m^e ≡ c (mod n) 即 c = m^e mod n     \n>私钥解密公式    \n>c^d ≡ m (mod n) 即 m = c^d mod n    \n\nRSA加密常用的填充方式有下面3种：    \n\n1. RSA_PKCS1_PADDING 填充模式，最常用的模式    \n   输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n   根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     \n2. RSA_PKCS1_OAEP_PADDING    \n   输入：RSA_size(rsa) – 41    \n   输出：和modulus一样长    \n3. for RSA_NO_PADDING 不填充    \n   输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n\n特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：    \n[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)\n\n### iOS Security.framework\n\n#### encryptWithPublicKey\n\n``` objc\n- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@\"dataLength: %zu\", dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) < dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) < toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n```\n\n1. 根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）\n2. 创建MutableData用以下面操作添加Data\n3. 判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。\n4. while循环多次操作\n5. 使用SecKeyEncrypt进行加解密\n``` objc\nOSStatus SecKeyEncrypt(\n    SecKeyRef           key,                //加解密使用的密钥\n    SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n    const uint8_t       *plainText,          //明文\n    size_t              plainTextLen,        //明文长度\n    uint8_t             *cipherText,        //返回的密文\n    size_t              *cipherTextLen)     //返回的密文长度\n    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n```\n6. 将已经加解密过的数据剔除\n7. 往MutableData中添加数据\n8. 计算总的BufferSize，这里只是做个统计\n9. 将得到的数据进行Base64转码\n10. 记得释放cipherBuffer\n\n\n#### decryptWithPrivateKey\n\n``` objc \n- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer < cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer < toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n```\n\n解密和加密的方式基本一样，此处不多加赘述。\n[Demo](<https://github.com/objchris/ChrisDerDemos/tree/master/PKIDemo>)\n\n\n**Hacker君，问你惊未，哈哈哈哈哈。**    \n非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    \n\n![hahahahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)    \n从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　\n\n题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。    \n更多的算法，eg：数字摘要、数字签名、口令认证等等都在[Github](https://github.com/objchris/PKIDemo)上了，有兴趣请移步。     \n关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！\n","slug":"简简单单说说PKIOniOS","published":1,"updated":"2018-11-09T07:16:07.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6dz000mqu0xps5f8sgk","content":"<p>Hacker,问你惊未Σ( ° △ °|||)︴</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg\" alt=\"Crypto_Sherlock\"> </p>\n<p>看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··<br>​<br>今天来聊聊阿澤君的故事，顺便谈谈</p>\n<ol>\n<li>CommonCryto中关于DES、AES的部分内容</li>\n<li>iOS的Security框架里关于RSA加密的部分内容….</li>\n</ol>\n<p>阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg\" alt=\"focusOnCom\">    </p>\n<p>很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg\" alt=\"bucuowo\"></p>\n<h1 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h1><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。</p>\n<h2 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h2><p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg\" alt=\"Crypto_DES\"></p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：<br>3DES加密过程为：C=Ek3(Dk2(Ek1(P)))<br>3DES解密过程为：P=Dk1(EK2(Dk3(C)))<br>若<strong>Ek1 == Ek2 == Ek3</strong>，就是简单的DES了。</p>\n<h2 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png\" alt=\"Crypto_AES\"><br>图片来自网络，若有侵犯到权利之处，请告知，谢谢~    </p>\n<p>AES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。<br>算法详细已经有其他人写了，我就不再造轮子了。<a href=\"http://www.blogfshare.com/aes-rijndael.html\" target=\"_blank\" rel=\"external\">密码算法详解——AES</a><br>还有算法及解密算法的<a href=\"http://blog.csdn.net/searchsun/article/details/2516191\" target=\"_blank\" rel=\"external\">模式介绍</a>，可以了解了解~    </p>\n<h2 id=\"RC4\"><a href=\"#RC4\" class=\"headerlink\" title=\"RC4\"></a>RC4</h2><p>不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。</p>\n<h2 id=\"CommonCrypto\"><a href=\"#CommonCrypto\" class=\"headerlink\" title=\"CommonCrypto\"></a>CommonCrypto</h2><p>对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    </p>\n<h3 id=\"CommonCrypto的一些主要的结构体\"><a href=\"#CommonCrypto的一些主要的结构体\" class=\"headerlink\" title=\"CommonCrypto的一些主要的结构体\"></a>CommonCrypto的一些主要的结构体</h3><ol>\n<li>CCOperation：定义操作：加密或解密</li>\n</ol>\n<pre><code>enum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n</code></pre><ol>\n<li>CCAlgorithm：加解密算法，很明显就不详细说明了。</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n</code></pre>\n<ol>\n<li>CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n</code></pre>\n<ol>\n<li>KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n</code></pre>\n<h3 id=\"通过代码实现\"><a href=\"#通过代码实现\" class=\"headerlink\" title=\"通过代码实现\"></a>通过代码实现</h3><h4 id=\"导入CommonCrypto的头文件。\"><a href=\"#导入CommonCrypto的头文件。\" class=\"headerlink\" title=\"导入CommonCrypto的头文件。\"></a>导入CommonCrypto的头文件。</h4><pre><code class=\"objc\">#import &lt;CommonCrypto/CommonCrypto.h&gt;\n</code></pre>\n<h4 id=\"symCrypt\"><a href=\"#symCrypt\" class=\"headerlink\" title=\"symCrypt\"></a>symCrypt</h4><pre><code class=\"objc\">/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@&quot;[ERROR] failed to encrypt|CCCryptoStatus: %d&quot;, *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n</code></pre>\n<ol>\n<li>根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength</li>\n<li>加密后的数据总小于等于数据长度加上block的大小</li>\n<li>申请bufferSize的空间以保存加密或解密后的数据</li>\n<li>调用CCCrypt函数实现加解密。<pre><code class=\"objc\">CCCryptorStatus CCCrypt(\n CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n const void *key,        /* 密钥 */\n size_t keyLength,       /* 密钥长度 */\n const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n const void *dataIn,     /* 要加密或解密的数据 */\n size_t dataInLength,    /* 数据长度 */\n void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n size_t *dataOutMoved    /* 结果所占的长度 */\n )    \n __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>若成功，则将(void *)类型的数据封装到NSData中。</li>\n<li>释放申请的buffer内存</li>\n<li>返回。</li>\n</ol>\n<h4 id=\"fixKeyLength\"><a href=\"#fixKeyLength\" class=\"headerlink\" title=\"fixKeyLength\"></a>fixKeyLength</h4><pre><code class=\"objc\">/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength &lt; kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength &lt; kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n</code></pre>\n<h4 id=\"blockSizeByAlgorithm\"><a href=\"#blockSizeByAlgorithm\" class=\"headerlink\" title=\"blockSizeByAlgorithm\"></a>blockSizeByAlgorithm</h4><pre><code class=\"objc\">/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n</code></pre>\n<p>上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：<br>　　DESCipherActor.h<br>　　<code>objc\n​    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n​    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;</code><br>　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传<a href=\"https://github.com/objchris/PKIDemo\" target=\"_blank\" rel=\"external\">Github</a></p>\n<p>　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！<br>　　What the <em>**</em>！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg\" alt=\"desk\">    </p>\n<p>　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决…</p>\n<h1 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h1><p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>如甲乙双方需要加密通信：</p>\n<ol>\n<li>乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。</li>\n<li>得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。</li>\n<li>乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。</li>\n</ol>\n<p>　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。<br>　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。<br>　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png\" alt=\"yaoMing\"></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><ol>\n<li>选取两个质数p和q, 计算<code>n = p * q</code> 。p和q要尽量大</li>\n<li>根据质数<code>φ(p)=p-1</code>和欧拉方程满足乘法结合率的规律求出φ(n),即<code>φ(n)=(p-1)(q-1)</code></li>\n<li>选取质数e作为公钥指数, e的范围<code>1&lt;e&lt;φ(n)</code>,且 e 与 φ(n) 互质</li>\n<li>出e对φ(n)的模反元素d，求解公式：<code>ed ≡ 1 (mod φ(n))</code>即可得出<br>这样计算后(n,e)是公钥，(n,d)是私钥。<blockquote>\n<p>公钥加密公式<br>m^e ≡ c (mod n) 即 c = m^e mod n<br>私钥解密公式<br>c^d ≡ m (mod n) 即 m = c^d mod n    </p>\n</blockquote>\n</li>\n</ol>\n<p>RSA加密常用的填充方式有下面3种：    </p>\n<ol>\n<li>RSA_PKCS1_PADDING 填充模式，最常用的模式<br>输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长<br>根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     </li>\n<li>RSA_PKCS1_OAEP_PADDING<br>输入：RSA_size(rsa) – 41<br>输出：和modulus一样长    </li>\n<li>for RSA_NO_PADDING 不填充<br>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长    </li>\n</ol>\n<p>特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：<br><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\" target=\"_blank\" rel=\"external\">RSA算法原理（一）</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\" target=\"_blank\" rel=\"external\">RSA算法原理（二）</a></p>\n<h3 id=\"iOS-Security-framework\"><a href=\"#iOS-Security-framework\" class=\"headerlink\" title=\"iOS Security.framework\"></a>iOS Security.framework</h3><h4 id=\"encryptWithPublicKey\"><a href=\"#encryptWithPublicKey\" class=\"headerlink\" title=\"encryptWithPublicKey\"></a>encryptWithPublicKey</h4><pre><code class=\"objc\">- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@&quot;dataLength: %zu&quot;, dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) &lt; dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) &lt; toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &amp;cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n</code></pre>\n<ol>\n<li>根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）</li>\n<li>创建MutableData用以下面操作添加Data</li>\n<li>判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。</li>\n<li>while循环多次操作</li>\n<li>使用SecKeyEncrypt进行加解密<pre><code class=\"objc\">OSStatus SecKeyEncrypt(\n SecKeyRef           key,                //加解密使用的密钥\n SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n const uint8_t       *plainText,          //明文\n size_t              plainTextLen,        //明文长度\n uint8_t             *cipherText,        //返回的密文\n size_t              *cipherTextLen)     //返回的密文长度\n __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>将已经加解密过的数据剔除</li>\n<li>往MutableData中添加数据</li>\n<li>计算总的BufferSize，这里只是做个统计</li>\n<li>将得到的数据进行Base64转码</li>\n<li>记得释放cipherBuffer</li>\n</ol>\n<h4 id=\"decryptWithPrivateKey\"><a href=\"#decryptWithPrivateKey\" class=\"headerlink\" title=\"decryptWithPrivateKey\"></a>decryptWithPrivateKey</h4><pre><code class=\"objc\">- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer &lt; cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer &lt; toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &amp;plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n</code></pre>\n<p>解密和加密的方式基本一样，此处不多加赘述。<br><a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/PKIDemo\" target=\"_blank\" rel=\"external\">Demo</a></p>\n<p><strong>Hacker君，问你惊未，哈哈哈哈哈。</strong><br>非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahahahaha\"><br>从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　</p>\n<p>题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。<br>更多的算法，eg：数字摘要、数字签名、口令认证等等都在<a href=\"https://github.com/objchris/PKIDemo\" target=\"_blank\" rel=\"external\">Github</a>上了，有兴趣请移步。<br>关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！</p>\n","excerpt":"<p>Hacker,问你惊未Σ( ° △ °|||)︴</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg\" alt=\"Crypto_Sherlock\"> </p>\n<p>看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··<br>​<br>今天来聊聊阿澤君的故事，顺便谈谈</p>\n<ol>\n<li>CommonCryto中关于DES、AES的部分内容</li>\n<li>iOS的Security框架里关于RSA加密的部分内容….</li>\n</ol>\n<p>阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg\" alt=\"focusOnCom\">    </p>\n<p>很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg\" alt=\"bucuowo\"></p>\n<h1 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h1><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。</p>\n<h2 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h2><p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg\" alt=\"Crypto_DES\"></p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：<br>3DES加密过程为：C=Ek3(Dk2(Ek1(P)))<br>3DES解密过程为：P=Dk1(EK2(Dk3(C)))<br>若<strong>Ek1 == Ek2 == Ek3</strong>，就是简单的DES了。</p>\n<h2 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png\" alt=\"Crypto_AES\"><br>图片来自网络，若有侵犯到权利之处，请告知，谢谢~    </p>\n<p>AES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。<br>算法详细已经有其他人写了，我就不再造轮子了。<a href=\"http://www.blogfshare.com/aes-rijndael.html\">密码算法详解——AES</a><br>还有算法及解密算法的<a href=\"http://blog.csdn.net/searchsun/article/details/2516191\">模式介绍</a>，可以了解了解~    </p>\n<h2 id=\"RC4\"><a href=\"#RC4\" class=\"headerlink\" title=\"RC4\"></a>RC4</h2><p>不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。</p>\n<h2 id=\"CommonCrypto\"><a href=\"#CommonCrypto\" class=\"headerlink\" title=\"CommonCrypto\"></a>CommonCrypto</h2><p>对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    </p>\n<h3 id=\"CommonCrypto的一些主要的结构体\"><a href=\"#CommonCrypto的一些主要的结构体\" class=\"headerlink\" title=\"CommonCrypto的一些主要的结构体\"></a>CommonCrypto的一些主要的结构体</h3><ol>\n<li>CCOperation：定义操作：加密或解密</li>\n</ol>\n<pre><code>enum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n</code></pre><ol>\n<li>CCAlgorithm：加解密算法，很明显就不详细说明了。</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n</code></pre>\n<ol>\n<li>CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n</code></pre>\n<ol>\n<li>KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n</code></pre>\n<h3 id=\"通过代码实现\"><a href=\"#通过代码实现\" class=\"headerlink\" title=\"通过代码实现\"></a>通过代码实现</h3><h4 id=\"导入CommonCrypto的头文件。\"><a href=\"#导入CommonCrypto的头文件。\" class=\"headerlink\" title=\"导入CommonCrypto的头文件。\"></a>导入CommonCrypto的头文件。</h4><pre><code class=\"objc\">#import &lt;CommonCrypto/CommonCrypto.h&gt;\n</code></pre>\n<h4 id=\"symCrypt\"><a href=\"#symCrypt\" class=\"headerlink\" title=\"symCrypt\"></a>symCrypt</h4><pre><code class=\"objc\">/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@&quot;[ERROR] failed to encrypt|CCCryptoStatus: %d&quot;, *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n</code></pre>\n<ol>\n<li>根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength</li>\n<li>加密后的数据总小于等于数据长度加上block的大小</li>\n<li>申请bufferSize的空间以保存加密或解密后的数据</li>\n<li>调用CCCrypt函数实现加解密。<pre><code class=\"objc\">CCCryptorStatus CCCrypt(\n CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n const void *key,        /* 密钥 */\n size_t keyLength,       /* 密钥长度 */\n const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n const void *dataIn,     /* 要加密或解密的数据 */\n size_t dataInLength,    /* 数据长度 */\n void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n size_t *dataOutMoved    /* 结果所占的长度 */\n )    \n __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>若成功，则将(void *)类型的数据封装到NSData中。</li>\n<li>释放申请的buffer内存</li>\n<li>返回。</li>\n</ol>\n<h4 id=\"fixKeyLength\"><a href=\"#fixKeyLength\" class=\"headerlink\" title=\"fixKeyLength\"></a>fixKeyLength</h4><pre><code class=\"objc\">/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength &lt; kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength &lt; kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n</code></pre>\n<h4 id=\"blockSizeByAlgorithm\"><a href=\"#blockSizeByAlgorithm\" class=\"headerlink\" title=\"blockSizeByAlgorithm\"></a>blockSizeByAlgorithm</h4><pre><code class=\"objc\">/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n</code></pre>\n<p>上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：<br>　　DESCipherActor.h<br>　　<code>objc\n​    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n​    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n​    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;</code><br>　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传<a href=\"https://github.com/objchris/PKIDemo\">Github</a></p>\n<p>　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！<br>　　What the <em>**</em>！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg\" alt=\"desk\">    </p>\n<p>　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决…</p>\n<h1 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h1><p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>如甲乙双方需要加密通信：</p>\n<ol>\n<li>乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。</li>\n<li>得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。</li>\n<li>乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。</li>\n</ol>\n<p>　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。<br>　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。<br>　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png\" alt=\"yaoMing\"></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><ol>\n<li>选取两个质数p和q, 计算<code>n = p * q</code> 。p和q要尽量大</li>\n<li>根据质数<code>φ(p)=p-1</code>和欧拉方程满足乘法结合率的规律求出φ(n),即<code>φ(n)=(p-1)(q-1)</code></li>\n<li>选取质数e作为公钥指数, e的范围<code>1&lt;e&lt;φ(n)</code>,且 e 与 φ(n) 互质</li>\n<li>出e对φ(n)的模反元素d，求解公式：<code>ed ≡ 1 (mod φ(n))</code>即可得出<br>这样计算后(n,e)是公钥，(n,d)是私钥。<blockquote>\n<p>公钥加密公式<br>m^e ≡ c (mod n) 即 c = m^e mod n<br>私钥解密公式<br>c^d ≡ m (mod n) 即 m = c^d mod n    </p>\n</blockquote>\n</li>\n</ol>\n<p>RSA加密常用的填充方式有下面3种：    </p>\n<ol>\n<li>RSA_PKCS1_PADDING 填充模式，最常用的模式<br>输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长<br>根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     </li>\n<li>RSA_PKCS1_OAEP_PADDING<br>输入：RSA_size(rsa) – 41<br>输出：和modulus一样长    </li>\n<li>for RSA_NO_PADDING 不填充<br>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长    </li>\n</ol>\n<p>特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：<br><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\">RSA算法原理（一）</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\">RSA算法原理（二）</a></p>\n<h3 id=\"iOS-Security-framework\"><a href=\"#iOS-Security-framework\" class=\"headerlink\" title=\"iOS Security.framework\"></a>iOS Security.framework</h3><h4 id=\"encryptWithPublicKey\"><a href=\"#encryptWithPublicKey\" class=\"headerlink\" title=\"encryptWithPublicKey\"></a>encryptWithPublicKey</h4><pre><code class=\"objc\">- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@&quot;dataLength: %zu&quot;, dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) &lt; dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) &lt; toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &amp;cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n</code></pre>\n<ol>\n<li>根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）</li>\n<li>创建MutableData用以下面操作添加Data</li>\n<li>判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。</li>\n<li>while循环多次操作</li>\n<li>使用SecKeyEncrypt进行加解密<pre><code class=\"objc\">OSStatus SecKeyEncrypt(\n SecKeyRef           key,                //加解密使用的密钥\n SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n const uint8_t       *plainText,          //明文\n size_t              plainTextLen,        //明文长度\n uint8_t             *cipherText,        //返回的密文\n size_t              *cipherTextLen)     //返回的密文长度\n __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>将已经加解密过的数据剔除</li>\n<li>往MutableData中添加数据</li>\n<li>计算总的BufferSize，这里只是做个统计</li>\n<li>将得到的数据进行Base64转码</li>\n<li>记得释放cipherBuffer</li>\n</ol>\n<h4 id=\"decryptWithPrivateKey\"><a href=\"#decryptWithPrivateKey\" class=\"headerlink\" title=\"decryptWithPrivateKey\"></a>decryptWithPrivateKey</h4><pre><code class=\"objc\">- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer &lt; cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer &lt; toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &amp;plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n</code></pre>\n<p>解密和加密的方式基本一样，此处不多加赘述。<br><a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/PKIDemo\">Demo</a></p>\n<p><strong>Hacker君，问你惊未，哈哈哈哈哈。</strong><br>非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahahahaha\"><br>从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　</p>\n<p>题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。<br>更多的算法，eg：数字摘要、数字签名、口令认证等等都在<a href=\"https://github.com/objchris/PKIDemo\">Github</a>上了，有兴趣请移步。<br>关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！</p>"},{"title":"我想...修复一个已发布软件的BUG","date":"2018-11-07T06:53:07.000Z","typora-copy-images-to":"ipic","_content":"\n事实上，我也没想过会是以这种形式接触逆向工程，我甚至不知道这样是不是就叫逆向工程，事情的起因就只是想省下一笔买蓝牙键盘的钱，惭愧。\n\n<!--more-->\n\n## 背景与目的\n\n对全面屏 iPad Pro 的青睐已久，在今年 10 月 30 号 发布之后就剁手买了一个。不想买配套键盘，一是觉得与 iPad 的设计初衷向违背，移动办公不想多个累赘的键盘；二是一千三百多大洋着实让我望而却步，感觉不是很值得吧。而且平时用 iPad 也没用键盘，小部分时候确实不方便。今天看着电脑键盘突然想到，能不能通过 Mac 来连接 iPad ，充当 iPad 的键盘呢？\n\n起初想学学自己写个 Mac 端的 App ，发现成本略高，遂转去寻找市面上是否有满足的 App。发现了一款：1Keyboard 。不过很久没更新，上一次已是 2016 年。看了 App Store，68 大洋。\n\n使用的过程中，我发现了一个可能是 BUG 的无脑设定，十分影响使用，所以寻思着看看能否自己解决，于是我要对 1Keyboard 开刀了。\n\n## 工具\n\n- class-dump —— 导出一个二进制文件的头文件等信息。\n\n- Hopper Disassembler —— 反汇编分析工具。\n- lldb —— Xcode 自带的调试器。\n\n- Hex fiend —— 二进制文件编辑器。\n\n## 开刀\n\n### 为什么要开刀\n\n正如医生对症下刀一样，病人接受临床手术必定是身体机能有问题。 1Keyboard 的问题在于：一个可能是 BUG 的无脑设定。\n\n实话，第一次的尝试『 macOS 10.14 连接 iOS 12.1 ( iPhone ) 』给我留下的印象还是很好的，输入的东西很快地在我的手机上显示出来，时延低。但是我在 Mac 上码字习惯用 Caps Lock 来切换输入法，事实上，1Keyboard 应该也是支持 Caps Lock 来更换移动设备的输入法的（我看到 iPhone 上输入法已经切换），但在 Mac 上弹出的类似 HUD 的窗口竟然出现了一个 Sheet ？！\n\n![Screen Shot 2018-11-07 at 4.07.39 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8f3t1.png)\n\nWhat ？！！ 这种感觉就好像代码的某个位置接收到键盘 Caps Lock 事件时命名奇妙地执行了这样一段代码：\n\n```objective-c\nNSAlert *alert = [[NSAlert alloc] init];\nalert.alertStyle = NSAlertStyleInformational;\nalert.messageText = @\"Use the fn Key + media keys to control playback and volumn\";\n[alert beginSheetModalForWindow:window completionHandler:nil];\n```\n\n这个提示是好的，让我知道我还能通过 Fn + 的组合去调节移动设备的音量、亮度等。但不应该是以这种情况出现的。\n\n所以，很明显——这次的临床手术就是**找到这个 BUG 并解决它**。\n\n### 初探 1Keyboard\n\n我们知道 App 的执行代码最后都编译链接成一个二进制文件，而 1Keyboard 的二进制文件就是 1Keyboard.app/Contents/MacOS/1Keyboard 。绝大多数的操作都是对这个二进制文件进行的。\n\n了解一个软件，我们都需要从头文件开始做起。先看看软件中存在哪些类，类中都有些什么函数。这时候，我们第一个工具 class-dump 就起作用了。\n\n将 class-dump 放在与 App 放在同一个文件夹下，然后在终端执行命令，看看里面有哪些头文件：\n\n```shell\nclass-dump -H 1Keyboard.app/Contents/MacOS/1Keyboard -o ./Headers\n```\n\n运行结束后在当前目录中会有一个叫 Headers 的文件夹，里面就包含了 1Keyboard 的头文件。此时会看到，几十个头文件，密密麻麻不知道从何看起。\n\n### 第一次寻找突破点\n\n还记得前面的截图吗？！在出现问题的时候，我们使用的窗口是仅仅是类 HUD 的一个 Windows。那突破口应该就是一个 Controller 或者一个 Window 。在头文件里找，很快地找到一个疑似的 BoxViewController.h 。\n\n![Screen Shot 2018-11-08 at 11.44.52 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qcyfk.png)\n\n一个疑似的函数也出现了：`- (void)handleKeyboardEvent:(id)arg1`。感觉像是用来处理键盘事件的。\n\n找到点苗头，接下来就是看看函数实现能否印证我们的猜测。\n\n打开 Hopper Disassembler ，将 Macos 文件夹下的二进制文件拖入其中，会得到很多汇编代码，如下图：\n\n![Screen Shot 2018-11-08 at 11.56.02 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/w7f2s.png)\n\n汇编是低层的编程语言，写 C 时有可能会在函数中间插入一小段，还有使用 Xcode 调试的时候也经常能看到，但是没有深入的学习，是没法了解其中指令的含义，在本次逆向，我们就先忽略它们。\n\n左边栏的 Tag Scope 可以选择类，或者通过上方的搜索框，我们可以轻松地找到我们想要的 BoxViewController 。随即下方出现 BoxViewController 类中被实现的函数。同样，找到 `[BoxViewController handleKeyboardEvent:]` \n\n![Screen Shot 2018-11-08 at 12.03.21 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qeb6a.png)\n\n:[ 还是汇编代码。不过，我们可以通过\n\n![Screen Shot 2018-11-08 at 12.04.41 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8futb.png)\n\n第三个选项 if(b) f(x); 转换成伪代码，看起来就简单多了。\n\n![Screen Shot 2018-11-08 at 12.06.00 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jk2jy.png)\n\n一切都是这么顺利。但是到这里，我们发现：伪代码中只有一个 `if-else` ，判断条件是 event 的 keyCode 是否等于 0x35 。通过参考资料 1. NSEvent Code 可以得出，0x35 是 esc ，不是我们想要的 Caps Lock （0x39）。\n\n### 第二次寻找突破点\n\n回想起来，忽略了一点，既然 App 弹出提示，那为何不从提示文本入手呢？\n\n```\nUse the fn key + media keys to control playback and volumn.\n```\n\n对于没有做国际化的 App ，提示文本肯定是在实现文件内的，同样地，我们在 Hopper Disassembler 中看能否搜索到。这次不能搜索 Labels 了，要选择 str 选项。\n\n![Screen Shot 2018-11-08 at 2.48.00 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/xo66d.png)\n\n找到了我们要的结果，看右边，在地址处右键选择 References to 0x10001f3ed 。可以得到是哪个方法引用了这个字符串。我们得到的是\n\n```\nDATA XREF=-[BoxViewController mediaKeysPressed:]+102\n```\n\n继续深入，我们如法炮制，来看看 `mediaKeysPressed` 这个函数里面是什么。\n\n![Screen Shot 2018-11-08 at 2.55.46 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/c3z3h.png)\n\n1Keyboard 就是在这个方法中弹出框的，这也验证了一开始的猜想，在不知道什么情况下，执行了最上面说的那段类似的代码。\n\n然而，这个函数也只是做到弹框显示，没有什么对解决问题有用的信息。那我们就要来看看是哪里调用了这个函数。\n\n回到汇编代码这边来，在函数名称右键选择 References to selector mediaKeysPressed :\n\n![Screen Shot 2018-11-08 at 3.01.38 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rnxwk.png)\n\n会发现，我们去到 BoxViewController 的 `awakeFromNib`中。\n\n![Screen Shot 2018-11-08 at 3.06.48 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/o9rhm.png)\n\n`mediaKeysPressed` 原来是通知事件的 selector 。我们可以发现到后面的字符串  media_keys_pressed 。\n\n再重复上面的操作，最后可以找到 MyNSApplication 的 `sendEvent:`方法。\n\n![Screen Shot 2018-11-08 at 3.14.29 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/irvtr.png)\n\n乍一看觉得很熟悉，查阅了文档知道是 NSApplication 用于分发事件的， 1Keyboard 重写了这个方法，那现在问题很明确，我们按下 Caps Lock 的时候，进入到这个方法中了。\n\n本着科学的无限探索精神，我想弄清楚：为什么要重写？怎么解决我们要解决的问题？\n\n### 问题思考\n\n首先，对几个问题的思考：\n\nQ：什么是 Media Key？\n\nA：就是这几个键。![Screen Shot 2018-11-08 at 3.28.42 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3fclz.png)\n\nQ：为什么要重写`sendEvent:`？\n\nA：这个问题个人觉得与 1Keyboard 的设计初衷有关系，从方法名、Notification Name 我们可以得知，1Keyboard 是想在 macOS 上实现对移动设备播放、暂停、调节亮度、音量等多媒体操作的控制。对于有 Media Key 的键盘，自然就需要增加对 Media Key 的支持。监测 Media Key 的`KeyDown` 和`KeyUp`最常见的方式就是重写 `sendEvent:`。\n\n如上面代码中所示：\n\n```objective-c\nif (([rbx type] == 0xe) && (([rbx subtype] & 0xffff) == 0x8))\n```\n\n`rbx `是 `[arg2 retain]` ，理所当然是一个 `NSEvent` Object 。当 `[rbx type]` 是 `NSEventTypeSystemDefined`（14）且  `[rbx subtype]` 是 8 的时候，就当做是一个  Media Key 的事件，可以借鉴参考资料给出的 2.获取MediaKey的开源Lib——SPMediaKeyTap 。\n\n然后，第二个判断条件：\n\n```objective-c\nif ([rbx data1] & 0xff00) != 0xa00)\n```\n\n成立是指按键被按下，即 KeyDown 。\n\n 1Keyboard 设计的初衷和出发点是好的，但是在`sendEvent:`中没有对 Event 的 keyCode进行判断，导致问题的出现。\n\n### 寻找解决方法\n\n稍微停一下，我们在这里重整一下思路，一开始通过查找字符串，得到 selector ，然后通过引用关系，找到 NSApplication 中的 `sendEvent` 中通知的发起点，并知道了 BUG 发生的原因，没有判断 event 的 keyCode。\n\n那好了，现在有两种解决方式：\n\n1. 在发送 media_keys_pressed 通知之前判断 event 的 keyCode 是否为 0x39 ，若是，则不发送通知。\n2. 去掉`[postNotificationName:object:]`，不再发送通知。\n\n第一种会影响整个二进制文件，添加的代码后面所有属性和函数的地址都需要修改；第二种直接覆盖原有地址的汇编，对原来二进制文件影响小，但是不会再弹出提示框。\n\n对于我这个新手来说，第二种方法虽然没有第一种高级，但至少省下时间，且提示框也不影响平时的使用。\n\n所以，剩下最后一步：将`[postNotificationName:object:]`的汇编码变成无作为。\n\n这时候就需要用到 lldb 了，实际上，用 Hopper Disassembler 是可以直接修改的，只是需要购买 license 。我使用的是试用版，没有修改二进制文件的功能。其实用 gdb 也可以，现在搜到的大多数文章也是用 gdb 来调试程序，但既然在 macOS 上，安装了 Xcode 就有了lldb ，且可以免去 gdb codesign 的烦恼。\n\n好啦，接下来，我们用 lldb 来完成剩下的工作：\n\n1. 找到调用语句。\n2. 使用 NOP 替换掉它。\n\n先使 lldb 进入调试模式：\n\n```shell\nlldb 1Keyboard.app/Contents/MacOS/1Keyboard\n```\n\nlldb 有个 disassemble 指令，可以通过它来看到一个区间内的地址指令情况：\n\n```shell\n(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n1Keyboard[0x10000a541] <+103>: movq   0x2ba00(%rip), %rdi       ; (void *)0x0000000000000000\n1Keyboard[0x10000a548] <+110>: movq   0x2a919(%rip), %rsi       ; \"defaultCenter\"\n1Keyboard[0x10000a54f] <+117>: movq   0x20bfa(%rip), %r15       ; (void *)0x0000000000000000\n1Keyboard[0x10000a556] <+124>: callq  *%r15\n1Keyboard[0x10000a559] <+127>: movq   %rax, %rdi\n1Keyboard[0x10000a55c] <+130>: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n1Keyboard[0x10000a561] <+135>: movq   %rax, %r14\n1Keyboard[0x10000a564] <+138>: movq   0x2af95(%rip), %rsi       ; \"postNotificationName:object:\"\n1Keyboard[0x10000a56b] <+145>: leaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n1Keyboard[0x10000a572] <+152>: xorl   %ecx, %ecx\n1Keyboard[0x10000a574] <+154>: movq   %r14, %rdi\n1Keyboard[0x10000a577] <+157>: callq  *%r15\n1Keyboard[0x10000a57a] <+160>: movq   %r14, %rdi\n1Keyboard[0x10000a57d] <+163>: callq  0x100019af8               ; symbol stub for: objc_release\n```\n\nlldb 的指令如无歧义，可以进行缩写，如 **p**rint **o**bject 可以缩写成 po 。disassemble 也可以缩写成 di 。-s 是起始地址，-e 是结束地址。\n\n肯定有人要问：000000010000a541 和 000000010000a582 是怎么得来的？\n\n那就要回到 Hopper Disassembler 了。\n\n记得前面我们看过 `[sendEvent:]`的伪代码，我们还可以看到它的汇编代码的不是吗？只需要点击 mov add 按钮就可以了。可以看到起始地址和结束地址了吧。\n\n![Screen Shot 2018-11-09 at 11.03.14 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j7fmb.png)\n\n我们都知道 OC 使用消息传递，用 objc_msgSend 来充当函数调用。需要有消息发送者和参数。\n\n分析一下这段输出，首先我们很快找到 `postNotificationName:object:` ：\n\n```shell\nmovq   0x2af95(%rip), %rsi\t\t ; \"postNotificationName:object:\"\n```\n\n在汇编代码中 % 前缀的是指寄存器。`movq (%ebx), %edx` 是指64位间接寻址，因此，这个指令应该是去找 selector 的地址。\n\n```shell\nleaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n```\n\n这个很明显：找到 @\"media_keys_pressed\" 这个字符串。\n\n```shell\nmovq   %r14, %rdi\n```\n\n这个是找调用 `postNotificationName:object:` 的对象，也就是 NotificationCenter 。\n\n最后，通过 `callq` 来进行调用：\n\n```\ncallq  *%r15\n```\n\n至此，调用语句已经找到了，接下来就是使用 NOP 来替换它。\n\n> NOP 是什么？\n>\n> 计算机科学中，NOP 或 NOOP 是汇编语言的一个指令，一系列编程语句，或网络传输协议中的表示不做任何有效操作的命令。\n>\n> NOP 的值是 0x90 ，占用一个字节。\n\n首先，要设置断点，让程序在某个位置停下来，方便我们修改指令调试：\n\n```shell\n(lldb) breakpoint set -n \"[MyNSApplication sendEvent:]\"\n(lldb) r\n```\n\nr 是让程序开始运行，按照之前，我们连接手机，按下任意键，会触发断点。此时 lldb 会停下来等待我们进一步的输入。\n\n从上面可以知道，我们要修改的指令是：\n\n```shell\n1Keyboard[0x10000a577] <+157>: callq  *%r15\n1Keyboard[0x10000a57a] <+160>: movq   %r14, %rdi\n```\n\n指令在内存中的起始地址是 `0x10000a577`，需要注意的是：下一条指令起始地址是 `0x10000a57a`。也就是说，我们要修改的指令占据了三个 Byte 。而一个 NOP 只是一个 Byte 。所以我们要将 `callq  *%r15` 替换成三个 NOP ：\n\n```shell\n(lldb) memory write -f x 0x10000a577 0x90\n(lldb) memory write -f x 0x10000a578 0x90\n(lldb) memory write -f x 0x10000a579 0x90\n```\n\n使用 `memory write` 可以达到 gdb 中 `set` 的效果。然后我们再 disassemble 一次：\n\n```shell\n(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n    0x10000a541 <+103>: movq   0x2ba00(%rip), %rdi       ; (void *)0x00007fffa62b49d8: NSNotificationCenter\n    0x10000a548 <+110>: movq   0x2a919(%rip), %rsi       ; \"defaultCenter\"\n    0x10000a54f <+117>: movq   0x20bfa(%rip), %r15       ; (void *)0x00007fff7a0d1a00: objc_msgSend\n    0x10000a556 <+124>: callq  *%r15\n    0x10000a559 <+127>: movq   %rax, %rdi\n    0x10000a55c <+130>: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n    0x10000a561 <+135>: movq   %rax, %r14\n    0x10000a564 <+138>: movq   0x2af95(%rip), %rsi       ; \"postNotificationName:object:\"\n    0x10000a56b <+145>: leaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n    0x10000a572 <+152>: xorl   %ecx, %ecx\n    0x10000a574 <+154>: movq   %r14, %rdi\n    0x10000a577 <+157>: nop\n    0x10000a578 <+158>: nop\n    0x10000a579 <+159>: nop\n    0x10000a57a <+160>: movq   %r14, %rdi\n    0x10000a57d <+163>: callq  0x100019af8               ; symbol stub for: objc_release\n```\n\n如我们所愿，已经改好了。在终端输入 `c` ，让程序继续运行，这时会发现，按下 Caps Lock已经不会再弹出那个厌烦的 Sheet 了。\n\n到这里，已经完成大部分了，lldb 只是一个调试工具，并不能做到修改二进制文件的功能，所以要将修改长效地保存下来，就需要对原二进制文件进行修改。我们就必须先找到 `0x10000a577` 起始的三个 Byte 的二进制代码是什么。\n\n因为我们已经修改过内存中的程序，所以需要先将 lldb 退出，重新加载原来的程序，再使用 `x/x` 指令：\n\n```shell\n(lldb) x/x 0x10000a577\n0x10000a577: 0x4cd7ff41\n(lldb) x/x 0x10000a578\n0x10000a578: 0x894cd7ff\n(lldb) x/x 0x10000a579\n0x10000a579: 0xf7894cd7\n```\n\n我们发现，这三个地址都有部分是重合的，不是巧合，不同的指令拥有不同的二进制编码，`x/x` 指令总是读取相同长度的内存中的数据。因此我们要将相同的合在一起。\n\n还需要注意的是：\n\n> **字节序问题（ Byte Order ）**，Intel 处理器一般是以**小端（ Little endian ）**进行存储，而在硬盘上的二进制码，则是以**大端（ Big endian ）**存储。所谓的**大端**，就是把数字的最高位放在最前面，**小端**则是把最高位放在最后面。\n>\n> ——摘自参考资料 5.一个数字的魔法——破解Mac上198元的Paw\n\n所以，三者的二进制代码组合起来就是：`41 FF D7 4C 89 F7` 。\n\n打开 Hex Fiend 。将二进制文件拖入其中，搜索 `41 FF D7 4C 89 F7` ，仔细发现，可以搜索出来三个，在不确定是哪个的情况下，我们可以继续对后面的指令再 `x/x` 。组合更多的 Byte 提高搜索精确度。\n\n再选两个指令：\n\n```\n(lldb) x/x 0x10000a57a\n0x10000a57a: 0xe8f7894c\n(lldb) x/x 0x10000a57b\n0x10000a57b: 0x76e8f789\n```\n\n好了，我们的搜索组合现在变成：`41 FF D7 4C 89 F7 E8 76`。这样就有且仅有一个结果了：\n\n![Screen Shot 2018-11-09 at 1.24.40 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkugc.png)\n\n还记得我们要替换为三位 NOP 吗？将 `90 90 90 4C 89 F7 E8 76` 填入到 Replace 中。再选择 Replace & Find 就可以了。\n\n至此，就完成了整个问题的修复。可以 lldb 打开调试看看有没有问题。直接通过双击 1Keyboard.app 是无法打开的，是因为我们修改了 app 中的文件，App 签名已经无法验证通过了。需要进行代码重签：具体可以看我之前的这篇文章。\n\n然后就可以愉快地玩耍了~ \n\n\n\n## 最后说两句\n\n我是在看别人的优秀文章的时候学习了一点点逆向工程的皮毛。第一次接触逆向工程，很多地方写的不好，肯定有错误的地方，对上述操作手动表示滑稽，还请不吝指正。\n\n另外，推荐两篇延伸阅读，请见参考资料 5.6. 。\n\n\n\n## 参考资料\n\n[1. NSEvent KeyCode](https://forums.macrumors.com/threads/nsevent-keycode-list.780577/)\n\n[2.获取MediaKey的开源Lib——SPMediaKeyTap](https://github.com/nevyn/SPMediaKeyTap)\n\n[3.SPMediaKeyTap作者对Media Key处理方式的解释](http://overooped.com/post/2593597587/mediakeys)\n\n[4.GDB - To - LLDB](http://lldb.llvm.org/lldb-gdb.html)\n\n[5.一个数字的魔法——破解Mac上198元的Paw](https://bestswifter.com/app-crack/)\n\n[6.饿了么安全：Mac 下的破解软件真的安全吗？](https://juejin.im/entry/598d53155188257c666c5943)","source":"_posts/逆向修复软件的BUG.md","raw":"---\ntitle: 我想...修复一个已发布软件的BUG\ndate: 2018-11-7 14:53:07\ntags: \n- Security\ntypora-copy-images-to: ipic\n---\n\n事实上，我也没想过会是以这种形式接触逆向工程，我甚至不知道这样是不是就叫逆向工程，事情的起因就只是想省下一笔买蓝牙键盘的钱，惭愧。\n\n<!--more-->\n\n## 背景与目的\n\n对全面屏 iPad Pro 的青睐已久，在今年 10 月 30 号 发布之后就剁手买了一个。不想买配套键盘，一是觉得与 iPad 的设计初衷向违背，移动办公不想多个累赘的键盘；二是一千三百多大洋着实让我望而却步，感觉不是很值得吧。而且平时用 iPad 也没用键盘，小部分时候确实不方便。今天看着电脑键盘突然想到，能不能通过 Mac 来连接 iPad ，充当 iPad 的键盘呢？\n\n起初想学学自己写个 Mac 端的 App ，发现成本略高，遂转去寻找市面上是否有满足的 App。发现了一款：1Keyboard 。不过很久没更新，上一次已是 2016 年。看了 App Store，68 大洋。\n\n使用的过程中，我发现了一个可能是 BUG 的无脑设定，十分影响使用，所以寻思着看看能否自己解决，于是我要对 1Keyboard 开刀了。\n\n## 工具\n\n- class-dump —— 导出一个二进制文件的头文件等信息。\n\n- Hopper Disassembler —— 反汇编分析工具。\n- lldb —— Xcode 自带的调试器。\n\n- Hex fiend —— 二进制文件编辑器。\n\n## 开刀\n\n### 为什么要开刀\n\n正如医生对症下刀一样，病人接受临床手术必定是身体机能有问题。 1Keyboard 的问题在于：一个可能是 BUG 的无脑设定。\n\n实话，第一次的尝试『 macOS 10.14 连接 iOS 12.1 ( iPhone ) 』给我留下的印象还是很好的，输入的东西很快地在我的手机上显示出来，时延低。但是我在 Mac 上码字习惯用 Caps Lock 来切换输入法，事实上，1Keyboard 应该也是支持 Caps Lock 来更换移动设备的输入法的（我看到 iPhone 上输入法已经切换），但在 Mac 上弹出的类似 HUD 的窗口竟然出现了一个 Sheet ？！\n\n![Screen Shot 2018-11-07 at 4.07.39 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8f3t1.png)\n\nWhat ？！！ 这种感觉就好像代码的某个位置接收到键盘 Caps Lock 事件时命名奇妙地执行了这样一段代码：\n\n```objective-c\nNSAlert *alert = [[NSAlert alloc] init];\nalert.alertStyle = NSAlertStyleInformational;\nalert.messageText = @\"Use the fn Key + media keys to control playback and volumn\";\n[alert beginSheetModalForWindow:window completionHandler:nil];\n```\n\n这个提示是好的，让我知道我还能通过 Fn + 的组合去调节移动设备的音量、亮度等。但不应该是以这种情况出现的。\n\n所以，很明显——这次的临床手术就是**找到这个 BUG 并解决它**。\n\n### 初探 1Keyboard\n\n我们知道 App 的执行代码最后都编译链接成一个二进制文件，而 1Keyboard 的二进制文件就是 1Keyboard.app/Contents/MacOS/1Keyboard 。绝大多数的操作都是对这个二进制文件进行的。\n\n了解一个软件，我们都需要从头文件开始做起。先看看软件中存在哪些类，类中都有些什么函数。这时候，我们第一个工具 class-dump 就起作用了。\n\n将 class-dump 放在与 App 放在同一个文件夹下，然后在终端执行命令，看看里面有哪些头文件：\n\n```shell\nclass-dump -H 1Keyboard.app/Contents/MacOS/1Keyboard -o ./Headers\n```\n\n运行结束后在当前目录中会有一个叫 Headers 的文件夹，里面就包含了 1Keyboard 的头文件。此时会看到，几十个头文件，密密麻麻不知道从何看起。\n\n### 第一次寻找突破点\n\n还记得前面的截图吗？！在出现问题的时候，我们使用的窗口是仅仅是类 HUD 的一个 Windows。那突破口应该就是一个 Controller 或者一个 Window 。在头文件里找，很快地找到一个疑似的 BoxViewController.h 。\n\n![Screen Shot 2018-11-08 at 11.44.52 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qcyfk.png)\n\n一个疑似的函数也出现了：`- (void)handleKeyboardEvent:(id)arg1`。感觉像是用来处理键盘事件的。\n\n找到点苗头，接下来就是看看函数实现能否印证我们的猜测。\n\n打开 Hopper Disassembler ，将 Macos 文件夹下的二进制文件拖入其中，会得到很多汇编代码，如下图：\n\n![Screen Shot 2018-11-08 at 11.56.02 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/w7f2s.png)\n\n汇编是低层的编程语言，写 C 时有可能会在函数中间插入一小段，还有使用 Xcode 调试的时候也经常能看到，但是没有深入的学习，是没法了解其中指令的含义，在本次逆向，我们就先忽略它们。\n\n左边栏的 Tag Scope 可以选择类，或者通过上方的搜索框，我们可以轻松地找到我们想要的 BoxViewController 。随即下方出现 BoxViewController 类中被实现的函数。同样，找到 `[BoxViewController handleKeyboardEvent:]` \n\n![Screen Shot 2018-11-08 at 12.03.21 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qeb6a.png)\n\n:[ 还是汇编代码。不过，我们可以通过\n\n![Screen Shot 2018-11-08 at 12.04.41 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8futb.png)\n\n第三个选项 if(b) f(x); 转换成伪代码，看起来就简单多了。\n\n![Screen Shot 2018-11-08 at 12.06.00 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jk2jy.png)\n\n一切都是这么顺利。但是到这里，我们发现：伪代码中只有一个 `if-else` ，判断条件是 event 的 keyCode 是否等于 0x35 。通过参考资料 1. NSEvent Code 可以得出，0x35 是 esc ，不是我们想要的 Caps Lock （0x39）。\n\n### 第二次寻找突破点\n\n回想起来，忽略了一点，既然 App 弹出提示，那为何不从提示文本入手呢？\n\n```\nUse the fn key + media keys to control playback and volumn.\n```\n\n对于没有做国际化的 App ，提示文本肯定是在实现文件内的，同样地，我们在 Hopper Disassembler 中看能否搜索到。这次不能搜索 Labels 了，要选择 str 选项。\n\n![Screen Shot 2018-11-08 at 2.48.00 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/xo66d.png)\n\n找到了我们要的结果，看右边，在地址处右键选择 References to 0x10001f3ed 。可以得到是哪个方法引用了这个字符串。我们得到的是\n\n```\nDATA XREF=-[BoxViewController mediaKeysPressed:]+102\n```\n\n继续深入，我们如法炮制，来看看 `mediaKeysPressed` 这个函数里面是什么。\n\n![Screen Shot 2018-11-08 at 2.55.46 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/c3z3h.png)\n\n1Keyboard 就是在这个方法中弹出框的，这也验证了一开始的猜想，在不知道什么情况下，执行了最上面说的那段类似的代码。\n\n然而，这个函数也只是做到弹框显示，没有什么对解决问题有用的信息。那我们就要来看看是哪里调用了这个函数。\n\n回到汇编代码这边来，在函数名称右键选择 References to selector mediaKeysPressed :\n\n![Screen Shot 2018-11-08 at 3.01.38 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rnxwk.png)\n\n会发现，我们去到 BoxViewController 的 `awakeFromNib`中。\n\n![Screen Shot 2018-11-08 at 3.06.48 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/o9rhm.png)\n\n`mediaKeysPressed` 原来是通知事件的 selector 。我们可以发现到后面的字符串  media_keys_pressed 。\n\n再重复上面的操作，最后可以找到 MyNSApplication 的 `sendEvent:`方法。\n\n![Screen Shot 2018-11-08 at 3.14.29 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/irvtr.png)\n\n乍一看觉得很熟悉，查阅了文档知道是 NSApplication 用于分发事件的， 1Keyboard 重写了这个方法，那现在问题很明确，我们按下 Caps Lock 的时候，进入到这个方法中了。\n\n本着科学的无限探索精神，我想弄清楚：为什么要重写？怎么解决我们要解决的问题？\n\n### 问题思考\n\n首先，对几个问题的思考：\n\nQ：什么是 Media Key？\n\nA：就是这几个键。![Screen Shot 2018-11-08 at 3.28.42 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3fclz.png)\n\nQ：为什么要重写`sendEvent:`？\n\nA：这个问题个人觉得与 1Keyboard 的设计初衷有关系，从方法名、Notification Name 我们可以得知，1Keyboard 是想在 macOS 上实现对移动设备播放、暂停、调节亮度、音量等多媒体操作的控制。对于有 Media Key 的键盘，自然就需要增加对 Media Key 的支持。监测 Media Key 的`KeyDown` 和`KeyUp`最常见的方式就是重写 `sendEvent:`。\n\n如上面代码中所示：\n\n```objective-c\nif (([rbx type] == 0xe) && (([rbx subtype] & 0xffff) == 0x8))\n```\n\n`rbx `是 `[arg2 retain]` ，理所当然是一个 `NSEvent` Object 。当 `[rbx type]` 是 `NSEventTypeSystemDefined`（14）且  `[rbx subtype]` 是 8 的时候，就当做是一个  Media Key 的事件，可以借鉴参考资料给出的 2.获取MediaKey的开源Lib——SPMediaKeyTap 。\n\n然后，第二个判断条件：\n\n```objective-c\nif ([rbx data1] & 0xff00) != 0xa00)\n```\n\n成立是指按键被按下，即 KeyDown 。\n\n 1Keyboard 设计的初衷和出发点是好的，但是在`sendEvent:`中没有对 Event 的 keyCode进行判断，导致问题的出现。\n\n### 寻找解决方法\n\n稍微停一下，我们在这里重整一下思路，一开始通过查找字符串，得到 selector ，然后通过引用关系，找到 NSApplication 中的 `sendEvent` 中通知的发起点，并知道了 BUG 发生的原因，没有判断 event 的 keyCode。\n\n那好了，现在有两种解决方式：\n\n1. 在发送 media_keys_pressed 通知之前判断 event 的 keyCode 是否为 0x39 ，若是，则不发送通知。\n2. 去掉`[postNotificationName:object:]`，不再发送通知。\n\n第一种会影响整个二进制文件，添加的代码后面所有属性和函数的地址都需要修改；第二种直接覆盖原有地址的汇编，对原来二进制文件影响小，但是不会再弹出提示框。\n\n对于我这个新手来说，第二种方法虽然没有第一种高级，但至少省下时间，且提示框也不影响平时的使用。\n\n所以，剩下最后一步：将`[postNotificationName:object:]`的汇编码变成无作为。\n\n这时候就需要用到 lldb 了，实际上，用 Hopper Disassembler 是可以直接修改的，只是需要购买 license 。我使用的是试用版，没有修改二进制文件的功能。其实用 gdb 也可以，现在搜到的大多数文章也是用 gdb 来调试程序，但既然在 macOS 上，安装了 Xcode 就有了lldb ，且可以免去 gdb codesign 的烦恼。\n\n好啦，接下来，我们用 lldb 来完成剩下的工作：\n\n1. 找到调用语句。\n2. 使用 NOP 替换掉它。\n\n先使 lldb 进入调试模式：\n\n```shell\nlldb 1Keyboard.app/Contents/MacOS/1Keyboard\n```\n\nlldb 有个 disassemble 指令，可以通过它来看到一个区间内的地址指令情况：\n\n```shell\n(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n1Keyboard[0x10000a541] <+103>: movq   0x2ba00(%rip), %rdi       ; (void *)0x0000000000000000\n1Keyboard[0x10000a548] <+110>: movq   0x2a919(%rip), %rsi       ; \"defaultCenter\"\n1Keyboard[0x10000a54f] <+117>: movq   0x20bfa(%rip), %r15       ; (void *)0x0000000000000000\n1Keyboard[0x10000a556] <+124>: callq  *%r15\n1Keyboard[0x10000a559] <+127>: movq   %rax, %rdi\n1Keyboard[0x10000a55c] <+130>: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n1Keyboard[0x10000a561] <+135>: movq   %rax, %r14\n1Keyboard[0x10000a564] <+138>: movq   0x2af95(%rip), %rsi       ; \"postNotificationName:object:\"\n1Keyboard[0x10000a56b] <+145>: leaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n1Keyboard[0x10000a572] <+152>: xorl   %ecx, %ecx\n1Keyboard[0x10000a574] <+154>: movq   %r14, %rdi\n1Keyboard[0x10000a577] <+157>: callq  *%r15\n1Keyboard[0x10000a57a] <+160>: movq   %r14, %rdi\n1Keyboard[0x10000a57d] <+163>: callq  0x100019af8               ; symbol stub for: objc_release\n```\n\nlldb 的指令如无歧义，可以进行缩写，如 **p**rint **o**bject 可以缩写成 po 。disassemble 也可以缩写成 di 。-s 是起始地址，-e 是结束地址。\n\n肯定有人要问：000000010000a541 和 000000010000a582 是怎么得来的？\n\n那就要回到 Hopper Disassembler 了。\n\n记得前面我们看过 `[sendEvent:]`的伪代码，我们还可以看到它的汇编代码的不是吗？只需要点击 mov add 按钮就可以了。可以看到起始地址和结束地址了吧。\n\n![Screen Shot 2018-11-09 at 11.03.14 AM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j7fmb.png)\n\n我们都知道 OC 使用消息传递，用 objc_msgSend 来充当函数调用。需要有消息发送者和参数。\n\n分析一下这段输出，首先我们很快找到 `postNotificationName:object:` ：\n\n```shell\nmovq   0x2af95(%rip), %rsi\t\t ; \"postNotificationName:object:\"\n```\n\n在汇编代码中 % 前缀的是指寄存器。`movq (%ebx), %edx` 是指64位间接寻址，因此，这个指令应该是去找 selector 的地址。\n\n```shell\nleaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n```\n\n这个很明显：找到 @\"media_keys_pressed\" 这个字符串。\n\n```shell\nmovq   %r14, %rdi\n```\n\n这个是找调用 `postNotificationName:object:` 的对象，也就是 NotificationCenter 。\n\n最后，通过 `callq` 来进行调用：\n\n```\ncallq  *%r15\n```\n\n至此，调用语句已经找到了，接下来就是使用 NOP 来替换它。\n\n> NOP 是什么？\n>\n> 计算机科学中，NOP 或 NOOP 是汇编语言的一个指令，一系列编程语句，或网络传输协议中的表示不做任何有效操作的命令。\n>\n> NOP 的值是 0x90 ，占用一个字节。\n\n首先，要设置断点，让程序在某个位置停下来，方便我们修改指令调试：\n\n```shell\n(lldb) breakpoint set -n \"[MyNSApplication sendEvent:]\"\n(lldb) r\n```\n\nr 是让程序开始运行，按照之前，我们连接手机，按下任意键，会触发断点。此时 lldb 会停下来等待我们进一步的输入。\n\n从上面可以知道，我们要修改的指令是：\n\n```shell\n1Keyboard[0x10000a577] <+157>: callq  *%r15\n1Keyboard[0x10000a57a] <+160>: movq   %r14, %rdi\n```\n\n指令在内存中的起始地址是 `0x10000a577`，需要注意的是：下一条指令起始地址是 `0x10000a57a`。也就是说，我们要修改的指令占据了三个 Byte 。而一个 NOP 只是一个 Byte 。所以我们要将 `callq  *%r15` 替换成三个 NOP ：\n\n```shell\n(lldb) memory write -f x 0x10000a577 0x90\n(lldb) memory write -f x 0x10000a578 0x90\n(lldb) memory write -f x 0x10000a579 0x90\n```\n\n使用 `memory write` 可以达到 gdb 中 `set` 的效果。然后我们再 disassemble 一次：\n\n```shell\n(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n    0x10000a541 <+103>: movq   0x2ba00(%rip), %rdi       ; (void *)0x00007fffa62b49d8: NSNotificationCenter\n    0x10000a548 <+110>: movq   0x2a919(%rip), %rsi       ; \"defaultCenter\"\n    0x10000a54f <+117>: movq   0x20bfa(%rip), %r15       ; (void *)0x00007fff7a0d1a00: objc_msgSend\n    0x10000a556 <+124>: callq  *%r15\n    0x10000a559 <+127>: movq   %rax, %rdi\n    0x10000a55c <+130>: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n    0x10000a561 <+135>: movq   %rax, %r14\n    0x10000a564 <+138>: movq   0x2af95(%rip), %rsi       ; \"postNotificationName:object:\"\n    0x10000a56b <+145>: leaq   0x2184e(%rip), %rdx       ; @\"media_keys_pressed\"\n    0x10000a572 <+152>: xorl   %ecx, %ecx\n    0x10000a574 <+154>: movq   %r14, %rdi\n    0x10000a577 <+157>: nop\n    0x10000a578 <+158>: nop\n    0x10000a579 <+159>: nop\n    0x10000a57a <+160>: movq   %r14, %rdi\n    0x10000a57d <+163>: callq  0x100019af8               ; symbol stub for: objc_release\n```\n\n如我们所愿，已经改好了。在终端输入 `c` ，让程序继续运行，这时会发现，按下 Caps Lock已经不会再弹出那个厌烦的 Sheet 了。\n\n到这里，已经完成大部分了，lldb 只是一个调试工具，并不能做到修改二进制文件的功能，所以要将修改长效地保存下来，就需要对原二进制文件进行修改。我们就必须先找到 `0x10000a577` 起始的三个 Byte 的二进制代码是什么。\n\n因为我们已经修改过内存中的程序，所以需要先将 lldb 退出，重新加载原来的程序，再使用 `x/x` 指令：\n\n```shell\n(lldb) x/x 0x10000a577\n0x10000a577: 0x4cd7ff41\n(lldb) x/x 0x10000a578\n0x10000a578: 0x894cd7ff\n(lldb) x/x 0x10000a579\n0x10000a579: 0xf7894cd7\n```\n\n我们发现，这三个地址都有部分是重合的，不是巧合，不同的指令拥有不同的二进制编码，`x/x` 指令总是读取相同长度的内存中的数据。因此我们要将相同的合在一起。\n\n还需要注意的是：\n\n> **字节序问题（ Byte Order ）**，Intel 处理器一般是以**小端（ Little endian ）**进行存储，而在硬盘上的二进制码，则是以**大端（ Big endian ）**存储。所谓的**大端**，就是把数字的最高位放在最前面，**小端**则是把最高位放在最后面。\n>\n> ——摘自参考资料 5.一个数字的魔法——破解Mac上198元的Paw\n\n所以，三者的二进制代码组合起来就是：`41 FF D7 4C 89 F7` 。\n\n打开 Hex Fiend 。将二进制文件拖入其中，搜索 `41 FF D7 4C 89 F7` ，仔细发现，可以搜索出来三个，在不确定是哪个的情况下，我们可以继续对后面的指令再 `x/x` 。组合更多的 Byte 提高搜索精确度。\n\n再选两个指令：\n\n```\n(lldb) x/x 0x10000a57a\n0x10000a57a: 0xe8f7894c\n(lldb) x/x 0x10000a57b\n0x10000a57b: 0x76e8f789\n```\n\n好了，我们的搜索组合现在变成：`41 FF D7 4C 89 F7 E8 76`。这样就有且仅有一个结果了：\n\n![Screen Shot 2018-11-09 at 1.24.40 PM](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkugc.png)\n\n还记得我们要替换为三位 NOP 吗？将 `90 90 90 4C 89 F7 E8 76` 填入到 Replace 中。再选择 Replace & Find 就可以了。\n\n至此，就完成了整个问题的修复。可以 lldb 打开调试看看有没有问题。直接通过双击 1Keyboard.app 是无法打开的，是因为我们修改了 app 中的文件，App 签名已经无法验证通过了。需要进行代码重签：具体可以看我之前的这篇文章。\n\n然后就可以愉快地玩耍了~ \n\n\n\n## 最后说两句\n\n我是在看别人的优秀文章的时候学习了一点点逆向工程的皮毛。第一次接触逆向工程，很多地方写的不好，肯定有错误的地方，对上述操作手动表示滑稽，还请不吝指正。\n\n另外，推荐两篇延伸阅读，请见参考资料 5.6. 。\n\n\n\n## 参考资料\n\n[1. NSEvent KeyCode](https://forums.macrumors.com/threads/nsevent-keycode-list.780577/)\n\n[2.获取MediaKey的开源Lib——SPMediaKeyTap](https://github.com/nevyn/SPMediaKeyTap)\n\n[3.SPMediaKeyTap作者对Media Key处理方式的解释](http://overooped.com/post/2593597587/mediakeys)\n\n[4.GDB - To - LLDB](http://lldb.llvm.org/lldb-gdb.html)\n\n[5.一个数字的魔法——破解Mac上198元的Paw](https://bestswifter.com/app-crack/)\n\n[6.饿了么安全：Mac 下的破解软件真的安全吗？](https://juejin.im/entry/598d53155188257c666c5943)","slug":"逆向修复软件的BUG","published":1,"updated":"2018-11-09T06:01:42.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6e0000nqu0xsuufiown","content":"<p>事实上，我也没想过会是以这种形式接触逆向工程，我甚至不知道这样是不是就叫逆向工程，事情的起因就只是想省下一笔买蓝牙键盘的钱，惭愧。</p>\n<a id=\"more\"></a>\n<h2 id=\"背景与目的\"><a href=\"#背景与目的\" class=\"headerlink\" title=\"背景与目的\"></a>背景与目的</h2><p>对全面屏 iPad Pro 的青睐已久，在今年 10 月 30 号 发布之后就剁手买了一个。不想买配套键盘，一是觉得与 iPad 的设计初衷向违背，移动办公不想多个累赘的键盘；二是一千三百多大洋着实让我望而却步，感觉不是很值得吧。而且平时用 iPad 也没用键盘，小部分时候确实不方便。今天看着电脑键盘突然想到，能不能通过 Mac 来连接 iPad ，充当 iPad 的键盘呢？</p>\n<p>起初想学学自己写个 Mac 端的 App ，发现成本略高，遂转去寻找市面上是否有满足的 App。发现了一款：1Keyboard 。不过很久没更新，上一次已是 2016 年。看了 App Store，68 大洋。</p>\n<p>使用的过程中，我发现了一个可能是 BUG 的无脑设定，十分影响使用，所以寻思着看看能否自己解决，于是我要对 1Keyboard 开刀了。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><p>class-dump —— 导出一个二进制文件的头文件等信息。</p>\n</li>\n<li><p>Hopper Disassembler —— 反汇编分析工具。</p>\n</li>\n<li><p>lldb —— Xcode 自带的调试器。</p>\n</li>\n<li><p>Hex fiend —— 二进制文件编辑器。</p>\n</li>\n</ul>\n<h2 id=\"开刀\"><a href=\"#开刀\" class=\"headerlink\" title=\"开刀\"></a>开刀</h2><h3 id=\"为什么要开刀\"><a href=\"#为什么要开刀\" class=\"headerlink\" title=\"为什么要开刀\"></a>为什么要开刀</h3><p>正如医生对症下刀一样，病人接受临床手术必定是身体机能有问题。 1Keyboard 的问题在于：一个可能是 BUG 的无脑设定。</p>\n<p>实话，第一次的尝试『 macOS 10.14 连接 iOS 12.1 ( iPhone ) 』给我留下的印象还是很好的，输入的东西很快地在我的手机上显示出来，时延低。但是我在 Mac 上码字习惯用 Caps Lock 来切换输入法，事实上，1Keyboard 应该也是支持 Caps Lock 来更换移动设备的输入法的（我看到 iPhone 上输入法已经切换），但在 Mac 上弹出的类似 HUD 的窗口竟然出现了一个 Sheet ？！</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8f3t1.png\" alt=\"Screen Shot 2018-11-07 at 4.07.39 PM\"></p>\n<p>What ？！！ 这种感觉就好像代码的某个位置接收到键盘 Caps Lock 事件时命名奇妙地执行了这样一段代码：</p>\n<pre><code class=\"objective-c\">NSAlert *alert = [[NSAlert alloc] init];\nalert.alertStyle = NSAlertStyleInformational;\nalert.messageText = @&quot;Use the fn Key + media keys to control playback and volumn&quot;;\n[alert beginSheetModalForWindow:window completionHandler:nil];\n</code></pre>\n<p>这个提示是好的，让我知道我还能通过 Fn + 的组合去调节移动设备的音量、亮度等。但不应该是以这种情况出现的。</p>\n<p>所以，很明显——这次的临床手术就是<strong>找到这个 BUG 并解决它</strong>。</p>\n<h3 id=\"初探-1Keyboard\"><a href=\"#初探-1Keyboard\" class=\"headerlink\" title=\"初探 1Keyboard\"></a>初探 1Keyboard</h3><p>我们知道 App 的执行代码最后都编译链接成一个二进制文件，而 1Keyboard 的二进制文件就是 1Keyboard.app/Contents/MacOS/1Keyboard 。绝大多数的操作都是对这个二进制文件进行的。</p>\n<p>了解一个软件，我们都需要从头文件开始做起。先看看软件中存在哪些类，类中都有些什么函数。这时候，我们第一个工具 class-dump 就起作用了。</p>\n<p>将 class-dump 放在与 App 放在同一个文件夹下，然后在终端执行命令，看看里面有哪些头文件：</p>\n<pre><code class=\"shell\">class-dump -H 1Keyboard.app/Contents/MacOS/1Keyboard -o ./Headers\n</code></pre>\n<p>运行结束后在当前目录中会有一个叫 Headers 的文件夹，里面就包含了 1Keyboard 的头文件。此时会看到，几十个头文件，密密麻麻不知道从何看起。</p>\n<h3 id=\"第一次寻找突破点\"><a href=\"#第一次寻找突破点\" class=\"headerlink\" title=\"第一次寻找突破点\"></a>第一次寻找突破点</h3><p>还记得前面的截图吗？！在出现问题的时候，我们使用的窗口是仅仅是类 HUD 的一个 Windows。那突破口应该就是一个 Controller 或者一个 Window 。在头文件里找，很快地找到一个疑似的 BoxViewController.h 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qcyfk.png\" alt=\"Screen Shot 2018-11-08 at 11.44.52 AM\"></p>\n<p>一个疑似的函数也出现了：<code>- (void)handleKeyboardEvent:(id)arg1</code>。感觉像是用来处理键盘事件的。</p>\n<p>找到点苗头，接下来就是看看函数实现能否印证我们的猜测。</p>\n<p>打开 Hopper Disassembler ，将 Macos 文件夹下的二进制文件拖入其中，会得到很多汇编代码，如下图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/w7f2s.png\" alt=\"Screen Shot 2018-11-08 at 11.56.02 AM\"></p>\n<p>汇编是低层的编程语言，写 C 时有可能会在函数中间插入一小段，还有使用 Xcode 调试的时候也经常能看到，但是没有深入的学习，是没法了解其中指令的含义，在本次逆向，我们就先忽略它们。</p>\n<p>左边栏的 Tag Scope 可以选择类，或者通过上方的搜索框，我们可以轻松地找到我们想要的 BoxViewController 。随即下方出现 BoxViewController 类中被实现的函数。同样，找到 <code>[BoxViewController handleKeyboardEvent:]</code> </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qeb6a.png\" alt=\"Screen Shot 2018-11-08 at 12.03.21 PM\"></p>\n<p>:[ 还是汇编代码。不过，我们可以通过</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8futb.png\" alt=\"Screen Shot 2018-11-08 at 12.04.41 PM\"></p>\n<p>第三个选项 if(b) f(x); 转换成伪代码，看起来就简单多了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jk2jy.png\" alt=\"Screen Shot 2018-11-08 at 12.06.00 PM\"></p>\n<p>一切都是这么顺利。但是到这里，我们发现：伪代码中只有一个 <code>if-else</code> ，判断条件是 event 的 keyCode 是否等于 0x35 。通过参考资料 1. NSEvent Code 可以得出，0x35 是 esc ，不是我们想要的 Caps Lock （0x39）。</p>\n<h3 id=\"第二次寻找突破点\"><a href=\"#第二次寻找突破点\" class=\"headerlink\" title=\"第二次寻找突破点\"></a>第二次寻找突破点</h3><p>回想起来，忽略了一点，既然 App 弹出提示，那为何不从提示文本入手呢？</p>\n<pre><code>Use the fn key + media keys to control playback and volumn.\n</code></pre><p>对于没有做国际化的 App ，提示文本肯定是在实现文件内的，同样地，我们在 Hopper Disassembler 中看能否搜索到。这次不能搜索 Labels 了，要选择 str 选项。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/xo66d.png\" alt=\"Screen Shot 2018-11-08 at 2.48.00 PM\"></p>\n<p>找到了我们要的结果，看右边，在地址处右键选择 References to 0x10001f3ed 。可以得到是哪个方法引用了这个字符串。我们得到的是</p>\n<pre><code>DATA XREF=-[BoxViewController mediaKeysPressed:]+102\n</code></pre><p>继续深入，我们如法炮制，来看看 <code>mediaKeysPressed</code> 这个函数里面是什么。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/c3z3h.png\" alt=\"Screen Shot 2018-11-08 at 2.55.46 PM\"></p>\n<p>1Keyboard 就是在这个方法中弹出框的，这也验证了一开始的猜想，在不知道什么情况下，执行了最上面说的那段类似的代码。</p>\n<p>然而，这个函数也只是做到弹框显示，没有什么对解决问题有用的信息。那我们就要来看看是哪里调用了这个函数。</p>\n<p>回到汇编代码这边来，在函数名称右键选择 References to selector mediaKeysPressed :</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rnxwk.png\" alt=\"Screen Shot 2018-11-08 at 3.01.38 PM\"></p>\n<p>会发现，我们去到 BoxViewController 的 <code>awakeFromNib</code>中。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/o9rhm.png\" alt=\"Screen Shot 2018-11-08 at 3.06.48 PM\"></p>\n<p><code>mediaKeysPressed</code> 原来是通知事件的 selector 。我们可以发现到后面的字符串  media_keys_pressed 。</p>\n<p>再重复上面的操作，最后可以找到 MyNSApplication 的 <code>sendEvent:</code>方法。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/irvtr.png\" alt=\"Screen Shot 2018-11-08 at 3.14.29 PM\"></p>\n<p>乍一看觉得很熟悉，查阅了文档知道是 NSApplication 用于分发事件的， 1Keyboard 重写了这个方法，那现在问题很明确，我们按下 Caps Lock 的时候，进入到这个方法中了。</p>\n<p>本着科学的无限探索精神，我想弄清楚：为什么要重写？怎么解决我们要解决的问题？</p>\n<h3 id=\"问题思考\"><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h3><p>首先，对几个问题的思考：</p>\n<p>Q：什么是 Media Key？</p>\n<p>A：就是这几个键。<img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3fclz.png\" alt=\"Screen Shot 2018-11-08 at 3.28.42 PM\"></p>\n<p>Q：为什么要重写<code>sendEvent:</code>？</p>\n<p>A：这个问题个人觉得与 1Keyboard 的设计初衷有关系，从方法名、Notification Name 我们可以得知，1Keyboard 是想在 macOS 上实现对移动设备播放、暂停、调节亮度、音量等多媒体操作的控制。对于有 Media Key 的键盘，自然就需要增加对 Media Key 的支持。监测 Media Key 的<code>KeyDown</code> 和<code>KeyUp</code>最常见的方式就是重写 <code>sendEvent:</code>。</p>\n<p>如上面代码中所示：</p>\n<pre><code class=\"objective-c\">if (([rbx type] == 0xe) &amp;&amp; (([rbx subtype] &amp; 0xffff) == 0x8))\n</code></pre>\n<p><code>rbx</code>是 <code>[arg2 retain]</code> ，理所当然是一个 <code>NSEvent</code> Object 。当 <code>[rbx type]</code> 是 <code>NSEventTypeSystemDefined</code>（14）且  <code>[rbx subtype]</code> 是 8 的时候，就当做是一个  Media Key 的事件，可以借鉴参考资料给出的 2.获取MediaKey的开源Lib——SPMediaKeyTap 。</p>\n<p>然后，第二个判断条件：</p>\n<pre><code class=\"objective-c\">if ([rbx data1] &amp; 0xff00) != 0xa00)\n</code></pre>\n<p>成立是指按键被按下，即 KeyDown 。</p>\n<p> 1Keyboard 设计的初衷和出发点是好的，但是在<code>sendEvent:</code>中没有对 Event 的 keyCode进行判断，导致问题的出现。</p>\n<h3 id=\"寻找解决方法\"><a href=\"#寻找解决方法\" class=\"headerlink\" title=\"寻找解决方法\"></a>寻找解决方法</h3><p>稍微停一下，我们在这里重整一下思路，一开始通过查找字符串，得到 selector ，然后通过引用关系，找到 NSApplication 中的 <code>sendEvent</code> 中通知的发起点，并知道了 BUG 发生的原因，没有判断 event 的 keyCode。</p>\n<p>那好了，现在有两种解决方式：</p>\n<ol>\n<li>在发送 media_keys_pressed 通知之前判断 event 的 keyCode 是否为 0x39 ，若是，则不发送通知。</li>\n<li>去掉<code>[postNotificationName:object:]</code>，不再发送通知。</li>\n</ol>\n<p>第一种会影响整个二进制文件，添加的代码后面所有属性和函数的地址都需要修改；第二种直接覆盖原有地址的汇编，对原来二进制文件影响小，但是不会再弹出提示框。</p>\n<p>对于我这个新手来说，第二种方法虽然没有第一种高级，但至少省下时间，且提示框也不影响平时的使用。</p>\n<p>所以，剩下最后一步：将<code>[postNotificationName:object:]</code>的汇编码变成无作为。</p>\n<p>这时候就需要用到 lldb 了，实际上，用 Hopper Disassembler 是可以直接修改的，只是需要购买 license 。我使用的是试用版，没有修改二进制文件的功能。其实用 gdb 也可以，现在搜到的大多数文章也是用 gdb 来调试程序，但既然在 macOS 上，安装了 Xcode 就有了lldb ，且可以免去 gdb codesign 的烦恼。</p>\n<p>好啦，接下来，我们用 lldb 来完成剩下的工作：</p>\n<ol>\n<li>找到调用语句。</li>\n<li>使用 NOP 替换掉它。</li>\n</ol>\n<p>先使 lldb 进入调试模式：</p>\n<pre><code class=\"shell\">lldb 1Keyboard.app/Contents/MacOS/1Keyboard\n</code></pre>\n<p>lldb 有个 disassemble 指令，可以通过它来看到一个区间内的地址指令情况：</p>\n<pre><code class=\"shell\">(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n1Keyboard[0x10000a541] &lt;+103&gt;: movq   0x2ba00(%rip), %rdi       ; (void *)0x0000000000000000\n1Keyboard[0x10000a548] &lt;+110&gt;: movq   0x2a919(%rip), %rsi       ; &quot;defaultCenter&quot;\n1Keyboard[0x10000a54f] &lt;+117&gt;: movq   0x20bfa(%rip), %r15       ; (void *)0x0000000000000000\n1Keyboard[0x10000a556] &lt;+124&gt;: callq  *%r15\n1Keyboard[0x10000a559] &lt;+127&gt;: movq   %rax, %rdi\n1Keyboard[0x10000a55c] &lt;+130&gt;: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n1Keyboard[0x10000a561] &lt;+135&gt;: movq   %rax, %r14\n1Keyboard[0x10000a564] &lt;+138&gt;: movq   0x2af95(%rip), %rsi       ; &quot;postNotificationName:object:&quot;\n1Keyboard[0x10000a56b] &lt;+145&gt;: leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n1Keyboard[0x10000a572] &lt;+152&gt;: xorl   %ecx, %ecx\n1Keyboard[0x10000a574] &lt;+154&gt;: movq   %r14, %rdi\n1Keyboard[0x10000a577] &lt;+157&gt;: callq  *%r15\n1Keyboard[0x10000a57a] &lt;+160&gt;: movq   %r14, %rdi\n1Keyboard[0x10000a57d] &lt;+163&gt;: callq  0x100019af8               ; symbol stub for: objc_release\n</code></pre>\n<p>lldb 的指令如无歧义，可以进行缩写，如 <strong>p</strong>rint <strong>o</strong>bject 可以缩写成 po 。disassemble 也可以缩写成 di 。-s 是起始地址，-e 是结束地址。</p>\n<p>肯定有人要问：000000010000a541 和 000000010000a582 是怎么得来的？</p>\n<p>那就要回到 Hopper Disassembler 了。</p>\n<p>记得前面我们看过 <code>[sendEvent:]</code>的伪代码，我们还可以看到它的汇编代码的不是吗？只需要点击 mov add 按钮就可以了。可以看到起始地址和结束地址了吧。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j7fmb.png\" alt=\"Screen Shot 2018-11-09 at 11.03.14 AM\"></p>\n<p>我们都知道 OC 使用消息传递，用 objc_msgSend 来充当函数调用。需要有消息发送者和参数。</p>\n<p>分析一下这段输出，首先我们很快找到 <code>postNotificationName:object:</code> ：</p>\n<pre><code class=\"shell\">movq   0x2af95(%rip), %rsi         ; &quot;postNotificationName:object:&quot;\n</code></pre>\n<p>在汇编代码中 % 前缀的是指寄存器。<code>movq (%ebx), %edx</code> 是指64位间接寻址，因此，这个指令应该是去找 selector 的地址。</p>\n<pre><code class=\"shell\">leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n</code></pre>\n<p>这个很明显：找到 @”media_keys_pressed” 这个字符串。</p>\n<pre><code class=\"shell\">movq   %r14, %rdi\n</code></pre>\n<p>这个是找调用 <code>postNotificationName:object:</code> 的对象，也就是 NotificationCenter 。</p>\n<p>最后，通过 <code>callq</code> 来进行调用：</p>\n<pre><code>callq  *%r15\n</code></pre><p>至此，调用语句已经找到了，接下来就是使用 NOP 来替换它。</p>\n<blockquote>\n<p>NOP 是什么？</p>\n<p>计算机科学中，NOP 或 NOOP 是汇编语言的一个指令，一系列编程语句，或网络传输协议中的表示不做任何有效操作的命令。</p>\n<p>NOP 的值是 0x90 ，占用一个字节。</p>\n</blockquote>\n<p>首先，要设置断点，让程序在某个位置停下来，方便我们修改指令调试：</p>\n<pre><code class=\"shell\">(lldb) breakpoint set -n &quot;[MyNSApplication sendEvent:]&quot;\n(lldb) r\n</code></pre>\n<p>r 是让程序开始运行，按照之前，我们连接手机，按下任意键，会触发断点。此时 lldb 会停下来等待我们进一步的输入。</p>\n<p>从上面可以知道，我们要修改的指令是：</p>\n<pre><code class=\"shell\">1Keyboard[0x10000a577] &lt;+157&gt;: callq  *%r15\n1Keyboard[0x10000a57a] &lt;+160&gt;: movq   %r14, %rdi\n</code></pre>\n<p>指令在内存中的起始地址是 <code>0x10000a577</code>，需要注意的是：下一条指令起始地址是 <code>0x10000a57a</code>。也就是说，我们要修改的指令占据了三个 Byte 。而一个 NOP 只是一个 Byte 。所以我们要将 <code>callq  *%r15</code> 替换成三个 NOP ：</p>\n<pre><code class=\"shell\">(lldb) memory write -f x 0x10000a577 0x90\n(lldb) memory write -f x 0x10000a578 0x90\n(lldb) memory write -f x 0x10000a579 0x90\n</code></pre>\n<p>使用 <code>memory write</code> 可以达到 gdb 中 <code>set</code> 的效果。然后我们再 disassemble 一次：</p>\n<pre><code class=\"shell\">(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n    0x10000a541 &lt;+103&gt;: movq   0x2ba00(%rip), %rdi       ; (void *)0x00007fffa62b49d8: NSNotificationCenter\n    0x10000a548 &lt;+110&gt;: movq   0x2a919(%rip), %rsi       ; &quot;defaultCenter&quot;\n    0x10000a54f &lt;+117&gt;: movq   0x20bfa(%rip), %r15       ; (void *)0x00007fff7a0d1a00: objc_msgSend\n    0x10000a556 &lt;+124&gt;: callq  *%r15\n    0x10000a559 &lt;+127&gt;: movq   %rax, %rdi\n    0x10000a55c &lt;+130&gt;: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n    0x10000a561 &lt;+135&gt;: movq   %rax, %r14\n    0x10000a564 &lt;+138&gt;: movq   0x2af95(%rip), %rsi       ; &quot;postNotificationName:object:&quot;\n    0x10000a56b &lt;+145&gt;: leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n    0x10000a572 &lt;+152&gt;: xorl   %ecx, %ecx\n    0x10000a574 &lt;+154&gt;: movq   %r14, %rdi\n    0x10000a577 &lt;+157&gt;: nop\n    0x10000a578 &lt;+158&gt;: nop\n    0x10000a579 &lt;+159&gt;: nop\n    0x10000a57a &lt;+160&gt;: movq   %r14, %rdi\n    0x10000a57d &lt;+163&gt;: callq  0x100019af8               ; symbol stub for: objc_release\n</code></pre>\n<p>如我们所愿，已经改好了。在终端输入 <code>c</code> ，让程序继续运行，这时会发现，按下 Caps Lock已经不会再弹出那个厌烦的 Sheet 了。</p>\n<p>到这里，已经完成大部分了，lldb 只是一个调试工具，并不能做到修改二进制文件的功能，所以要将修改长效地保存下来，就需要对原二进制文件进行修改。我们就必须先找到 <code>0x10000a577</code> 起始的三个 Byte 的二进制代码是什么。</p>\n<p>因为我们已经修改过内存中的程序，所以需要先将 lldb 退出，重新加载原来的程序，再使用 <code>x/x</code> 指令：</p>\n<pre><code class=\"shell\">(lldb) x/x 0x10000a577\n0x10000a577: 0x4cd7ff41\n(lldb) x/x 0x10000a578\n0x10000a578: 0x894cd7ff\n(lldb) x/x 0x10000a579\n0x10000a579: 0xf7894cd7\n</code></pre>\n<p>我们发现，这三个地址都有部分是重合的，不是巧合，不同的指令拥有不同的二进制编码，<code>x/x</code> 指令总是读取相同长度的内存中的数据。因此我们要将相同的合在一起。</p>\n<p>还需要注意的是：</p>\n<blockquote>\n<p><strong>字节序问题（ Byte Order ）</strong>，Intel 处理器一般是以<strong>小端（ Little endian ）</strong>进行存储，而在硬盘上的二进制码，则是以<strong>大端（ Big endian ）</strong>存储。所谓的<strong>大端</strong>，就是把数字的最高位放在最前面，<strong>小端</strong>则是把最高位放在最后面。</p>\n<p>——摘自参考资料 5.一个数字的魔法——破解Mac上198元的Paw</p>\n</blockquote>\n<p>所以，三者的二进制代码组合起来就是：<code>41 FF D7 4C 89 F7</code> 。</p>\n<p>打开 Hex Fiend 。将二进制文件拖入其中，搜索 <code>41 FF D7 4C 89 F7</code> ，仔细发现，可以搜索出来三个，在不确定是哪个的情况下，我们可以继续对后面的指令再 <code>x/x</code> 。组合更多的 Byte 提高搜索精确度。</p>\n<p>再选两个指令：</p>\n<pre><code>(lldb) x/x 0x10000a57a\n0x10000a57a: 0xe8f7894c\n(lldb) x/x 0x10000a57b\n0x10000a57b: 0x76e8f789\n</code></pre><p>好了，我们的搜索组合现在变成：<code>41 FF D7 4C 89 F7 E8 76</code>。这样就有且仅有一个结果了：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkugc.png\" alt=\"Screen Shot 2018-11-09 at 1.24.40 PM\"></p>\n<p>还记得我们要替换为三位 NOP 吗？将 <code>90 90 90 4C 89 F7 E8 76</code> 填入到 Replace 中。再选择 Replace &amp; Find 就可以了。</p>\n<p>至此，就完成了整个问题的修复。可以 lldb 打开调试看看有没有问题。直接通过双击 1Keyboard.app 是无法打开的，是因为我们修改了 app 中的文件，App 签名已经无法验证通过了。需要进行代码重签：具体可以看我之前的这篇文章。</p>\n<p>然后就可以愉快地玩耍了~ </p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>我是在看别人的优秀文章的时候学习了一点点逆向工程的皮毛。第一次接触逆向工程，很多地方写的不好，肯定有错误的地方，对上述操作手动表示滑稽，还请不吝指正。</p>\n<p>另外，推荐两篇延伸阅读，请见参考资料 5.6. 。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://forums.macrumors.com/threads/nsevent-keycode-list.780577/\" target=\"_blank\" rel=\"external\">1. NSEvent KeyCode</a></p>\n<p><a href=\"https://github.com/nevyn/SPMediaKeyTap\" target=\"_blank\" rel=\"external\">2.获取MediaKey的开源Lib——SPMediaKeyTap</a></p>\n<p><a href=\"http://overooped.com/post/2593597587/mediakeys\" target=\"_blank\" rel=\"external\">3.SPMediaKeyTap作者对Media Key处理方式的解释</a></p>\n<p><a href=\"http://lldb.llvm.org/lldb-gdb.html\" target=\"_blank\" rel=\"external\">4.GDB - To - LLDB</a></p>\n<p><a href=\"https://bestswifter.com/app-crack/\" target=\"_blank\" rel=\"external\">5.一个数字的魔法——破解Mac上198元的Paw</a></p>\n<p><a href=\"https://juejin.im/entry/598d53155188257c666c5943\" target=\"_blank\" rel=\"external\">6.饿了么安全：Mac 下的破解软件真的安全吗？</a></p>\n","excerpt":"<p>事实上，我也没想过会是以这种形式接触逆向工程，我甚至不知道这样是不是就叫逆向工程，事情的起因就只是想省下一笔买蓝牙键盘的钱，惭愧。</p>","more":"<h2 id=\"背景与目的\"><a href=\"#背景与目的\" class=\"headerlink\" title=\"背景与目的\"></a>背景与目的</h2><p>对全面屏 iPad Pro 的青睐已久，在今年 10 月 30 号 发布之后就剁手买了一个。不想买配套键盘，一是觉得与 iPad 的设计初衷向违背，移动办公不想多个累赘的键盘；二是一千三百多大洋着实让我望而却步，感觉不是很值得吧。而且平时用 iPad 也没用键盘，小部分时候确实不方便。今天看着电脑键盘突然想到，能不能通过 Mac 来连接 iPad ，充当 iPad 的键盘呢？</p>\n<p>起初想学学自己写个 Mac 端的 App ，发现成本略高，遂转去寻找市面上是否有满足的 App。发现了一款：1Keyboard 。不过很久没更新，上一次已是 2016 年。看了 App Store，68 大洋。</p>\n<p>使用的过程中，我发现了一个可能是 BUG 的无脑设定，十分影响使用，所以寻思着看看能否自己解决，于是我要对 1Keyboard 开刀了。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><p>class-dump —— 导出一个二进制文件的头文件等信息。</p>\n</li>\n<li><p>Hopper Disassembler —— 反汇编分析工具。</p>\n</li>\n<li><p>lldb —— Xcode 自带的调试器。</p>\n</li>\n<li><p>Hex fiend —— 二进制文件编辑器。</p>\n</li>\n</ul>\n<h2 id=\"开刀\"><a href=\"#开刀\" class=\"headerlink\" title=\"开刀\"></a>开刀</h2><h3 id=\"为什么要开刀\"><a href=\"#为什么要开刀\" class=\"headerlink\" title=\"为什么要开刀\"></a>为什么要开刀</h3><p>正如医生对症下刀一样，病人接受临床手术必定是身体机能有问题。 1Keyboard 的问题在于：一个可能是 BUG 的无脑设定。</p>\n<p>实话，第一次的尝试『 macOS 10.14 连接 iOS 12.1 ( iPhone ) 』给我留下的印象还是很好的，输入的东西很快地在我的手机上显示出来，时延低。但是我在 Mac 上码字习惯用 Caps Lock 来切换输入法，事实上，1Keyboard 应该也是支持 Caps Lock 来更换移动设备的输入法的（我看到 iPhone 上输入法已经切换），但在 Mac 上弹出的类似 HUD 的窗口竟然出现了一个 Sheet ？！</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8f3t1.png\" alt=\"Screen Shot 2018-11-07 at 4.07.39 PM\"></p>\n<p>What ？！！ 这种感觉就好像代码的某个位置接收到键盘 Caps Lock 事件时命名奇妙地执行了这样一段代码：</p>\n<pre><code class=\"objective-c\">NSAlert *alert = [[NSAlert alloc] init];\nalert.alertStyle = NSAlertStyleInformational;\nalert.messageText = @&quot;Use the fn Key + media keys to control playback and volumn&quot;;\n[alert beginSheetModalForWindow:window completionHandler:nil];\n</code></pre>\n<p>这个提示是好的，让我知道我还能通过 Fn + 的组合去调节移动设备的音量、亮度等。但不应该是以这种情况出现的。</p>\n<p>所以，很明显——这次的临床手术就是<strong>找到这个 BUG 并解决它</strong>。</p>\n<h3 id=\"初探-1Keyboard\"><a href=\"#初探-1Keyboard\" class=\"headerlink\" title=\"初探 1Keyboard\"></a>初探 1Keyboard</h3><p>我们知道 App 的执行代码最后都编译链接成一个二进制文件，而 1Keyboard 的二进制文件就是 1Keyboard.app/Contents/MacOS/1Keyboard 。绝大多数的操作都是对这个二进制文件进行的。</p>\n<p>了解一个软件，我们都需要从头文件开始做起。先看看软件中存在哪些类，类中都有些什么函数。这时候，我们第一个工具 class-dump 就起作用了。</p>\n<p>将 class-dump 放在与 App 放在同一个文件夹下，然后在终端执行命令，看看里面有哪些头文件：</p>\n<pre><code class=\"shell\">class-dump -H 1Keyboard.app/Contents/MacOS/1Keyboard -o ./Headers\n</code></pre>\n<p>运行结束后在当前目录中会有一个叫 Headers 的文件夹，里面就包含了 1Keyboard 的头文件。此时会看到，几十个头文件，密密麻麻不知道从何看起。</p>\n<h3 id=\"第一次寻找突破点\"><a href=\"#第一次寻找突破点\" class=\"headerlink\" title=\"第一次寻找突破点\"></a>第一次寻找突破点</h3><p>还记得前面的截图吗？！在出现问题的时候，我们使用的窗口是仅仅是类 HUD 的一个 Windows。那突破口应该就是一个 Controller 或者一个 Window 。在头文件里找，很快地找到一个疑似的 BoxViewController.h 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qcyfk.png\" alt=\"Screen Shot 2018-11-08 at 11.44.52 AM\"></p>\n<p>一个疑似的函数也出现了：<code>- (void)handleKeyboardEvent:(id)arg1</code>。感觉像是用来处理键盘事件的。</p>\n<p>找到点苗头，接下来就是看看函数实现能否印证我们的猜测。</p>\n<p>打开 Hopper Disassembler ，将 Macos 文件夹下的二进制文件拖入其中，会得到很多汇编代码，如下图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/w7f2s.png\" alt=\"Screen Shot 2018-11-08 at 11.56.02 AM\"></p>\n<p>汇编是低层的编程语言，写 C 时有可能会在函数中间插入一小段，还有使用 Xcode 调试的时候也经常能看到，但是没有深入的学习，是没法了解其中指令的含义，在本次逆向，我们就先忽略它们。</p>\n<p>左边栏的 Tag Scope 可以选择类，或者通过上方的搜索框，我们可以轻松地找到我们想要的 BoxViewController 。随即下方出现 BoxViewController 类中被实现的函数。同样，找到 <code>[BoxViewController handleKeyboardEvent:]</code> </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/qeb6a.png\" alt=\"Screen Shot 2018-11-08 at 12.03.21 PM\"></p>\n<p>:[ 还是汇编代码。不过，我们可以通过</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8futb.png\" alt=\"Screen Shot 2018-11-08 at 12.04.41 PM\"></p>\n<p>第三个选项 if(b) f(x); 转换成伪代码，看起来就简单多了。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jk2jy.png\" alt=\"Screen Shot 2018-11-08 at 12.06.00 PM\"></p>\n<p>一切都是这么顺利。但是到这里，我们发现：伪代码中只有一个 <code>if-else</code> ，判断条件是 event 的 keyCode 是否等于 0x35 。通过参考资料 1. NSEvent Code 可以得出，0x35 是 esc ，不是我们想要的 Caps Lock （0x39）。</p>\n<h3 id=\"第二次寻找突破点\"><a href=\"#第二次寻找突破点\" class=\"headerlink\" title=\"第二次寻找突破点\"></a>第二次寻找突破点</h3><p>回想起来，忽略了一点，既然 App 弹出提示，那为何不从提示文本入手呢？</p>\n<pre><code>Use the fn key + media keys to control playback and volumn.\n</code></pre><p>对于没有做国际化的 App ，提示文本肯定是在实现文件内的，同样地，我们在 Hopper Disassembler 中看能否搜索到。这次不能搜索 Labels 了，要选择 str 选项。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/xo66d.png\" alt=\"Screen Shot 2018-11-08 at 2.48.00 PM\"></p>\n<p>找到了我们要的结果，看右边，在地址处右键选择 References to 0x10001f3ed 。可以得到是哪个方法引用了这个字符串。我们得到的是</p>\n<pre><code>DATA XREF=-[BoxViewController mediaKeysPressed:]+102\n</code></pre><p>继续深入，我们如法炮制，来看看 <code>mediaKeysPressed</code> 这个函数里面是什么。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/c3z3h.png\" alt=\"Screen Shot 2018-11-08 at 2.55.46 PM\"></p>\n<p>1Keyboard 就是在这个方法中弹出框的，这也验证了一开始的猜想，在不知道什么情况下，执行了最上面说的那段类似的代码。</p>\n<p>然而，这个函数也只是做到弹框显示，没有什么对解决问题有用的信息。那我们就要来看看是哪里调用了这个函数。</p>\n<p>回到汇编代码这边来，在函数名称右键选择 References to selector mediaKeysPressed :</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rnxwk.png\" alt=\"Screen Shot 2018-11-08 at 3.01.38 PM\"></p>\n<p>会发现，我们去到 BoxViewController 的 <code>awakeFromNib</code>中。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/o9rhm.png\" alt=\"Screen Shot 2018-11-08 at 3.06.48 PM\"></p>\n<p><code>mediaKeysPressed</code> 原来是通知事件的 selector 。我们可以发现到后面的字符串  media_keys_pressed 。</p>\n<p>再重复上面的操作，最后可以找到 MyNSApplication 的 <code>sendEvent:</code>方法。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/irvtr.png\" alt=\"Screen Shot 2018-11-08 at 3.14.29 PM\"></p>\n<p>乍一看觉得很熟悉，查阅了文档知道是 NSApplication 用于分发事件的， 1Keyboard 重写了这个方法，那现在问题很明确，我们按下 Caps Lock 的时候，进入到这个方法中了。</p>\n<p>本着科学的无限探索精神，我想弄清楚：为什么要重写？怎么解决我们要解决的问题？</p>\n<h3 id=\"问题思考\"><a href=\"#问题思考\" class=\"headerlink\" title=\"问题思考\"></a>问题思考</h3><p>首先，对几个问题的思考：</p>\n<p>Q：什么是 Media Key？</p>\n<p>A：就是这几个键。<img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/3fclz.png\" alt=\"Screen Shot 2018-11-08 at 3.28.42 PM\"></p>\n<p>Q：为什么要重写<code>sendEvent:</code>？</p>\n<p>A：这个问题个人觉得与 1Keyboard 的设计初衷有关系，从方法名、Notification Name 我们可以得知，1Keyboard 是想在 macOS 上实现对移动设备播放、暂停、调节亮度、音量等多媒体操作的控制。对于有 Media Key 的键盘，自然就需要增加对 Media Key 的支持。监测 Media Key 的<code>KeyDown</code> 和<code>KeyUp</code>最常见的方式就是重写 <code>sendEvent:</code>。</p>\n<p>如上面代码中所示：</p>\n<pre><code class=\"objective-c\">if (([rbx type] == 0xe) &amp;&amp; (([rbx subtype] &amp; 0xffff) == 0x8))\n</code></pre>\n<p><code>rbx</code>是 <code>[arg2 retain]</code> ，理所当然是一个 <code>NSEvent</code> Object 。当 <code>[rbx type]</code> 是 <code>NSEventTypeSystemDefined</code>（14）且  <code>[rbx subtype]</code> 是 8 的时候，就当做是一个  Media Key 的事件，可以借鉴参考资料给出的 2.获取MediaKey的开源Lib——SPMediaKeyTap 。</p>\n<p>然后，第二个判断条件：</p>\n<pre><code class=\"objective-c\">if ([rbx data1] &amp; 0xff00) != 0xa00)\n</code></pre>\n<p>成立是指按键被按下，即 KeyDown 。</p>\n<p> 1Keyboard 设计的初衷和出发点是好的，但是在<code>sendEvent:</code>中没有对 Event 的 keyCode进行判断，导致问题的出现。</p>\n<h3 id=\"寻找解决方法\"><a href=\"#寻找解决方法\" class=\"headerlink\" title=\"寻找解决方法\"></a>寻找解决方法</h3><p>稍微停一下，我们在这里重整一下思路，一开始通过查找字符串，得到 selector ，然后通过引用关系，找到 NSApplication 中的 <code>sendEvent</code> 中通知的发起点，并知道了 BUG 发生的原因，没有判断 event 的 keyCode。</p>\n<p>那好了，现在有两种解决方式：</p>\n<ol>\n<li>在发送 media_keys_pressed 通知之前判断 event 的 keyCode 是否为 0x39 ，若是，则不发送通知。</li>\n<li>去掉<code>[postNotificationName:object:]</code>，不再发送通知。</li>\n</ol>\n<p>第一种会影响整个二进制文件，添加的代码后面所有属性和函数的地址都需要修改；第二种直接覆盖原有地址的汇编，对原来二进制文件影响小，但是不会再弹出提示框。</p>\n<p>对于我这个新手来说，第二种方法虽然没有第一种高级，但至少省下时间，且提示框也不影响平时的使用。</p>\n<p>所以，剩下最后一步：将<code>[postNotificationName:object:]</code>的汇编码变成无作为。</p>\n<p>这时候就需要用到 lldb 了，实际上，用 Hopper Disassembler 是可以直接修改的，只是需要购买 license 。我使用的是试用版，没有修改二进制文件的功能。其实用 gdb 也可以，现在搜到的大多数文章也是用 gdb 来调试程序，但既然在 macOS 上，安装了 Xcode 就有了lldb ，且可以免去 gdb codesign 的烦恼。</p>\n<p>好啦，接下来，我们用 lldb 来完成剩下的工作：</p>\n<ol>\n<li>找到调用语句。</li>\n<li>使用 NOP 替换掉它。</li>\n</ol>\n<p>先使 lldb 进入调试模式：</p>\n<pre><code class=\"shell\">lldb 1Keyboard.app/Contents/MacOS/1Keyboard\n</code></pre>\n<p>lldb 有个 disassemble 指令，可以通过它来看到一个区间内的地址指令情况：</p>\n<pre><code class=\"shell\">(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n1Keyboard[0x10000a541] &lt;+103&gt;: movq   0x2ba00(%rip), %rdi       ; (void *)0x0000000000000000\n1Keyboard[0x10000a548] &lt;+110&gt;: movq   0x2a919(%rip), %rsi       ; &quot;defaultCenter&quot;\n1Keyboard[0x10000a54f] &lt;+117&gt;: movq   0x20bfa(%rip), %r15       ; (void *)0x0000000000000000\n1Keyboard[0x10000a556] &lt;+124&gt;: callq  *%r15\n1Keyboard[0x10000a559] &lt;+127&gt;: movq   %rax, %rdi\n1Keyboard[0x10000a55c] &lt;+130&gt;: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n1Keyboard[0x10000a561] &lt;+135&gt;: movq   %rax, %r14\n1Keyboard[0x10000a564] &lt;+138&gt;: movq   0x2af95(%rip), %rsi       ; &quot;postNotificationName:object:&quot;\n1Keyboard[0x10000a56b] &lt;+145&gt;: leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n1Keyboard[0x10000a572] &lt;+152&gt;: xorl   %ecx, %ecx\n1Keyboard[0x10000a574] &lt;+154&gt;: movq   %r14, %rdi\n1Keyboard[0x10000a577] &lt;+157&gt;: callq  *%r15\n1Keyboard[0x10000a57a] &lt;+160&gt;: movq   %r14, %rdi\n1Keyboard[0x10000a57d] &lt;+163&gt;: callq  0x100019af8               ; symbol stub for: objc_release\n</code></pre>\n<p>lldb 的指令如无歧义，可以进行缩写，如 <strong>p</strong>rint <strong>o</strong>bject 可以缩写成 po 。disassemble 也可以缩写成 di 。-s 是起始地址，-e 是结束地址。</p>\n<p>肯定有人要问：000000010000a541 和 000000010000a582 是怎么得来的？</p>\n<p>那就要回到 Hopper Disassembler 了。</p>\n<p>记得前面我们看过 <code>[sendEvent:]</code>的伪代码，我们还可以看到它的汇编代码的不是吗？只需要点击 mov add 按钮就可以了。可以看到起始地址和结束地址了吧。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/j7fmb.png\" alt=\"Screen Shot 2018-11-09 at 11.03.14 AM\"></p>\n<p>我们都知道 OC 使用消息传递，用 objc_msgSend 来充当函数调用。需要有消息发送者和参数。</p>\n<p>分析一下这段输出，首先我们很快找到 <code>postNotificationName:object:</code> ：</p>\n<pre><code class=\"shell\">movq   0x2af95(%rip), %rsi         ; &quot;postNotificationName:object:&quot;\n</code></pre>\n<p>在汇编代码中 % 前缀的是指寄存器。<code>movq (%ebx), %edx</code> 是指64位间接寻址，因此，这个指令应该是去找 selector 的地址。</p>\n<pre><code class=\"shell\">leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n</code></pre>\n<p>这个很明显：找到 @”media_keys_pressed” 这个字符串。</p>\n<pre><code class=\"shell\">movq   %r14, %rdi\n</code></pre>\n<p>这个是找调用 <code>postNotificationName:object:</code> 的对象，也就是 NotificationCenter 。</p>\n<p>最后，通过 <code>callq</code> 来进行调用：</p>\n<pre><code>callq  *%r15\n</code></pre><p>至此，调用语句已经找到了，接下来就是使用 NOP 来替换它。</p>\n<blockquote>\n<p>NOP 是什么？</p>\n<p>计算机科学中，NOP 或 NOOP 是汇编语言的一个指令，一系列编程语句，或网络传输协议中的表示不做任何有效操作的命令。</p>\n<p>NOP 的值是 0x90 ，占用一个字节。</p>\n</blockquote>\n<p>首先，要设置断点，让程序在某个位置停下来，方便我们修改指令调试：</p>\n<pre><code class=\"shell\">(lldb) breakpoint set -n &quot;[MyNSApplication sendEvent:]&quot;\n(lldb) r\n</code></pre>\n<p>r 是让程序开始运行，按照之前，我们连接手机，按下任意键，会触发断点。此时 lldb 会停下来等待我们进一步的输入。</p>\n<p>从上面可以知道，我们要修改的指令是：</p>\n<pre><code class=\"shell\">1Keyboard[0x10000a577] &lt;+157&gt;: callq  *%r15\n1Keyboard[0x10000a57a] &lt;+160&gt;: movq   %r14, %rdi\n</code></pre>\n<p>指令在内存中的起始地址是 <code>0x10000a577</code>，需要注意的是：下一条指令起始地址是 <code>0x10000a57a</code>。也就是说，我们要修改的指令占据了三个 Byte 。而一个 NOP 只是一个 Byte 。所以我们要将 <code>callq  *%r15</code> 替换成三个 NOP ：</p>\n<pre><code class=\"shell\">(lldb) memory write -f x 0x10000a577 0x90\n(lldb) memory write -f x 0x10000a578 0x90\n(lldb) memory write -f x 0x10000a579 0x90\n</code></pre>\n<p>使用 <code>memory write</code> 可以达到 gdb 中 <code>set</code> 的效果。然后我们再 disassemble 一次：</p>\n<pre><code class=\"shell\">(lldb) di -s 000000010000a541 -e 000000010000a582\n1Keyboard`___lldb_unnamed_symbol224$$1Keyboard:\n    0x10000a541 &lt;+103&gt;: movq   0x2ba00(%rip), %rdi       ; (void *)0x00007fffa62b49d8: NSNotificationCenter\n    0x10000a548 &lt;+110&gt;: movq   0x2a919(%rip), %rsi       ; &quot;defaultCenter&quot;\n    0x10000a54f &lt;+117&gt;: movq   0x20bfa(%rip), %r15       ; (void *)0x00007fff7a0d1a00: objc_msgSend\n    0x10000a556 &lt;+124&gt;: callq  *%r15\n    0x10000a559 &lt;+127&gt;: movq   %rax, %rdi\n    0x10000a55c &lt;+130&gt;: callq  0x100019b10               ; symbol stub for: objc_retainAutoreleasedReturnValue\n    0x10000a561 &lt;+135&gt;: movq   %rax, %r14\n    0x10000a564 &lt;+138&gt;: movq   0x2af95(%rip), %rsi       ; &quot;postNotificationName:object:&quot;\n    0x10000a56b &lt;+145&gt;: leaq   0x2184e(%rip), %rdx       ; @&quot;media_keys_pressed&quot;\n    0x10000a572 &lt;+152&gt;: xorl   %ecx, %ecx\n    0x10000a574 &lt;+154&gt;: movq   %r14, %rdi\n    0x10000a577 &lt;+157&gt;: nop\n    0x10000a578 &lt;+158&gt;: nop\n    0x10000a579 &lt;+159&gt;: nop\n    0x10000a57a &lt;+160&gt;: movq   %r14, %rdi\n    0x10000a57d &lt;+163&gt;: callq  0x100019af8               ; symbol stub for: objc_release\n</code></pre>\n<p>如我们所愿，已经改好了。在终端输入 <code>c</code> ，让程序继续运行，这时会发现，按下 Caps Lock已经不会再弹出那个厌烦的 Sheet 了。</p>\n<p>到这里，已经完成大部分了，lldb 只是一个调试工具，并不能做到修改二进制文件的功能，所以要将修改长效地保存下来，就需要对原二进制文件进行修改。我们就必须先找到 <code>0x10000a577</code> 起始的三个 Byte 的二进制代码是什么。</p>\n<p>因为我们已经修改过内存中的程序，所以需要先将 lldb 退出，重新加载原来的程序，再使用 <code>x/x</code> 指令：</p>\n<pre><code class=\"shell\">(lldb) x/x 0x10000a577\n0x10000a577: 0x4cd7ff41\n(lldb) x/x 0x10000a578\n0x10000a578: 0x894cd7ff\n(lldb) x/x 0x10000a579\n0x10000a579: 0xf7894cd7\n</code></pre>\n<p>我们发现，这三个地址都有部分是重合的，不是巧合，不同的指令拥有不同的二进制编码，<code>x/x</code> 指令总是读取相同长度的内存中的数据。因此我们要将相同的合在一起。</p>\n<p>还需要注意的是：</p>\n<blockquote>\n<p><strong>字节序问题（ Byte Order ）</strong>，Intel 处理器一般是以<strong>小端（ Little endian ）</strong>进行存储，而在硬盘上的二进制码，则是以<strong>大端（ Big endian ）</strong>存储。所谓的<strong>大端</strong>，就是把数字的最高位放在最前面，<strong>小端</strong>则是把最高位放在最后面。</p>\n<p>——摘自参考资料 5.一个数字的魔法——破解Mac上198元的Paw</p>\n</blockquote>\n<p>所以，三者的二进制代码组合起来就是：<code>41 FF D7 4C 89 F7</code> 。</p>\n<p>打开 Hex Fiend 。将二进制文件拖入其中，搜索 <code>41 FF D7 4C 89 F7</code> ，仔细发现，可以搜索出来三个，在不确定是哪个的情况下，我们可以继续对后面的指令再 <code>x/x</code> 。组合更多的 Byte 提高搜索精确度。</p>\n<p>再选两个指令：</p>\n<pre><code>(lldb) x/x 0x10000a57a\n0x10000a57a: 0xe8f7894c\n(lldb) x/x 0x10000a57b\n0x10000a57b: 0x76e8f789\n</code></pre><p>好了，我们的搜索组合现在变成：<code>41 FF D7 4C 89 F7 E8 76</code>。这样就有且仅有一个结果了：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkugc.png\" alt=\"Screen Shot 2018-11-09 at 1.24.40 PM\"></p>\n<p>还记得我们要替换为三位 NOP 吗？将 <code>90 90 90 4C 89 F7 E8 76</code> 填入到 Replace 中。再选择 Replace &amp; Find 就可以了。</p>\n<p>至此，就完成了整个问题的修复。可以 lldb 打开调试看看有没有问题。直接通过双击 1Keyboard.app 是无法打开的，是因为我们修改了 app 中的文件，App 签名已经无法验证通过了。需要进行代码重签：具体可以看我之前的这篇文章。</p>\n<p>然后就可以愉快地玩耍了~ </p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>我是在看别人的优秀文章的时候学习了一点点逆向工程的皮毛。第一次接触逆向工程，很多地方写的不好，肯定有错误的地方，对上述操作手动表示滑稽，还请不吝指正。</p>\n<p>另外，推荐两篇延伸阅读，请见参考资料 5.6. 。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://forums.macrumors.com/threads/nsevent-keycode-list.780577/\">1. NSEvent KeyCode</a></p>\n<p><a href=\"https://github.com/nevyn/SPMediaKeyTap\">2.获取MediaKey的开源Lib——SPMediaKeyTap</a></p>\n<p><a href=\"http://overooped.com/post/2593597587/mediakeys\">3.SPMediaKeyTap作者对Media Key处理方式的解释</a></p>\n<p><a href=\"http://lldb.llvm.org/lldb-gdb.html\">4.GDB - To - LLDB</a></p>\n<p><a href=\"https://bestswifter.com/app-crack/\">5.一个数字的魔法——破解Mac上198元的Paw</a></p>\n<p><a href=\"https://juejin.im/entry/598d53155188257c666c5943\">6.饿了么安全：Mac 下的破解软件真的安全吗？</a></p>"},{"title":"阿澤君的独白","date":"2016-04-02T03:37:39.000Z","typora-copy-images-to":"ipic","_content":"\n接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~\n\n<!--more-->\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg)\n　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。    \n　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。    \n　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。    \n　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。    \n　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>    \n　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！    \n　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。    \n　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。    \n　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。    \n曾经还发过朋友圈宣泄负能量\n![Dubai_piaoquan](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg)\n　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。    \n　　**最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。**但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：\n![Dubai_douzhi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg)\n　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。\n![Dubai_gongsi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg)\n　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。    \n　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>","source":"_posts/阿澤君的独白.md","raw":"---\ntitle: 阿澤君的独白\ndate: 2016-04-02 11:37:39\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n\n接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~\n\n<!--more-->\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg)\n　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。    \n　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。    \n　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。    \n　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。    \n　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>    \n　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！    \n　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。    \n　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。    \n　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。    \n曾经还发过朋友圈宣泄负能量\n![Dubai_piaoquan](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg)\n　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。    \n　　**最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。**但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：\n![Dubai_douzhi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg)\n　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。\n![Dubai_gongsi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg)\n　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。    \n　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>","slug":"阿澤君的独白","published":1,"updated":"2018-03-07T07:52:20.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6e1000qqu0xrccbct21","content":"<p>接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg\" alt=\"\"><br>　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。<br>　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。<br>　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。<br>　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。<br>　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=\"#ff7073\" size=\"3\" face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font><br>　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！<br>　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。<br>　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。<br>　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。<br>曾经还发过朋友圈宣泄负能量<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg\" alt=\"Dubai_piaoquan\"><br>　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。<br>　　<strong>最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。</strong>但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg\" alt=\"Dubai_douzhi\"><br>　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg\" alt=\"Dubai_gongsi\"><br>　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。<br>　　最后，我想说：<font color=\"#ff7073\" size=\"3\" face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font></p>\n","excerpt":"<p>接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg\" alt=\"\"><br>　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。<br>　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。<br>　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。<br>　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。<br>　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font><br>　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！<br>　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。<br>　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。<br>　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。<br>曾经还发过朋友圈宣泄负能量<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg\" alt=\"Dubai_piaoquan\"><br>　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。<br>　　<strong>最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。</strong>但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg\" alt=\"Dubai_douzhi\"><br>　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg\" alt=\"Dubai_gongsi\"><br>　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。<br>　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font></p>"},{"title":"《Beauty》项目小总结","date":"2017-07-17T12:48:15.000Z","id":"FCDAE83256354451","typora-copy-images-to":"ipic","_content":"\n三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    \n\n<!--more-->\n\n2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(\n\n## 所做的事情\n\n总的来说，有这么几个功能：\n\n- 用户端：\n\n  1. 通过Google地图查看当前附近且在线的技师\n\n  2. 添加信用卡等信息，使用Paypal支付\n\n  3. 查看、修改个人信息\n\n  4. 发布公共订单给每个美容技师，技师可以通过竞标得到订单\n\n  5. 查看技师信息，收藏喜爱的技师\n\n  6. 发布私有订单给特定技师\n\n  7. 订单结束评价，打分等\n\n  8. 提供其他用户和技师的电话联系方式\n\n- 技师端：\n\n  1. 竞标用户的公共订单    \n\n  2. 接受或拒绝用户的私有订单\n\n  3. 添加银行卡，得到订单报酬\n\n  4. 查看、修改个人信息，查看收入数据，\n\n  5. 提交封面图片，作品图片\n\n  6. 增删改查服务信息、价格\n\n     ​\n\n## 一些具体实现\n\n　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：\n\n### 项目文件结构\n\n![Beauty_项目大致结构](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png)\n\n　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    \n\n　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的>w<）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      \n\n　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     \n\n\n\n### 地图\n\n![Beauty_Google地图_小](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg)\n\n　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     \n\n\n\n### 左侧滑动菜单\n\n![Beauty_左边栏](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg)\n\n　　图片好像压缩得有点过分了....\n\n　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了...\n\n　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神[《iOS开发进阶》](https://book.douban.com/subject/26287173/)一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：\n\n```objective-c\n- (void)viewDidLoad {\n\t_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t_window.windowLevel = UIWindowLevelNormal;\n\t_window.backgroundColor = [UIColor clearColor];\n\t_window.hidden = YES;\n\tBECDrawerView *view = [BECDrawerView new];\n\t//省略对view的一些初始化代码\n\t_leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n\t_leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n\t_leftView = view;\n\t//一开始先把leftView隐藏\n\t_leftHidden = YES;\n\t_leftView.hidden = _leftHidden;\n\t[_window addSubview:_leftView];\n    \n\tUIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n\tedgeGesture.delegate = self;\n\tedgeGesture.edges = UIRectEdgeLeft;\n\t[self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x > 0 && panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];\t//添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n    \n    _leftHidden = !_leftHidden;\n    \n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@\"removed\");\n        self.navigationController.navigationBar.hidden = NO;\n    }\n    \n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n    \n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@\"%@\",self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n    \n}\n```\n\n\n\n### CHARMER PROFILE\n\n![Beauty_CollectionView](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg)\n\n　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：\n\n1. 最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件[EZRecycleImageView](https://github.com/objchris/EZRecycleImageView)，在开发中边使用边改进是最好不过的事情了。\n2. 第二个Header是技师信息和三个按钮\n3. 最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。\n\n　　View里面嵌入View的复杂结构也是很值得掌握的手法~\n\n\n\n　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     \n\n　　最后附上使用的第三方库：\n\n```\nplatform :ios, \"8.0\"\ntarget :Beauty do\npod 'SVProgressHUD', '~> 2.0.3'\npod 'Masonry', '~> 1.0.2'\npod 'AFNetworking', '~> 3.0'\npod 'SDWebImage', '~>3.8'\npod 'YYModel'\npod 'IQKeyboardManager'\npod 'GoogleMaps'\npod 'MJRefresh'\npod \"MWPhotoBrowser\"\npod 'JPush'\npod 'PayPal-iOS-SDK'\n\nend\n```\n\n\n\n\n\n## 总结与反思\n\n- 好的方面：\n\n  1. 一位好Partner，一位一起奋斗的好朋友。\n\n  2. 很多UI控件和底层实现都接触到了，加深了印象。\n\n  3. 真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。\n\n  4. 积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。\n\n- 不好的方面：\n\n  1. 首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。\n\n  2. 其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。\n\n  3. 客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。\n\n\n","source":"_posts/项目Beauty总结.md","raw":"---\ntitle: 《Beauty》项目小总结\ndate: 2017-07-17 20:48:15\nid: FCDAE83256354451\ntags: \n- Summary\ntypora-copy-images-to: ipic\n---\n\n三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    \n\n<!--more-->\n\n2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(\n\n## 所做的事情\n\n总的来说，有这么几个功能：\n\n- 用户端：\n\n  1. 通过Google地图查看当前附近且在线的技师\n\n  2. 添加信用卡等信息，使用Paypal支付\n\n  3. 查看、修改个人信息\n\n  4. 发布公共订单给每个美容技师，技师可以通过竞标得到订单\n\n  5. 查看技师信息，收藏喜爱的技师\n\n  6. 发布私有订单给特定技师\n\n  7. 订单结束评价，打分等\n\n  8. 提供其他用户和技师的电话联系方式\n\n- 技师端：\n\n  1. 竞标用户的公共订单    \n\n  2. 接受或拒绝用户的私有订单\n\n  3. 添加银行卡，得到订单报酬\n\n  4. 查看、修改个人信息，查看收入数据，\n\n  5. 提交封面图片，作品图片\n\n  6. 增删改查服务信息、价格\n\n     ​\n\n## 一些具体实现\n\n　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：\n\n### 项目文件结构\n\n![Beauty_项目大致结构](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png)\n\n　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    \n\n　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的>w<）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      \n\n　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     \n\n\n\n### 地图\n\n![Beauty_Google地图_小](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg)\n\n　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     \n\n\n\n### 左侧滑动菜单\n\n![Beauty_左边栏](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg)\n\n　　图片好像压缩得有点过分了....\n\n　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了...\n\n　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神[《iOS开发进阶》](https://book.douban.com/subject/26287173/)一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：\n\n```objective-c\n- (void)viewDidLoad {\n\t_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t_window.windowLevel = UIWindowLevelNormal;\n\t_window.backgroundColor = [UIColor clearColor];\n\t_window.hidden = YES;\n\tBECDrawerView *view = [BECDrawerView new];\n\t//省略对view的一些初始化代码\n\t_leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n\t_leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n\t_leftView = view;\n\t//一开始先把leftView隐藏\n\t_leftHidden = YES;\n\t_leftView.hidden = _leftHidden;\n\t[_window addSubview:_leftView];\n    \n\tUIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n\tedgeGesture.delegate = self;\n\tedgeGesture.edges = UIRectEdgeLeft;\n\t[self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x > 0 && panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];\t//添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n    \n    _leftHidden = !_leftHidden;\n    \n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@\"removed\");\n        self.navigationController.navigationBar.hidden = NO;\n    }\n    \n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n    \n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@\"%@\",self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n    \n}\n```\n\n\n\n### CHARMER PROFILE\n\n![Beauty_CollectionView](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg)\n\n　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：\n\n1. 最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件[EZRecycleImageView](https://github.com/objchris/EZRecycleImageView)，在开发中边使用边改进是最好不过的事情了。\n2. 第二个Header是技师信息和三个按钮\n3. 最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。\n\n　　View里面嵌入View的复杂结构也是很值得掌握的手法~\n\n\n\n　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     \n\n　　最后附上使用的第三方库：\n\n```\nplatform :ios, \"8.0\"\ntarget :Beauty do\npod 'SVProgressHUD', '~> 2.0.3'\npod 'Masonry', '~> 1.0.2'\npod 'AFNetworking', '~> 3.0'\npod 'SDWebImage', '~>3.8'\npod 'YYModel'\npod 'IQKeyboardManager'\npod 'GoogleMaps'\npod 'MJRefresh'\npod \"MWPhotoBrowser\"\npod 'JPush'\npod 'PayPal-iOS-SDK'\n\nend\n```\n\n\n\n\n\n## 总结与反思\n\n- 好的方面：\n\n  1. 一位好Partner，一位一起奋斗的好朋友。\n\n  2. 很多UI控件和底层实现都接触到了，加深了印象。\n\n  3. 真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。\n\n  4. 积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。\n\n- 不好的方面：\n\n  1. 首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。\n\n  2. 其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。\n\n  3. 客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。\n\n\n","slug":"项目Beauty总结","published":1,"updated":"2018-03-15T01:32:27.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6e3000rqu0x5s95lyjq","content":"<p>三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    </p>\n<a id=\"more\"></a>\n<p>2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(</p>\n<h2 id=\"所做的事情\"><a href=\"#所做的事情\" class=\"headerlink\" title=\"所做的事情\"></a>所做的事情</h2><p>总的来说，有这么几个功能：</p>\n<ul>\n<li><p>用户端：</p>\n<ol>\n<li><p>通过Google地图查看当前附近且在线的技师</p>\n</li>\n<li><p>添加信用卡等信息，使用Paypal支付</p>\n</li>\n<li><p>查看、修改个人信息</p>\n</li>\n<li><p>发布公共订单给每个美容技师，技师可以通过竞标得到订单</p>\n</li>\n<li><p>查看技师信息，收藏喜爱的技师</p>\n</li>\n<li><p>发布私有订单给特定技师</p>\n</li>\n<li><p>订单结束评价，打分等</p>\n</li>\n<li><p>提供其他用户和技师的电话联系方式</p>\n</li>\n</ol>\n</li>\n<li><p>技师端：</p>\n<ol>\n<li><p>竞标用户的公共订单    </p>\n</li>\n<li><p>接受或拒绝用户的私有订单</p>\n</li>\n<li><p>添加银行卡，得到订单报酬</p>\n</li>\n<li><p>查看、修改个人信息，查看收入数据，</p>\n</li>\n<li><p>提交封面图片，作品图片</p>\n</li>\n<li><p>增删改查服务信息、价格</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一些具体实现\"><a href=\"#一些具体实现\" class=\"headerlink\" title=\"一些具体实现\"></a>一些具体实现</h2><p>　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：</p>\n<h3 id=\"项目文件结构\"><a href=\"#项目文件结构\" class=\"headerlink\" title=\"项目文件结构\"></a>项目文件结构</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png\" alt=\"Beauty_项目大致结构\"></p>\n<p>　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    </p>\n<p>　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的&gt;w&lt;）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      </p>\n<p>　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     </p>\n<h3 id=\"地图\"><a href=\"#地图\" class=\"headerlink\" title=\"地图\"></a>地图</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg\" alt=\"Beauty_Google地图_小\"></p>\n<p>　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     </p>\n<h3 id=\"左侧滑动菜单\"><a href=\"#左侧滑动菜单\" class=\"headerlink\" title=\"左侧滑动菜单\"></a>左侧滑动菜单</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg\" alt=\"Beauty_左边栏\"></p>\n<p>　　图片好像压缩得有点过分了….</p>\n<p>　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了…</p>\n<p>　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神<a href=\"https://book.douban.com/subject/26287173/\" target=\"_blank\" rel=\"external\">《iOS开发进阶》</a>一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：</p>\n<pre><code class=\"objective-c\">- (void)viewDidLoad {\n    _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    _window.windowLevel = UIWindowLevelNormal;\n    _window.backgroundColor = [UIColor clearColor];\n    _window.hidden = YES;\n    BECDrawerView *view = [BECDrawerView new];\n    //省略对view的一些初始化代码\n    _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n    _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n    _leftView = view;\n    //一开始先把leftView隐藏\n    _leftHidden = YES;\n    _leftView.hidden = _leftHidden;\n    [_window addSubview:_leftView];\n\n    UIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n    edgeGesture.delegate = self;\n    edgeGesture.edges = UIRectEdgeLeft;\n    [self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x &gt; 0 &amp;&amp; panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];    //添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n\n    _leftHidden = !_leftHidden;\n\n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@&quot;removed&quot;);\n        self.navigationController.navigationBar.hidden = NO;\n    }\n\n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n\n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@&quot;%@&quot;,self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n\n}\n</code></pre>\n<h3 id=\"CHARMER-PROFILE\"><a href=\"#CHARMER-PROFILE\" class=\"headerlink\" title=\"CHARMER PROFILE\"></a>CHARMER PROFILE</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg\" alt=\"Beauty_CollectionView\"></p>\n<p>　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：</p>\n<ol>\n<li>最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件<a href=\"https://github.com/objchris/EZRecycleImageView\" target=\"_blank\" rel=\"external\">EZRecycleImageView</a>，在开发中边使用边改进是最好不过的事情了。</li>\n<li>第二个Header是技师信息和三个按钮</li>\n<li>最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。</li>\n</ol>\n<p>　　View里面嵌入View的复杂结构也是很值得掌握的手法~</p>\n<p>　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     </p>\n<p>　　最后附上使用的第三方库：</p>\n<pre><code>platform :ios, &quot;8.0&quot;\ntarget :Beauty do\npod &#39;SVProgressHUD&#39;, &#39;~&gt; 2.0.3&#39;\npod &#39;Masonry&#39;, &#39;~&gt; 1.0.2&#39;\npod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39;\npod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;\npod &#39;YYModel&#39;\npod &#39;IQKeyboardManager&#39;\npod &#39;GoogleMaps&#39;\npod &#39;MJRefresh&#39;\npod &quot;MWPhotoBrowser&quot;\npod &#39;JPush&#39;\npod &#39;PayPal-iOS-SDK&#39;\n\nend\n</code></pre><h2 id=\"总结与反思\"><a href=\"#总结与反思\" class=\"headerlink\" title=\"总结与反思\"></a>总结与反思</h2><ul>\n<li><p>好的方面：</p>\n<ol>\n<li><p>一位好Partner，一位一起奋斗的好朋友。</p>\n</li>\n<li><p>很多UI控件和底层实现都接触到了，加深了印象。</p>\n</li>\n<li><p>真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。</p>\n</li>\n<li><p>积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。</p>\n</li>\n</ol>\n</li>\n<li><p>不好的方面：</p>\n<ol>\n<li><p>首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。</p>\n</li>\n<li><p>其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。</p>\n</li>\n<li><p>客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。</p>\n</li>\n</ol>\n</li>\n</ul>\n","excerpt":"<p>三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    </p>","more":"<p>2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(</p>\n<h2 id=\"所做的事情\"><a href=\"#所做的事情\" class=\"headerlink\" title=\"所做的事情\"></a>所做的事情</h2><p>总的来说，有这么几个功能：</p>\n<ul>\n<li><p>用户端：</p>\n<ol>\n<li><p>通过Google地图查看当前附近且在线的技师</p>\n</li>\n<li><p>添加信用卡等信息，使用Paypal支付</p>\n</li>\n<li><p>查看、修改个人信息</p>\n</li>\n<li><p>发布公共订单给每个美容技师，技师可以通过竞标得到订单</p>\n</li>\n<li><p>查看技师信息，收藏喜爱的技师</p>\n</li>\n<li><p>发布私有订单给特定技师</p>\n</li>\n<li><p>订单结束评价，打分等</p>\n</li>\n<li><p>提供其他用户和技师的电话联系方式</p>\n</li>\n</ol>\n</li>\n<li><p>技师端：</p>\n<ol>\n<li><p>竞标用户的公共订单    </p>\n</li>\n<li><p>接受或拒绝用户的私有订单</p>\n</li>\n<li><p>添加银行卡，得到订单报酬</p>\n</li>\n<li><p>查看、修改个人信息，查看收入数据，</p>\n</li>\n<li><p>提交封面图片，作品图片</p>\n</li>\n<li><p>增删改查服务信息、价格</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一些具体实现\"><a href=\"#一些具体实现\" class=\"headerlink\" title=\"一些具体实现\"></a>一些具体实现</h2><p>　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：</p>\n<h3 id=\"项目文件结构\"><a href=\"#项目文件结构\" class=\"headerlink\" title=\"项目文件结构\"></a>项目文件结构</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png\" alt=\"Beauty_项目大致结构\"></p>\n<p>　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    </p>\n<p>　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的&gt;w&lt;）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      </p>\n<p>　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     </p>\n<h3 id=\"地图\"><a href=\"#地图\" class=\"headerlink\" title=\"地图\"></a>地图</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg\" alt=\"Beauty_Google地图_小\"></p>\n<p>　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     </p>\n<h3 id=\"左侧滑动菜单\"><a href=\"#左侧滑动菜单\" class=\"headerlink\" title=\"左侧滑动菜单\"></a>左侧滑动菜单</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg\" alt=\"Beauty_左边栏\"></p>\n<p>　　图片好像压缩得有点过分了….</p>\n<p>　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了…</p>\n<p>　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神<a href=\"https://book.douban.com/subject/26287173/\">《iOS开发进阶》</a>一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：</p>\n<pre><code class=\"objective-c\">- (void)viewDidLoad {\n    _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    _window.windowLevel = UIWindowLevelNormal;\n    _window.backgroundColor = [UIColor clearColor];\n    _window.hidden = YES;\n    BECDrawerView *view = [BECDrawerView new];\n    //省略对view的一些初始化代码\n    _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n    _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n    _leftView = view;\n    //一开始先把leftView隐藏\n    _leftHidden = YES;\n    _leftView.hidden = _leftHidden;\n    [_window addSubview:_leftView];\n\n    UIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n    edgeGesture.delegate = self;\n    edgeGesture.edges = UIRectEdgeLeft;\n    [self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x &gt; 0 &amp;&amp; panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];    //添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n\n    _leftHidden = !_leftHidden;\n\n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@&quot;removed&quot;);\n        self.navigationController.navigationBar.hidden = NO;\n    }\n\n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n\n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@&quot;%@&quot;,self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n\n}\n</code></pre>\n<h3 id=\"CHARMER-PROFILE\"><a href=\"#CHARMER-PROFILE\" class=\"headerlink\" title=\"CHARMER PROFILE\"></a>CHARMER PROFILE</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg\" alt=\"Beauty_CollectionView\"></p>\n<p>　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：</p>\n<ol>\n<li>最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件<a href=\"https://github.com/objchris/EZRecycleImageView\">EZRecycleImageView</a>，在开发中边使用边改进是最好不过的事情了。</li>\n<li>第二个Header是技师信息和三个按钮</li>\n<li>最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。</li>\n</ol>\n<p>　　View里面嵌入View的复杂结构也是很值得掌握的手法~</p>\n<p>　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     </p>\n<p>　　最后附上使用的第三方库：</p>\n<pre><code>platform :ios, &quot;8.0&quot;\ntarget :Beauty do\npod &#39;SVProgressHUD&#39;, &#39;~&gt; 2.0.3&#39;\npod &#39;Masonry&#39;, &#39;~&gt; 1.0.2&#39;\npod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39;\npod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;\npod &#39;YYModel&#39;\npod &#39;IQKeyboardManager&#39;\npod &#39;GoogleMaps&#39;\npod &#39;MJRefresh&#39;\npod &quot;MWPhotoBrowser&quot;\npod &#39;JPush&#39;\npod &#39;PayPal-iOS-SDK&#39;\n\nend\n</code></pre><h2 id=\"总结与反思\"><a href=\"#总结与反思\" class=\"headerlink\" title=\"总结与反思\"></a>总结与反思</h2><ul>\n<li><p>好的方面：</p>\n<ol>\n<li><p>一位好Partner，一位一起奋斗的好朋友。</p>\n</li>\n<li><p>很多UI控件和底层实现都接触到了，加深了印象。</p>\n</li>\n<li><p>真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。</p>\n</li>\n<li><p>积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。</p>\n</li>\n</ol>\n</li>\n<li><p>不好的方面：</p>\n<ol>\n<li><p>首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。</p>\n</li>\n<li><p>其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。</p>\n</li>\n<li><p>客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。</p>\n</li>\n</ol>\n</li>\n</ul>"},{"title":"What's new in Xcode 10","date":"2018-06-15T09:25:21.000Z","typora-copy-images-to":"ipic","_content":"\n要让开发效率提高，写更多的 ~~bug~~ ，呸，更多改变世界的代码，我们就需要先了解每个苹果系列开发者必须使用的工具，就是今天要讲的主角 —— Xcode 10\n\n<!--more-->\n\n## 关于 Xcode 10\n\nXcode 在每年的 [WWDC](https://developer.apple.com/videos/wwdc2018/) 都会有所改进，今年也不例外，如约而至降临于六月五号。同样是先发布 [beta](https://developer.apple.com/download/) 版，正式版将在秋季发布于新的 App Store 上（新版的 App Store 还挺好看的，欢心荡漾中 :] ）\n\n### 平台限制\n\nXcode 10 现在只有 beta 版，只能安装在 mac 10.13.4 及以上的版本，如果升级了最新的 beta 版系统 Mojave 还可以尝试一下黑夜模式，下面会说到。\n\n### SDK\n\nbeta 版包含了新发布的 iOS 12, watchOS 5, macOS 10.14 以及 tvOS 12 的 SDK 开发工具包。\n\n### 下载安装\n\n首先下载 [.xip 安装包](https://download.developer.apple.com/Developer_Tools/Xcode_10_Beta/Xcode_10_Beta.xip)，解压放到 Applications 文件夹就可以了。使用 beta 版的 command line tools ，在 iTerm 或自带的 Terminals 中执行命令：\n\n```Shell\nxcode-select -s <path to Xcode>\n```\n\n对了，Xcode 10 beta 版是可以与原有的 Xcode 共存的。\n\n### 什么被弃用了？\n\nXcode 每年更新总会弃用一些旧的标准或工具，今年也不例外。Xcode 10 beta 今年对如下的几项动了刀子：\n\n- macOS 10.14 SDK 不再支持编译 32 位的应用，以后再见不到 i386 了。\n\n- 对 SVN 的支持也取消了，同时现在可直接使用以下源代码管理平台：\n\n  - Bitbucket Cloud 和 Bitbucket Server\n  - Github 和 Github Enterprise\n  - Gitlab.com 和 Gitlab Self-hosted\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rvegj.png)\n\n-  libstdc++ 自从 Xcode 8 宣布不建议使用后，终于在 Xcode 10 中被直接斩掉。其中包括 stdc++, stdc++.6.0.9, libstdc++.6.0.9.tbd（新的动态库）,  libstdc++.6.0.9.dylib（旧的动态库）。经过 Apple 两年对 libc++ 的优化和推广，Xcode 10 中 C++ 工程需要链接 libc++ 已经箭在弦上，如果项目中使用到 libstdc++ ，就像我一样，暂时可以做到的是继续使用 Xcode 9 苟一段时间，或将 Xcode 9 中 关于 libstdc++ 的文件复制一份到 Xcode 10 中。不过长久来看，还是将使用到 libstdc++ 的 API 的库重新修改代码，链接到 libc++ 好一点。\n\n- OpenGL , OpenGL|ES , OpenCL 进入废弃列表，原有 API 还是可用，但说不定以后的某一天跟 i386 一样突然就没了，对游戏开发和图像处理工具等 App 影响还是蛮大的。对此，苹果建议使用 Metal 来进行图像处理，声称可以更大程度地使用到 GPU 。\n\n- 还有一些其他的 API ，请见 [Apple Developer Documentation](https://developer.apple.com/documentation/) 。\n\n## 新特性\n\nXcode 10 beta 的新特性是我们比较关心的，涉及到方方面面，接下来我们看看今年的Xcode 10 给我们带来了什么？\n\n### 通用层面\n\n#### Dark Mode\n\n说到 macOS Mojave ，首先想到的应该就是 Dark Mode 黑夜模式了，看 WWDC Keynote 的时候，桌面从白天变成黑夜，真的惊艳到。Mojave 的黑夜模式不仅仅是系统层面，App 也可以融入这种深沉的黑色。当然了，Xcode 10 beta 版也在众多支持黑夜模式的首发 App 中，打开看一下：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/moj7b.png)\n\n对这个有兴趣可以看看 [Introducing Dark Mode](https://developer.apple.com/videos/play/wwdc2018/210/) 。\n\n#### Library 的位置改变了\n\n用多了 storyboard ，我们都知道，每次从 Inspectors 底部的 Library(库内容) 中将各种组件拉出来放到 storyboard 为我们设置好的画布上，是一件很舒服的事情。\n\n从 Xcode 10 开始，Library 不再内嵌于 Inspectors 。而是放到 Xcode 右上角 Configure editor area 的左侧：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/mpxl8.png)\n\n点击后会弹出一个重叠窗口，就想 Spotlight Search 一样。窗口呈现的内容会随当前打开的文件的不同而不同，譬如，如果当前是代码文件，则显示 Code Snippets ，如果当前是 storyboard ，那么会显示各种可拖拉的组件：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dfceb.png)\n\n在将组件拖动放置到文件中时，弹出的重叠窗口会消失，如果不想它消失，则在拖拉组件的时候按住 Option(⌥) 键即可。\n\n对了，弹出的重叠窗口可以左右拉伸。激活的话，还可以通过 View > Libraries 中选择打开，也可以通过快捷键 ⇧+⌘+L 。\n\n长按按钮可以选择查看 Media Library ，也就是添加到项目中的图片等。同样的，在 View > Libraries 中选择，快捷键是 ⇧+⌘+M 。\n\n个人觉得，这个更新操作比之前稍微繁杂了一些，但是一次性展示出来的内容更多了些，各有优劣吧感觉。\n\n#### Scheme\n\n新建的 scheme 默认是 Shared 的状态，如果想建立私有的 scheme ，则在 Manage Schemes 中去掉勾选。\n\nScheme 的选择和运行设备的选择都可以通过键盘快捷键来操作，这是要解放鼠标？\n\n快捷键分别是 ⌃+0 和 ⌃+⇧+0 ，当弹出 popup 后，可以键入字符或使用方向键来高亮 scheme 或设备，并回车选择。\n\n### Source Editor\n\n#### mutil-cursor editing (多行同时输入)\n\n像 Sublime Text 一样，支持多行同时输入了。以前一个 Alert 的提示语要复制粘贴粘贴粘贴粘贴的时代终于离我们而去。\n\n包括鼠标点击方式 ⌃+⇧+Click ，或通过选择列 ⌥+Click+Drag ，或通过键盘的 ⌃+⇧+Up 选择上一列，或 ⌃+⇧+Down 选择下一列。\n\n#### 可以折叠代码了，嘿嘿\n\nXcode 9中，在 `if` , `func` 等关键字处 ⌘+Click 可以看到代码块所占的所有行，而在 Xcode 10 beta 中，还可以激活 code folding 的 popup ，在弹出的 popup 选择 Fold 就可以折叠代码了。\n\n不想每次都 ⌘+Click ，可以在 Xcode > Preferences > Text Editing > Show， 勾选 Code folding ribbon 。就可以看到在 Editor 的内部左侧，显示的行数的右侧有标志条，点击就可以直接折叠代码了。\n\n还可以通过 Editor > Code Folding 选择折叠当前打开文件**所有**的代码结构，甚至是注释。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zd5zl.png)\n\nXcode 10 beta 中的处于版本管理状态的工程，可以看到开发者所作出的修改和在版本控制服务器上未被 pull 下来的提交。这个的标志条是在代码行数的左侧。\n\n#### 查找和选择\n\n以前有一种情况是：我们想改变文件内的静态函数名、函数内的变量名、静态变量名的时候，修改之后需要整个文件审视一遍，或让 Xcode 通过编译错误提醒我们。现在，在 Xcode 10 beta 中，可以通过 Editor > Structure > Select all Symbols 选择光标所在的函数或变量的 symbols ，就可以做到改一处而改动所有。\n\n当我们要选择当前文件下查找到的所有结果，可以先执行一次查找 ⌘+F ，然后 Find > Select All Find Matches 进行全选，就可以修改所有结果。\n\n但是，当我们不想选择当前文件下的所有查找到的结果，而是选择某一段代码中的包含的将被查找到的结果，可以先进行查找，然后选择要查找的那段代码， Find > Select Find Matches in Selection ，就可以选择到某段代码中的所有查找到的结果。\n\n#### overscroll\n\n打开 Xcode 10 beta 版的 Source Editor 时，滑动到最下面时，出现了一大片空白，如下图白色框框所示：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/897w4.png)\n\n这不是 Xcode 的 Bug ，而是 10 beta 版的新功能 overscroll 。以前版本的 Xcode ，在文件末尾添加函数的时候，视线只能一直盯着最下面几行，或者提前先使用几个空行做占位，让视线更趋近于 Source Editor 的中间。现在有了 overscroll 之后，滚动到文件末尾，Xcode 会预留更多空间，使 Source Editor 可以向下再滚动一段距离（估计只是修改了 Source Editor 的 ScrollerView 的 inset 。:] ）\n\n可滚动的距离也可以设置，在 Preference > Text Editing > Editor Overscroll 选择距离级别，分别有 None, Small, Medium, Large ，见名知意，就不多阐述了。\n\n#### Quick Help\n\n右侧 Quick Help 的 layout 也修改了，可读性更强。普天同庆啊~\n\nQuick Help 和 Documentation Viewer 的代码样式跟用户当前使用的主题是一样的，整体看起来更和谐一些。\n\n### New Build System\n\nXcode 10 使用了新的 Build System ，当然也可以选择使用老的 Build System ，通过 File > Project/Workspace Settings 中选择：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aykpw.png)\n\n这样的话，在构建时， Toolbar 的 View Activity 的 Activity Indicators 区域会出现一个橘黄色的小锤子：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/u2dp7.png)\n\n新的 Build System 保证了构建时的可靠性和性能，能捕获到项目的配置问题。在我们没有能很好地使用新的 Build System 之前，使用新的工具总会遇到问题，常见的一些编译问题的解释和解决方法在 [Xcode Help](https://help.apple.com/xcode/mac/current/#/dev621201fb0) 。\n\n### Testing\n\n#### 乱序\n\n首先，支持乱序。Test Bundle 中的方法可以不按顺序进行测试，默认是关闭的，可以通过 Edit Scheme > Test > Info > Tests 选择任意 Test Bundle ，打开 Options 勾选 Randomize execution order 来开启。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tn1xw.png)\n\n#### 并行测试\n\n上图还透露了一个信息，在 Randomize execution order 上面，还有个选项 Execute in parallel on Simulator ，那就是可以并行测试了（并发已经满足不了广大开发者的需求了）。只限于 macOS 的 unit tests ，iOS 模拟器和 tvOS 模拟器的 unit 和 UI tests 。因为，要达到真正的并行，真机肯定是不支持的。并行测试时，Xcode 会开启多个线程运行多个我们选定的模拟器，然后在上面进行测试，在 Report navigator 也会记录线程启动和测试的日志，你会看到很多诸如 Clone X of iPhone X 的信息。\n\n命令行 `xcodebuild` 也支持并行测试，只需要加上参数 `-parallel-testing-enabled YES|NO ` 去重写 seheme 的 pre-target 就可以了。还可以通过 `-parallel-testing-worker-count` 和 `-maximum-parallel-testing-workers` 控制测试模拟器的数量。\n\n具体请打开 iTerm 或 Terminals 敲 `xcodebuild -help` 。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f5vxe.png)\n\n#### 可变的测试集\n\n新建的测试默认状态是 enabled 的，这样我们在 Test navigator 中可以通过点击测试类或测试方法右边的运行按钮进行测试。\n\n然而，如果想固定当前的测试集，排除新建的测试类或方法时，可以取消勾选 Automatically include new tests ，见上图。此时测试方法的状态是 disabled ，将无法在 Test navigator 中进行测试，但可以在类中该方法的左侧点击运行按钮进行测试。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4jdy0.png)\n\n假设过了一段时间，想把 disabled 状态的测试类或方法变成 enabled ，在 Edit Scheme 中可以修改其状态。这样我们可以控制每次测试所运行的测试集，不必浪费时间去做一些不需要做的测试。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p99x5.png)\n\n### IB\n\n- 画布的渲染也并行了，scenes 的放大缩小和组件的修改，据说性能都得到提升。\n\n\n- 原来 storyboard 右下角的 \"Embed in Stack View\" 按钮也改成了 popup ，提供更多选项供开发者选择 embed ，如下图白色框框。\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kij8a.png) \n\n  其中的 View Without Inset 会将选择的所有 View 紧凑地放在一个 Super View 里面。\n\n\n- 打开 Xcode 5 的 .nib 或 .xib 文件，会提示格式问题并自动更新到当前版本所使用的格式。\n- Attributes Inspector 的字体支持 iOS 11 发布的 Large Title ，且自定义字体可以看到样式预览，这个还挺不错的。\n- 同样是 Attributes Inspector 中，named color 和 图片右侧有个小按钮可以连接到 Assets ，在这个小按钮上 ⌥+Click 可以在 Assistant Editor 中打开。\n\n### Asset Catalog\n\nmacOS 10.14 有了 Dark Mode 之后，Assets 除了之前普通模式下单一的图片和 named color ，也支持 Light 和 Dark 。并且有个 High Contrast 的选项可以勾选，所以 macOS 开发如果要加入 Dark Mode ，要上传的图片和 named color 从原来的三张、一个颜色变成十三张图片、六个颜色，我的🐴🦆。\n\n不过感谢 Dark Mode 福泽，asset 的背景也可以切换成 Light , Dark , System Appearance(跟随系统) 。切换的按钮在 assets 的左下角。对了，View Debugger 也有这个切换背景的功能，也就是那个调试 UI 的界面。\n\n支持 Carplay assets，国内还没普及，暂时应该没多大用处。\n\n支持 ARKit 3D `ARReferenceObject` assets 。\n\n### Debugging\n\nDebugging 功能的完善主要是针对 macOS 开发：\n\n- Disk Gauge Report 加入了已关闭文件的大小的显示和对硬盘的读写随时间推进的变化表。\n\n- Named color 在 View Debugger 的  Inspector 显示颜色的名称和是否属于系统颜色，仅 macOS 开发才有。\n\n- 当 macOS App 在运行过程中，可以通过 Debug > View Debugging > Appearance menu 或者调试工具 Memory Graph 右边新加的按钮或 Touch Bar 来切换 Light 或 Dark 模式\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9nth5.png)\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a5le3.png)\n\n\n- Metal Frame Debugger ，笔者尚未深入了解，暂时不介绍了。\n\n### Playground\n\nPlayground 引入了一个增量执行? ( execute code incrementally ) 的 workflow 。\n\n1. 在 Xcode 10 中，新建 Playground 默认是 Manually Run 。\n\n2. 当写完代码后，按 ⇧+Return 或点击代码左侧的执行按钮，Playground 会进入运行模式，执行到指定位置( ⇧+Return 或点击的执行按钮所在的上一行)，然后进入等待模式，没有结束执行。\n\n   ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/t5tiz.png)\n\n3. 我们可以不断地执行第2步，Playground 只会编译上一次暂停执行的位置到我们 ⇧+Return 或点击执行按钮的位置。\n\n   ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/opr4z.png)\n\n4. 点击 Stop Playground 结束操作 Playground 。\n\n### Localization\n\nXcode 10 beta 版支持新的国际化 workflow ，使用新的国际化文件 .xcloc 取代以前的 .xliff 。喔，不，应该是包含 .xliff 。还支持其他可能需要国际化的文件，如图片。\n\n有兴趣的同学可以看看 [New Localization Workflows in Xcode 10](https://developer.apple.com/videos/play/wwdc2018/404/) 。\n\n### Signing And Distribution\n\n今年的 Xcode 10 完善了 macOS App 的发布和认证， Organizer Distribution 的 Developer ID 选项提供了上传到 Apple 进行认证的功能。Archive 后， Distribute App > Developer ID ，可以选择 Upload 上传到 Apple 进行认证或 Export 到本地保存。要上传应用，需要在 Xcode 中添加苹果账号，并填写所需的App Store Connect role与提供者资格，此外，认证应用还需要有开发者ID证书签名。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97fpw.png)\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a05lh.png)\n\n在上传的应用被认证后，你可以在 Organizer 中选择你的档案并点击 Show Status Log 按钮，这样就能查看应用的状态。当收到认证通过的通知后，就可以从 Organizer 中将 App Export 出来，保存下来的 App 包含一个附加的票据，就意味着可以发布了。\n\n## 最后说一句\n\n今年的 WWDC 没有专题讲述 Xcode 10 。很多都是穿插在各个 Session 中。理解并用好一个工具能提高我们开发的效率，每年 Xcode 都有很多新的功能和改进，虽然出 Bug 和闪退的问题依旧存在，依旧是开发者们诟病的一点，但是，苹果爸爸在改善开发者的工作环境和提高 Xcode 的友好度作出的努力，大家还是有目共睹的，至少黑夜模式照顾到了我们这群深夜加班~~努力写 Bug~~ ，呸，努力写改变世界的代码的工程狮。\n\n本文是我一份小小的学习笔记，请各位批判性地看，肯定有写的不好或错误的地方，请斧正，我定虚心接受。","source":"_posts/Xcode 10 新特性.md","raw":"---\ntitle: What's new in Xcode 10\ndate: 2018-06-15 17:25:21\ntags:\n- WWDC2018\ntypora-copy-images-to: ipic\n---\n\n要让开发效率提高，写更多的 ~~bug~~ ，呸，更多改变世界的代码，我们就需要先了解每个苹果系列开发者必须使用的工具，就是今天要讲的主角 —— Xcode 10\n\n<!--more-->\n\n## 关于 Xcode 10\n\nXcode 在每年的 [WWDC](https://developer.apple.com/videos/wwdc2018/) 都会有所改进，今年也不例外，如约而至降临于六月五号。同样是先发布 [beta](https://developer.apple.com/download/) 版，正式版将在秋季发布于新的 App Store 上（新版的 App Store 还挺好看的，欢心荡漾中 :] ）\n\n### 平台限制\n\nXcode 10 现在只有 beta 版，只能安装在 mac 10.13.4 及以上的版本，如果升级了最新的 beta 版系统 Mojave 还可以尝试一下黑夜模式，下面会说到。\n\n### SDK\n\nbeta 版包含了新发布的 iOS 12, watchOS 5, macOS 10.14 以及 tvOS 12 的 SDK 开发工具包。\n\n### 下载安装\n\n首先下载 [.xip 安装包](https://download.developer.apple.com/Developer_Tools/Xcode_10_Beta/Xcode_10_Beta.xip)，解压放到 Applications 文件夹就可以了。使用 beta 版的 command line tools ，在 iTerm 或自带的 Terminals 中执行命令：\n\n```Shell\nxcode-select -s <path to Xcode>\n```\n\n对了，Xcode 10 beta 版是可以与原有的 Xcode 共存的。\n\n### 什么被弃用了？\n\nXcode 每年更新总会弃用一些旧的标准或工具，今年也不例外。Xcode 10 beta 今年对如下的几项动了刀子：\n\n- macOS 10.14 SDK 不再支持编译 32 位的应用，以后再见不到 i386 了。\n\n- 对 SVN 的支持也取消了，同时现在可直接使用以下源代码管理平台：\n\n  - Bitbucket Cloud 和 Bitbucket Server\n  - Github 和 Github Enterprise\n  - Gitlab.com 和 Gitlab Self-hosted\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rvegj.png)\n\n-  libstdc++ 自从 Xcode 8 宣布不建议使用后，终于在 Xcode 10 中被直接斩掉。其中包括 stdc++, stdc++.6.0.9, libstdc++.6.0.9.tbd（新的动态库）,  libstdc++.6.0.9.dylib（旧的动态库）。经过 Apple 两年对 libc++ 的优化和推广，Xcode 10 中 C++ 工程需要链接 libc++ 已经箭在弦上，如果项目中使用到 libstdc++ ，就像我一样，暂时可以做到的是继续使用 Xcode 9 苟一段时间，或将 Xcode 9 中 关于 libstdc++ 的文件复制一份到 Xcode 10 中。不过长久来看，还是将使用到 libstdc++ 的 API 的库重新修改代码，链接到 libc++ 好一点。\n\n- OpenGL , OpenGL|ES , OpenCL 进入废弃列表，原有 API 还是可用，但说不定以后的某一天跟 i386 一样突然就没了，对游戏开发和图像处理工具等 App 影响还是蛮大的。对此，苹果建议使用 Metal 来进行图像处理，声称可以更大程度地使用到 GPU 。\n\n- 还有一些其他的 API ，请见 [Apple Developer Documentation](https://developer.apple.com/documentation/) 。\n\n## 新特性\n\nXcode 10 beta 的新特性是我们比较关心的，涉及到方方面面，接下来我们看看今年的Xcode 10 给我们带来了什么？\n\n### 通用层面\n\n#### Dark Mode\n\n说到 macOS Mojave ，首先想到的应该就是 Dark Mode 黑夜模式了，看 WWDC Keynote 的时候，桌面从白天变成黑夜，真的惊艳到。Mojave 的黑夜模式不仅仅是系统层面，App 也可以融入这种深沉的黑色。当然了，Xcode 10 beta 版也在众多支持黑夜模式的首发 App 中，打开看一下：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/moj7b.png)\n\n对这个有兴趣可以看看 [Introducing Dark Mode](https://developer.apple.com/videos/play/wwdc2018/210/) 。\n\n#### Library 的位置改变了\n\n用多了 storyboard ，我们都知道，每次从 Inspectors 底部的 Library(库内容) 中将各种组件拉出来放到 storyboard 为我们设置好的画布上，是一件很舒服的事情。\n\n从 Xcode 10 开始，Library 不再内嵌于 Inspectors 。而是放到 Xcode 右上角 Configure editor area 的左侧：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/mpxl8.png)\n\n点击后会弹出一个重叠窗口，就想 Spotlight Search 一样。窗口呈现的内容会随当前打开的文件的不同而不同，譬如，如果当前是代码文件，则显示 Code Snippets ，如果当前是 storyboard ，那么会显示各种可拖拉的组件：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dfceb.png)\n\n在将组件拖动放置到文件中时，弹出的重叠窗口会消失，如果不想它消失，则在拖拉组件的时候按住 Option(⌥) 键即可。\n\n对了，弹出的重叠窗口可以左右拉伸。激活的话，还可以通过 View > Libraries 中选择打开，也可以通过快捷键 ⇧+⌘+L 。\n\n长按按钮可以选择查看 Media Library ，也就是添加到项目中的图片等。同样的，在 View > Libraries 中选择，快捷键是 ⇧+⌘+M 。\n\n个人觉得，这个更新操作比之前稍微繁杂了一些，但是一次性展示出来的内容更多了些，各有优劣吧感觉。\n\n#### Scheme\n\n新建的 scheme 默认是 Shared 的状态，如果想建立私有的 scheme ，则在 Manage Schemes 中去掉勾选。\n\nScheme 的选择和运行设备的选择都可以通过键盘快捷键来操作，这是要解放鼠标？\n\n快捷键分别是 ⌃+0 和 ⌃+⇧+0 ，当弹出 popup 后，可以键入字符或使用方向键来高亮 scheme 或设备，并回车选择。\n\n### Source Editor\n\n#### mutil-cursor editing (多行同时输入)\n\n像 Sublime Text 一样，支持多行同时输入了。以前一个 Alert 的提示语要复制粘贴粘贴粘贴粘贴的时代终于离我们而去。\n\n包括鼠标点击方式 ⌃+⇧+Click ，或通过选择列 ⌥+Click+Drag ，或通过键盘的 ⌃+⇧+Up 选择上一列，或 ⌃+⇧+Down 选择下一列。\n\n#### 可以折叠代码了，嘿嘿\n\nXcode 9中，在 `if` , `func` 等关键字处 ⌘+Click 可以看到代码块所占的所有行，而在 Xcode 10 beta 中，还可以激活 code folding 的 popup ，在弹出的 popup 选择 Fold 就可以折叠代码了。\n\n不想每次都 ⌘+Click ，可以在 Xcode > Preferences > Text Editing > Show， 勾选 Code folding ribbon 。就可以看到在 Editor 的内部左侧，显示的行数的右侧有标志条，点击就可以直接折叠代码了。\n\n还可以通过 Editor > Code Folding 选择折叠当前打开文件**所有**的代码结构，甚至是注释。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zd5zl.png)\n\nXcode 10 beta 中的处于版本管理状态的工程，可以看到开发者所作出的修改和在版本控制服务器上未被 pull 下来的提交。这个的标志条是在代码行数的左侧。\n\n#### 查找和选择\n\n以前有一种情况是：我们想改变文件内的静态函数名、函数内的变量名、静态变量名的时候，修改之后需要整个文件审视一遍，或让 Xcode 通过编译错误提醒我们。现在，在 Xcode 10 beta 中，可以通过 Editor > Structure > Select all Symbols 选择光标所在的函数或变量的 symbols ，就可以做到改一处而改动所有。\n\n当我们要选择当前文件下查找到的所有结果，可以先执行一次查找 ⌘+F ，然后 Find > Select All Find Matches 进行全选，就可以修改所有结果。\n\n但是，当我们不想选择当前文件下的所有查找到的结果，而是选择某一段代码中的包含的将被查找到的结果，可以先进行查找，然后选择要查找的那段代码， Find > Select Find Matches in Selection ，就可以选择到某段代码中的所有查找到的结果。\n\n#### overscroll\n\n打开 Xcode 10 beta 版的 Source Editor 时，滑动到最下面时，出现了一大片空白，如下图白色框框所示：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/897w4.png)\n\n这不是 Xcode 的 Bug ，而是 10 beta 版的新功能 overscroll 。以前版本的 Xcode ，在文件末尾添加函数的时候，视线只能一直盯着最下面几行，或者提前先使用几个空行做占位，让视线更趋近于 Source Editor 的中间。现在有了 overscroll 之后，滚动到文件末尾，Xcode 会预留更多空间，使 Source Editor 可以向下再滚动一段距离（估计只是修改了 Source Editor 的 ScrollerView 的 inset 。:] ）\n\n可滚动的距离也可以设置，在 Preference > Text Editing > Editor Overscroll 选择距离级别，分别有 None, Small, Medium, Large ，见名知意，就不多阐述了。\n\n#### Quick Help\n\n右侧 Quick Help 的 layout 也修改了，可读性更强。普天同庆啊~\n\nQuick Help 和 Documentation Viewer 的代码样式跟用户当前使用的主题是一样的，整体看起来更和谐一些。\n\n### New Build System\n\nXcode 10 使用了新的 Build System ，当然也可以选择使用老的 Build System ，通过 File > Project/Workspace Settings 中选择：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aykpw.png)\n\n这样的话，在构建时， Toolbar 的 View Activity 的 Activity Indicators 区域会出现一个橘黄色的小锤子：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/u2dp7.png)\n\n新的 Build System 保证了构建时的可靠性和性能，能捕获到项目的配置问题。在我们没有能很好地使用新的 Build System 之前，使用新的工具总会遇到问题，常见的一些编译问题的解释和解决方法在 [Xcode Help](https://help.apple.com/xcode/mac/current/#/dev621201fb0) 。\n\n### Testing\n\n#### 乱序\n\n首先，支持乱序。Test Bundle 中的方法可以不按顺序进行测试，默认是关闭的，可以通过 Edit Scheme > Test > Info > Tests 选择任意 Test Bundle ，打开 Options 勾选 Randomize execution order 来开启。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tn1xw.png)\n\n#### 并行测试\n\n上图还透露了一个信息，在 Randomize execution order 上面，还有个选项 Execute in parallel on Simulator ，那就是可以并行测试了（并发已经满足不了广大开发者的需求了）。只限于 macOS 的 unit tests ，iOS 模拟器和 tvOS 模拟器的 unit 和 UI tests 。因为，要达到真正的并行，真机肯定是不支持的。并行测试时，Xcode 会开启多个线程运行多个我们选定的模拟器，然后在上面进行测试，在 Report navigator 也会记录线程启动和测试的日志，你会看到很多诸如 Clone X of iPhone X 的信息。\n\n命令行 `xcodebuild` 也支持并行测试，只需要加上参数 `-parallel-testing-enabled YES|NO ` 去重写 seheme 的 pre-target 就可以了。还可以通过 `-parallel-testing-worker-count` 和 `-maximum-parallel-testing-workers` 控制测试模拟器的数量。\n\n具体请打开 iTerm 或 Terminals 敲 `xcodebuild -help` 。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f5vxe.png)\n\n#### 可变的测试集\n\n新建的测试默认状态是 enabled 的，这样我们在 Test navigator 中可以通过点击测试类或测试方法右边的运行按钮进行测试。\n\n然而，如果想固定当前的测试集，排除新建的测试类或方法时，可以取消勾选 Automatically include new tests ，见上图。此时测试方法的状态是 disabled ，将无法在 Test navigator 中进行测试，但可以在类中该方法的左侧点击运行按钮进行测试。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4jdy0.png)\n\n假设过了一段时间，想把 disabled 状态的测试类或方法变成 enabled ，在 Edit Scheme 中可以修改其状态。这样我们可以控制每次测试所运行的测试集，不必浪费时间去做一些不需要做的测试。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p99x5.png)\n\n### IB\n\n- 画布的渲染也并行了，scenes 的放大缩小和组件的修改，据说性能都得到提升。\n\n\n- 原来 storyboard 右下角的 \"Embed in Stack View\" 按钮也改成了 popup ，提供更多选项供开发者选择 embed ，如下图白色框框。\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kij8a.png) \n\n  其中的 View Without Inset 会将选择的所有 View 紧凑地放在一个 Super View 里面。\n\n\n- 打开 Xcode 5 的 .nib 或 .xib 文件，会提示格式问题并自动更新到当前版本所使用的格式。\n- Attributes Inspector 的字体支持 iOS 11 发布的 Large Title ，且自定义字体可以看到样式预览，这个还挺不错的。\n- 同样是 Attributes Inspector 中，named color 和 图片右侧有个小按钮可以连接到 Assets ，在这个小按钮上 ⌥+Click 可以在 Assistant Editor 中打开。\n\n### Asset Catalog\n\nmacOS 10.14 有了 Dark Mode 之后，Assets 除了之前普通模式下单一的图片和 named color ，也支持 Light 和 Dark 。并且有个 High Contrast 的选项可以勾选，所以 macOS 开发如果要加入 Dark Mode ，要上传的图片和 named color 从原来的三张、一个颜色变成十三张图片、六个颜色，我的🐴🦆。\n\n不过感谢 Dark Mode 福泽，asset 的背景也可以切换成 Light , Dark , System Appearance(跟随系统) 。切换的按钮在 assets 的左下角。对了，View Debugger 也有这个切换背景的功能，也就是那个调试 UI 的界面。\n\n支持 Carplay assets，国内还没普及，暂时应该没多大用处。\n\n支持 ARKit 3D `ARReferenceObject` assets 。\n\n### Debugging\n\nDebugging 功能的完善主要是针对 macOS 开发：\n\n- Disk Gauge Report 加入了已关闭文件的大小的显示和对硬盘的读写随时间推进的变化表。\n\n- Named color 在 View Debugger 的  Inspector 显示颜色的名称和是否属于系统颜色，仅 macOS 开发才有。\n\n- 当 macOS App 在运行过程中，可以通过 Debug > View Debugging > Appearance menu 或者调试工具 Memory Graph 右边新加的按钮或 Touch Bar 来切换 Light 或 Dark 模式\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9nth5.png)\n\n  ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a5le3.png)\n\n\n- Metal Frame Debugger ，笔者尚未深入了解，暂时不介绍了。\n\n### Playground\n\nPlayground 引入了一个增量执行? ( execute code incrementally ) 的 workflow 。\n\n1. 在 Xcode 10 中，新建 Playground 默认是 Manually Run 。\n\n2. 当写完代码后，按 ⇧+Return 或点击代码左侧的执行按钮，Playground 会进入运行模式，执行到指定位置( ⇧+Return 或点击的执行按钮所在的上一行)，然后进入等待模式，没有结束执行。\n\n   ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/t5tiz.png)\n\n3. 我们可以不断地执行第2步，Playground 只会编译上一次暂停执行的位置到我们 ⇧+Return 或点击执行按钮的位置。\n\n   ![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/opr4z.png)\n\n4. 点击 Stop Playground 结束操作 Playground 。\n\n### Localization\n\nXcode 10 beta 版支持新的国际化 workflow ，使用新的国际化文件 .xcloc 取代以前的 .xliff 。喔，不，应该是包含 .xliff 。还支持其他可能需要国际化的文件，如图片。\n\n有兴趣的同学可以看看 [New Localization Workflows in Xcode 10](https://developer.apple.com/videos/play/wwdc2018/404/) 。\n\n### Signing And Distribution\n\n今年的 Xcode 10 完善了 macOS App 的发布和认证， Organizer Distribution 的 Developer ID 选项提供了上传到 Apple 进行认证的功能。Archive 后， Distribute App > Developer ID ，可以选择 Upload 上传到 Apple 进行认证或 Export 到本地保存。要上传应用，需要在 Xcode 中添加苹果账号，并填写所需的App Store Connect role与提供者资格，此外，认证应用还需要有开发者ID证书签名。\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97fpw.png)\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a05lh.png)\n\n在上传的应用被认证后，你可以在 Organizer 中选择你的档案并点击 Show Status Log 按钮，这样就能查看应用的状态。当收到认证通过的通知后，就可以从 Organizer 中将 App Export 出来，保存下来的 App 包含一个附加的票据，就意味着可以发布了。\n\n## 最后说一句\n\n今年的 WWDC 没有专题讲述 Xcode 10 。很多都是穿插在各个 Session 中。理解并用好一个工具能提高我们开发的效率，每年 Xcode 都有很多新的功能和改进，虽然出 Bug 和闪退的问题依旧存在，依旧是开发者们诟病的一点，但是，苹果爸爸在改善开发者的工作环境和提高 Xcode 的友好度作出的努力，大家还是有目共睹的，至少黑夜模式照顾到了我们这群深夜加班~~努力写 Bug~~ ，呸，努力写改变世界的代码的工程狮。\n\n本文是我一份小小的学习笔记，请各位批判性地看，肯定有写的不好或错误的地方，请斧正，我定虚心接受。","slug":"Xcode 10 新特性","published":1,"updated":"2018-11-07T02:23:39.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjonym6e5000uqu0xsj9bc86d","content":"<p>要让开发效率提高，写更多的 <del>bug</del> ，呸，更多改变世界的代码，我们就需要先了解每个苹果系列开发者必须使用的工具，就是今天要讲的主角 —— Xcode 10</p>\n<a id=\"more\"></a>\n<h2 id=\"关于-Xcode-10\"><a href=\"#关于-Xcode-10\" class=\"headerlink\" title=\"关于 Xcode 10\"></a>关于 Xcode 10</h2><p>Xcode 在每年的 <a href=\"https://developer.apple.com/videos/wwdc2018/\" target=\"_blank\" rel=\"external\">WWDC</a> 都会有所改进，今年也不例外，如约而至降临于六月五号。同样是先发布 <a href=\"https://developer.apple.com/download/\" target=\"_blank\" rel=\"external\">beta</a> 版，正式版将在秋季发布于新的 App Store 上（新版的 App Store 还挺好看的，欢心荡漾中 :] ）</p>\n<h3 id=\"平台限制\"><a href=\"#平台限制\" class=\"headerlink\" title=\"平台限制\"></a>平台限制</h3><p>Xcode 10 现在只有 beta 版，只能安装在 mac 10.13.4 及以上的版本，如果升级了最新的 beta 版系统 Mojave 还可以尝试一下黑夜模式，下面会说到。</p>\n<h3 id=\"SDK\"><a href=\"#SDK\" class=\"headerlink\" title=\"SDK\"></a>SDK</h3><p>beta 版包含了新发布的 iOS 12, watchOS 5, macOS 10.14 以及 tvOS 12 的 SDK 开发工具包。</p>\n<h3 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h3><p>首先下载 <a href=\"https://download.developer.apple.com/Developer_Tools/Xcode_10_Beta/Xcode_10_Beta.xip\" target=\"_blank\" rel=\"external\">.xip 安装包</a>，解压放到 Applications 文件夹就可以了。使用 beta 版的 command line tools ，在 iTerm 或自带的 Terminals 中执行命令：</p>\n<pre><code class=\"Shell\">xcode-select -s &lt;path to Xcode&gt;\n</code></pre>\n<p>对了，Xcode 10 beta 版是可以与原有的 Xcode 共存的。</p>\n<h3 id=\"什么被弃用了？\"><a href=\"#什么被弃用了？\" class=\"headerlink\" title=\"什么被弃用了？\"></a>什么被弃用了？</h3><p>Xcode 每年更新总会弃用一些旧的标准或工具，今年也不例外。Xcode 10 beta 今年对如下的几项动了刀子：</p>\n<ul>\n<li><p>macOS 10.14 SDK 不再支持编译 32 位的应用，以后再见不到 i386 了。</p>\n</li>\n<li><p>对 SVN 的支持也取消了，同时现在可直接使用以下源代码管理平台：</p>\n<ul>\n<li>Bitbucket Cloud 和 Bitbucket Server</li>\n<li>Github 和 Github Enterprise</li>\n<li>Gitlab.com 和 Gitlab Self-hosted</li>\n</ul>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rvegj.png\" alt=\"\"></p>\n</li>\n<li><p>libstdc++ 自从 Xcode 8 宣布不建议使用后，终于在 Xcode 10 中被直接斩掉。其中包括 stdc++, stdc++.6.0.9, libstdc++.6.0.9.tbd（新的动态库）,  libstdc++.6.0.9.dylib（旧的动态库）。经过 Apple 两年对 libc++ 的优化和推广，Xcode 10 中 C++ 工程需要链接 libc++ 已经箭在弦上，如果项目中使用到 libstdc++ ，就像我一样，暂时可以做到的是继续使用 Xcode 9 苟一段时间，或将 Xcode 9 中 关于 libstdc++ 的文件复制一份到 Xcode 10 中。不过长久来看，还是将使用到 libstdc++ 的 API 的库重新修改代码，链接到 libc++ 好一点。</p>\n</li>\n<li><p>OpenGL , OpenGL|ES , OpenCL 进入废弃列表，原有 API 还是可用，但说不定以后的某一天跟 i386 一样突然就没了，对游戏开发和图像处理工具等 App 影响还是蛮大的。对此，苹果建议使用 Metal 来进行图像处理，声称可以更大程度地使用到 GPU 。</p>\n</li>\n<li><p>还有一些其他的 API ，请见 <a href=\"https://developer.apple.com/documentation/\" target=\"_blank\" rel=\"external\">Apple Developer Documentation</a> 。</p>\n</li>\n</ul>\n<h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><p>Xcode 10 beta 的新特性是我们比较关心的，涉及到方方面面，接下来我们看看今年的Xcode 10 给我们带来了什么？</p>\n<h3 id=\"通用层面\"><a href=\"#通用层面\" class=\"headerlink\" title=\"通用层面\"></a>通用层面</h3><h4 id=\"Dark-Mode\"><a href=\"#Dark-Mode\" class=\"headerlink\" title=\"Dark Mode\"></a>Dark Mode</h4><p>说到 macOS Mojave ，首先想到的应该就是 Dark Mode 黑夜模式了，看 WWDC Keynote 的时候，桌面从白天变成黑夜，真的惊艳到。Mojave 的黑夜模式不仅仅是系统层面，App 也可以融入这种深沉的黑色。当然了，Xcode 10 beta 版也在众多支持黑夜模式的首发 App 中，打开看一下：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/moj7b.png\" alt=\"\"></p>\n<p>对这个有兴趣可以看看 <a href=\"https://developer.apple.com/videos/play/wwdc2018/210/\" target=\"_blank\" rel=\"external\">Introducing Dark Mode</a> 。</p>\n<h4 id=\"Library-的位置改变了\"><a href=\"#Library-的位置改变了\" class=\"headerlink\" title=\"Library 的位置改变了\"></a>Library 的位置改变了</h4><p>用多了 storyboard ，我们都知道，每次从 Inspectors 底部的 Library(库内容) 中将各种组件拉出来放到 storyboard 为我们设置好的画布上，是一件很舒服的事情。</p>\n<p>从 Xcode 10 开始，Library 不再内嵌于 Inspectors 。而是放到 Xcode 右上角 Configure editor area 的左侧：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/mpxl8.png\" alt=\"\"></p>\n<p>点击后会弹出一个重叠窗口，就想 Spotlight Search 一样。窗口呈现的内容会随当前打开的文件的不同而不同，譬如，如果当前是代码文件，则显示 Code Snippets ，如果当前是 storyboard ，那么会显示各种可拖拉的组件：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dfceb.png\" alt=\"\"></p>\n<p>在将组件拖动放置到文件中时，弹出的重叠窗口会消失，如果不想它消失，则在拖拉组件的时候按住 Option(⌥) 键即可。</p>\n<p>对了，弹出的重叠窗口可以左右拉伸。激活的话，还可以通过 View &gt; Libraries 中选择打开，也可以通过快捷键 ⇧+⌘+L 。</p>\n<p>长按按钮可以选择查看 Media Library ，也就是添加到项目中的图片等。同样的，在 View &gt; Libraries 中选择，快捷键是 ⇧+⌘+M 。</p>\n<p>个人觉得，这个更新操作比之前稍微繁杂了一些，但是一次性展示出来的内容更多了些，各有优劣吧感觉。</p>\n<h4 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h4><p>新建的 scheme 默认是 Shared 的状态，如果想建立私有的 scheme ，则在 Manage Schemes 中去掉勾选。</p>\n<p>Scheme 的选择和运行设备的选择都可以通过键盘快捷键来操作，这是要解放鼠标？</p>\n<p>快捷键分别是 ⌃+0 和 ⌃+⇧+0 ，当弹出 popup 后，可以键入字符或使用方向键来高亮 scheme 或设备，并回车选择。</p>\n<h3 id=\"Source-Editor\"><a href=\"#Source-Editor\" class=\"headerlink\" title=\"Source Editor\"></a>Source Editor</h3><h4 id=\"mutil-cursor-editing-多行同时输入\"><a href=\"#mutil-cursor-editing-多行同时输入\" class=\"headerlink\" title=\"mutil-cursor editing (多行同时输入)\"></a>mutil-cursor editing (多行同时输入)</h4><p>像 Sublime Text 一样，支持多行同时输入了。以前一个 Alert 的提示语要复制粘贴粘贴粘贴粘贴的时代终于离我们而去。</p>\n<p>包括鼠标点击方式 ⌃+⇧+Click ，或通过选择列 ⌥+Click+Drag ，或通过键盘的 ⌃+⇧+Up 选择上一列，或 ⌃+⇧+Down 选择下一列。</p>\n<h4 id=\"可以折叠代码了，嘿嘿\"><a href=\"#可以折叠代码了，嘿嘿\" class=\"headerlink\" title=\"可以折叠代码了，嘿嘿\"></a>可以折叠代码了，嘿嘿</h4><p>Xcode 9中，在 <code>if</code> , <code>func</code> 等关键字处 ⌘+Click 可以看到代码块所占的所有行，而在 Xcode 10 beta 中，还可以激活 code folding 的 popup ，在弹出的 popup 选择 Fold 就可以折叠代码了。</p>\n<p>不想每次都 ⌘+Click ，可以在 Xcode &gt; Preferences &gt; Text Editing &gt; Show， 勾选 Code folding ribbon 。就可以看到在 Editor 的内部左侧，显示的行数的右侧有标志条，点击就可以直接折叠代码了。</p>\n<p>还可以通过 Editor &gt; Code Folding 选择折叠当前打开文件<strong>所有</strong>的代码结构，甚至是注释。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zd5zl.png\" alt=\"\"></p>\n<p>Xcode 10 beta 中的处于版本管理状态的工程，可以看到开发者所作出的修改和在版本控制服务器上未被 pull 下来的提交。这个的标志条是在代码行数的左侧。</p>\n<h4 id=\"查找和选择\"><a href=\"#查找和选择\" class=\"headerlink\" title=\"查找和选择\"></a>查找和选择</h4><p>以前有一种情况是：我们想改变文件内的静态函数名、函数内的变量名、静态变量名的时候，修改之后需要整个文件审视一遍，或让 Xcode 通过编译错误提醒我们。现在，在 Xcode 10 beta 中，可以通过 Editor &gt; Structure &gt; Select all Symbols 选择光标所在的函数或变量的 symbols ，就可以做到改一处而改动所有。</p>\n<p>当我们要选择当前文件下查找到的所有结果，可以先执行一次查找 ⌘+F ，然后 Find &gt; Select All Find Matches 进行全选，就可以修改所有结果。</p>\n<p>但是，当我们不想选择当前文件下的所有查找到的结果，而是选择某一段代码中的包含的将被查找到的结果，可以先进行查找，然后选择要查找的那段代码， Find &gt; Select Find Matches in Selection ，就可以选择到某段代码中的所有查找到的结果。</p>\n<h4 id=\"overscroll\"><a href=\"#overscroll\" class=\"headerlink\" title=\"overscroll\"></a>overscroll</h4><p>打开 Xcode 10 beta 版的 Source Editor 时，滑动到最下面时，出现了一大片空白，如下图白色框框所示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/897w4.png\" alt=\"\"></p>\n<p>这不是 Xcode 的 Bug ，而是 10 beta 版的新功能 overscroll 。以前版本的 Xcode ，在文件末尾添加函数的时候，视线只能一直盯着最下面几行，或者提前先使用几个空行做占位，让视线更趋近于 Source Editor 的中间。现在有了 overscroll 之后，滚动到文件末尾，Xcode 会预留更多空间，使 Source Editor 可以向下再滚动一段距离（估计只是修改了 Source Editor 的 ScrollerView 的 inset 。:] ）</p>\n<p>可滚动的距离也可以设置，在 Preference &gt; Text Editing &gt; Editor Overscroll 选择距离级别，分别有 None, Small, Medium, Large ，见名知意，就不多阐述了。</p>\n<h4 id=\"Quick-Help\"><a href=\"#Quick-Help\" class=\"headerlink\" title=\"Quick Help\"></a>Quick Help</h4><p>右侧 Quick Help 的 layout 也修改了，可读性更强。普天同庆啊~</p>\n<p>Quick Help 和 Documentation Viewer 的代码样式跟用户当前使用的主题是一样的，整体看起来更和谐一些。</p>\n<h3 id=\"New-Build-System\"><a href=\"#New-Build-System\" class=\"headerlink\" title=\"New Build System\"></a>New Build System</h3><p>Xcode 10 使用了新的 Build System ，当然也可以选择使用老的 Build System ，通过 File &gt; Project/Workspace Settings 中选择：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aykpw.png\" alt=\"\"></p>\n<p>这样的话，在构建时， Toolbar 的 View Activity 的 Activity Indicators 区域会出现一个橘黄色的小锤子：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/u2dp7.png\" alt=\"\"></p>\n<p>新的 Build System 保证了构建时的可靠性和性能，能捕获到项目的配置问题。在我们没有能很好地使用新的 Build System 之前，使用新的工具总会遇到问题，常见的一些编译问题的解释和解决方法在 <a href=\"https://help.apple.com/xcode/mac/current/#/dev621201fb0\" target=\"_blank\" rel=\"external\">Xcode Help</a> 。</p>\n<h3 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h3><h4 id=\"乱序\"><a href=\"#乱序\" class=\"headerlink\" title=\"乱序\"></a>乱序</h4><p>首先，支持乱序。Test Bundle 中的方法可以不按顺序进行测试，默认是关闭的，可以通过 Edit Scheme &gt; Test &gt; Info &gt; Tests 选择任意 Test Bundle ，打开 Options 勾选 Randomize execution order 来开启。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tn1xw.png\" alt=\"\"></p>\n<h4 id=\"并行测试\"><a href=\"#并行测试\" class=\"headerlink\" title=\"并行测试\"></a>并行测试</h4><p>上图还透露了一个信息，在 Randomize execution order 上面，还有个选项 Execute in parallel on Simulator ，那就是可以并行测试了（并发已经满足不了广大开发者的需求了）。只限于 macOS 的 unit tests ，iOS 模拟器和 tvOS 模拟器的 unit 和 UI tests 。因为，要达到真正的并行，真机肯定是不支持的。并行测试时，Xcode 会开启多个线程运行多个我们选定的模拟器，然后在上面进行测试，在 Report navigator 也会记录线程启动和测试的日志，你会看到很多诸如 Clone X of iPhone X 的信息。</p>\n<p>命令行 <code>xcodebuild</code> 也支持并行测试，只需要加上参数 <code>-parallel-testing-enabled YES|NO</code> 去重写 seheme 的 pre-target 就可以了。还可以通过 <code>-parallel-testing-worker-count</code> 和 <code>-maximum-parallel-testing-workers</code> 控制测试模拟器的数量。</p>\n<p>具体请打开 iTerm 或 Terminals 敲 <code>xcodebuild -help</code> 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f5vxe.png\" alt=\"\"></p>\n<h4 id=\"可变的测试集\"><a href=\"#可变的测试集\" class=\"headerlink\" title=\"可变的测试集\"></a>可变的测试集</h4><p>新建的测试默认状态是 enabled 的，这样我们在 Test navigator 中可以通过点击测试类或测试方法右边的运行按钮进行测试。</p>\n<p>然而，如果想固定当前的测试集，排除新建的测试类或方法时，可以取消勾选 Automatically include new tests ，见上图。此时测试方法的状态是 disabled ，将无法在 Test navigator 中进行测试，但可以在类中该方法的左侧点击运行按钮进行测试。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4jdy0.png\" alt=\"\"></p>\n<p>假设过了一段时间，想把 disabled 状态的测试类或方法变成 enabled ，在 Edit Scheme 中可以修改其状态。这样我们可以控制每次测试所运行的测试集，不必浪费时间去做一些不需要做的测试。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p99x5.png\" alt=\"\"></p>\n<h3 id=\"IB\"><a href=\"#IB\" class=\"headerlink\" title=\"IB\"></a>IB</h3><ul>\n<li>画布的渲染也并行了，scenes 的放大缩小和组件的修改，据说性能都得到提升。</li>\n</ul>\n<ul>\n<li><p>原来 storyboard 右下角的 “Embed in Stack View” 按钮也改成了 popup ，提供更多选项供开发者选择 embed ，如下图白色框框。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kij8a.png\" alt=\"\"> </p>\n<p>其中的 View Without Inset 会将选择的所有 View 紧凑地放在一个 Super View 里面。</p>\n</li>\n</ul>\n<ul>\n<li>打开 Xcode 5 的 .nib 或 .xib 文件，会提示格式问题并自动更新到当前版本所使用的格式。</li>\n<li>Attributes Inspector 的字体支持 iOS 11 发布的 Large Title ，且自定义字体可以看到样式预览，这个还挺不错的。</li>\n<li>同样是 Attributes Inspector 中，named color 和 图片右侧有个小按钮可以连接到 Assets ，在这个小按钮上 ⌥+Click 可以在 Assistant Editor 中打开。</li>\n</ul>\n<h3 id=\"Asset-Catalog\"><a href=\"#Asset-Catalog\" class=\"headerlink\" title=\"Asset Catalog\"></a>Asset Catalog</h3><p>macOS 10.14 有了 Dark Mode 之后，Assets 除了之前普通模式下单一的图片和 named color ，也支持 Light 和 Dark 。并且有个 High Contrast 的选项可以勾选，所以 macOS 开发如果要加入 Dark Mode ，要上传的图片和 named color 从原来的三张、一个颜色变成十三张图片、六个颜色，我的🐴🦆。</p>\n<p>不过感谢 Dark Mode 福泽，asset 的背景也可以切换成 Light , Dark , System Appearance(跟随系统) 。切换的按钮在 assets 的左下角。对了，View Debugger 也有这个切换背景的功能，也就是那个调试 UI 的界面。</p>\n<p>支持 Carplay assets，国内还没普及，暂时应该没多大用处。</p>\n<p>支持 ARKit 3D <code>ARReferenceObject</code> assets 。</p>\n<h3 id=\"Debugging\"><a href=\"#Debugging\" class=\"headerlink\" title=\"Debugging\"></a>Debugging</h3><p>Debugging 功能的完善主要是针对 macOS 开发：</p>\n<ul>\n<li><p>Disk Gauge Report 加入了已关闭文件的大小的显示和对硬盘的读写随时间推进的变化表。</p>\n</li>\n<li><p>Named color 在 View Debugger 的  Inspector 显示颜色的名称和是否属于系统颜色，仅 macOS 开发才有。</p>\n</li>\n<li><p>当 macOS App 在运行过程中，可以通过 Debug &gt; View Debugging &gt; Appearance menu 或者调试工具 Memory Graph 右边新加的按钮或 Touch Bar 来切换 Light 或 Dark 模式</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9nth5.png\" alt=\"\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a5le3.png\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li>Metal Frame Debugger ，笔者尚未深入了解，暂时不介绍了。</li>\n</ul>\n<h3 id=\"Playground\"><a href=\"#Playground\" class=\"headerlink\" title=\"Playground\"></a>Playground</h3><p>Playground 引入了一个增量执行? ( execute code incrementally ) 的 workflow 。</p>\n<ol>\n<li><p>在 Xcode 10 中，新建 Playground 默认是 Manually Run 。</p>\n</li>\n<li><p>当写完代码后，按 ⇧+Return 或点击代码左侧的执行按钮，Playground 会进入运行模式，执行到指定位置( ⇧+Return 或点击的执行按钮所在的上一行)，然后进入等待模式，没有结束执行。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/t5tiz.png\" alt=\"\"></p>\n</li>\n<li><p>我们可以不断地执行第2步，Playground 只会编译上一次暂停执行的位置到我们 ⇧+Return 或点击执行按钮的位置。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/opr4z.png\" alt=\"\"></p>\n</li>\n<li><p>点击 Stop Playground 结束操作 Playground 。</p>\n</li>\n</ol>\n<h3 id=\"Localization\"><a href=\"#Localization\" class=\"headerlink\" title=\"Localization\"></a>Localization</h3><p>Xcode 10 beta 版支持新的国际化 workflow ，使用新的国际化文件 .xcloc 取代以前的 .xliff 。喔，不，应该是包含 .xliff 。还支持其他可能需要国际化的文件，如图片。</p>\n<p>有兴趣的同学可以看看 <a href=\"https://developer.apple.com/videos/play/wwdc2018/404/\" target=\"_blank\" rel=\"external\">New Localization Workflows in Xcode 10</a> 。</p>\n<h3 id=\"Signing-And-Distribution\"><a href=\"#Signing-And-Distribution\" class=\"headerlink\" title=\"Signing And Distribution\"></a>Signing And Distribution</h3><p>今年的 Xcode 10 完善了 macOS App 的发布和认证， Organizer Distribution 的 Developer ID 选项提供了上传到 Apple 进行认证的功能。Archive 后， Distribute App &gt; Developer ID ，可以选择 Upload 上传到 Apple 进行认证或 Export 到本地保存。要上传应用，需要在 Xcode 中添加苹果账号，并填写所需的App Store Connect role与提供者资格，此外，认证应用还需要有开发者ID证书签名。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97fpw.png\" alt=\"\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a05lh.png\" alt=\"\"></p>\n<p>在上传的应用被认证后，你可以在 Organizer 中选择你的档案并点击 Show Status Log 按钮，这样就能查看应用的状态。当收到认证通过的通知后，就可以从 Organizer 中将 App Export 出来，保存下来的 App 包含一个附加的票据，就意味着可以发布了。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>今年的 WWDC 没有专题讲述 Xcode 10 。很多都是穿插在各个 Session 中。理解并用好一个工具能提高我们开发的效率，每年 Xcode 都有很多新的功能和改进，虽然出 Bug 和闪退的问题依旧存在，依旧是开发者们诟病的一点，但是，苹果爸爸在改善开发者的工作环境和提高 Xcode 的友好度作出的努力，大家还是有目共睹的，至少黑夜模式照顾到了我们这群深夜加班<del>努力写 Bug</del> ，呸，努力写改变世界的代码的工程狮。</p>\n<p>本文是我一份小小的学习笔记，请各位批判性地看，肯定有写的不好或错误的地方，请斧正，我定虚心接受。</p>\n","excerpt":"<p>要让开发效率提高，写更多的 <del>bug</del> ，呸，更多改变世界的代码，我们就需要先了解每个苹果系列开发者必须使用的工具，就是今天要讲的主角 —— Xcode 10</p>","more":"<h2 id=\"关于-Xcode-10\"><a href=\"#关于-Xcode-10\" class=\"headerlink\" title=\"关于 Xcode 10\"></a>关于 Xcode 10</h2><p>Xcode 在每年的 <a href=\"https://developer.apple.com/videos/wwdc2018/\">WWDC</a> 都会有所改进，今年也不例外，如约而至降临于六月五号。同样是先发布 <a href=\"https://developer.apple.com/download/\">beta</a> 版，正式版将在秋季发布于新的 App Store 上（新版的 App Store 还挺好看的，欢心荡漾中 :] ）</p>\n<h3 id=\"平台限制\"><a href=\"#平台限制\" class=\"headerlink\" title=\"平台限制\"></a>平台限制</h3><p>Xcode 10 现在只有 beta 版，只能安装在 mac 10.13.4 及以上的版本，如果升级了最新的 beta 版系统 Mojave 还可以尝试一下黑夜模式，下面会说到。</p>\n<h3 id=\"SDK\"><a href=\"#SDK\" class=\"headerlink\" title=\"SDK\"></a>SDK</h3><p>beta 版包含了新发布的 iOS 12, watchOS 5, macOS 10.14 以及 tvOS 12 的 SDK 开发工具包。</p>\n<h3 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h3><p>首先下载 <a href=\"https://download.developer.apple.com/Developer_Tools/Xcode_10_Beta/Xcode_10_Beta.xip\">.xip 安装包</a>，解压放到 Applications 文件夹就可以了。使用 beta 版的 command line tools ，在 iTerm 或自带的 Terminals 中执行命令：</p>\n<pre><code class=\"Shell\">xcode-select -s &lt;path to Xcode&gt;\n</code></pre>\n<p>对了，Xcode 10 beta 版是可以与原有的 Xcode 共存的。</p>\n<h3 id=\"什么被弃用了？\"><a href=\"#什么被弃用了？\" class=\"headerlink\" title=\"什么被弃用了？\"></a>什么被弃用了？</h3><p>Xcode 每年更新总会弃用一些旧的标准或工具，今年也不例外。Xcode 10 beta 今年对如下的几项动了刀子：</p>\n<ul>\n<li><p>macOS 10.14 SDK 不再支持编译 32 位的应用，以后再见不到 i386 了。</p>\n</li>\n<li><p>对 SVN 的支持也取消了，同时现在可直接使用以下源代码管理平台：</p>\n<ul>\n<li>Bitbucket Cloud 和 Bitbucket Server</li>\n<li>Github 和 Github Enterprise</li>\n<li>Gitlab.com 和 Gitlab Self-hosted</li>\n</ul>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rvegj.png\" alt=\"\"></p>\n</li>\n<li><p>libstdc++ 自从 Xcode 8 宣布不建议使用后，终于在 Xcode 10 中被直接斩掉。其中包括 stdc++, stdc++.6.0.9, libstdc++.6.0.9.tbd（新的动态库）,  libstdc++.6.0.9.dylib（旧的动态库）。经过 Apple 两年对 libc++ 的优化和推广，Xcode 10 中 C++ 工程需要链接 libc++ 已经箭在弦上，如果项目中使用到 libstdc++ ，就像我一样，暂时可以做到的是继续使用 Xcode 9 苟一段时间，或将 Xcode 9 中 关于 libstdc++ 的文件复制一份到 Xcode 10 中。不过长久来看，还是将使用到 libstdc++ 的 API 的库重新修改代码，链接到 libc++ 好一点。</p>\n</li>\n<li><p>OpenGL , OpenGL|ES , OpenCL 进入废弃列表，原有 API 还是可用，但说不定以后的某一天跟 i386 一样突然就没了，对游戏开发和图像处理工具等 App 影响还是蛮大的。对此，苹果建议使用 Metal 来进行图像处理，声称可以更大程度地使用到 GPU 。</p>\n</li>\n<li><p>还有一些其他的 API ，请见 <a href=\"https://developer.apple.com/documentation/\">Apple Developer Documentation</a> 。</p>\n</li>\n</ul>\n<h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><p>Xcode 10 beta 的新特性是我们比较关心的，涉及到方方面面，接下来我们看看今年的Xcode 10 给我们带来了什么？</p>\n<h3 id=\"通用层面\"><a href=\"#通用层面\" class=\"headerlink\" title=\"通用层面\"></a>通用层面</h3><h4 id=\"Dark-Mode\"><a href=\"#Dark-Mode\" class=\"headerlink\" title=\"Dark Mode\"></a>Dark Mode</h4><p>说到 macOS Mojave ，首先想到的应该就是 Dark Mode 黑夜模式了，看 WWDC Keynote 的时候，桌面从白天变成黑夜，真的惊艳到。Mojave 的黑夜模式不仅仅是系统层面，App 也可以融入这种深沉的黑色。当然了，Xcode 10 beta 版也在众多支持黑夜模式的首发 App 中，打开看一下：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/moj7b.png\" alt=\"\"></p>\n<p>对这个有兴趣可以看看 <a href=\"https://developer.apple.com/videos/play/wwdc2018/210/\">Introducing Dark Mode</a> 。</p>\n<h4 id=\"Library-的位置改变了\"><a href=\"#Library-的位置改变了\" class=\"headerlink\" title=\"Library 的位置改变了\"></a>Library 的位置改变了</h4><p>用多了 storyboard ，我们都知道，每次从 Inspectors 底部的 Library(库内容) 中将各种组件拉出来放到 storyboard 为我们设置好的画布上，是一件很舒服的事情。</p>\n<p>从 Xcode 10 开始，Library 不再内嵌于 Inspectors 。而是放到 Xcode 右上角 Configure editor area 的左侧：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/mpxl8.png\" alt=\"\"></p>\n<p>点击后会弹出一个重叠窗口，就想 Spotlight Search 一样。窗口呈现的内容会随当前打开的文件的不同而不同，譬如，如果当前是代码文件，则显示 Code Snippets ，如果当前是 storyboard ，那么会显示各种可拖拉的组件：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dfceb.png\" alt=\"\"></p>\n<p>在将组件拖动放置到文件中时，弹出的重叠窗口会消失，如果不想它消失，则在拖拉组件的时候按住 Option(⌥) 键即可。</p>\n<p>对了，弹出的重叠窗口可以左右拉伸。激活的话，还可以通过 View &gt; Libraries 中选择打开，也可以通过快捷键 ⇧+⌘+L 。</p>\n<p>长按按钮可以选择查看 Media Library ，也就是添加到项目中的图片等。同样的，在 View &gt; Libraries 中选择，快捷键是 ⇧+⌘+M 。</p>\n<p>个人觉得，这个更新操作比之前稍微繁杂了一些，但是一次性展示出来的内容更多了些，各有优劣吧感觉。</p>\n<h4 id=\"Scheme\"><a href=\"#Scheme\" class=\"headerlink\" title=\"Scheme\"></a>Scheme</h4><p>新建的 scheme 默认是 Shared 的状态，如果想建立私有的 scheme ，则在 Manage Schemes 中去掉勾选。</p>\n<p>Scheme 的选择和运行设备的选择都可以通过键盘快捷键来操作，这是要解放鼠标？</p>\n<p>快捷键分别是 ⌃+0 和 ⌃+⇧+0 ，当弹出 popup 后，可以键入字符或使用方向键来高亮 scheme 或设备，并回车选择。</p>\n<h3 id=\"Source-Editor\"><a href=\"#Source-Editor\" class=\"headerlink\" title=\"Source Editor\"></a>Source Editor</h3><h4 id=\"mutil-cursor-editing-多行同时输入\"><a href=\"#mutil-cursor-editing-多行同时输入\" class=\"headerlink\" title=\"mutil-cursor editing (多行同时输入)\"></a>mutil-cursor editing (多行同时输入)</h4><p>像 Sublime Text 一样，支持多行同时输入了。以前一个 Alert 的提示语要复制粘贴粘贴粘贴粘贴的时代终于离我们而去。</p>\n<p>包括鼠标点击方式 ⌃+⇧+Click ，或通过选择列 ⌥+Click+Drag ，或通过键盘的 ⌃+⇧+Up 选择上一列，或 ⌃+⇧+Down 选择下一列。</p>\n<h4 id=\"可以折叠代码了，嘿嘿\"><a href=\"#可以折叠代码了，嘿嘿\" class=\"headerlink\" title=\"可以折叠代码了，嘿嘿\"></a>可以折叠代码了，嘿嘿</h4><p>Xcode 9中，在 <code>if</code> , <code>func</code> 等关键字处 ⌘+Click 可以看到代码块所占的所有行，而在 Xcode 10 beta 中，还可以激活 code folding 的 popup ，在弹出的 popup 选择 Fold 就可以折叠代码了。</p>\n<p>不想每次都 ⌘+Click ，可以在 Xcode &gt; Preferences &gt; Text Editing &gt; Show， 勾选 Code folding ribbon 。就可以看到在 Editor 的内部左侧，显示的行数的右侧有标志条，点击就可以直接折叠代码了。</p>\n<p>还可以通过 Editor &gt; Code Folding 选择折叠当前打开文件<strong>所有</strong>的代码结构，甚至是注释。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zd5zl.png\" alt=\"\"></p>\n<p>Xcode 10 beta 中的处于版本管理状态的工程，可以看到开发者所作出的修改和在版本控制服务器上未被 pull 下来的提交。这个的标志条是在代码行数的左侧。</p>\n<h4 id=\"查找和选择\"><a href=\"#查找和选择\" class=\"headerlink\" title=\"查找和选择\"></a>查找和选择</h4><p>以前有一种情况是：我们想改变文件内的静态函数名、函数内的变量名、静态变量名的时候，修改之后需要整个文件审视一遍，或让 Xcode 通过编译错误提醒我们。现在，在 Xcode 10 beta 中，可以通过 Editor &gt; Structure &gt; Select all Symbols 选择光标所在的函数或变量的 symbols ，就可以做到改一处而改动所有。</p>\n<p>当我们要选择当前文件下查找到的所有结果，可以先执行一次查找 ⌘+F ，然后 Find &gt; Select All Find Matches 进行全选，就可以修改所有结果。</p>\n<p>但是，当我们不想选择当前文件下的所有查找到的结果，而是选择某一段代码中的包含的将被查找到的结果，可以先进行查找，然后选择要查找的那段代码， Find &gt; Select Find Matches in Selection ，就可以选择到某段代码中的所有查找到的结果。</p>\n<h4 id=\"overscroll\"><a href=\"#overscroll\" class=\"headerlink\" title=\"overscroll\"></a>overscroll</h4><p>打开 Xcode 10 beta 版的 Source Editor 时，滑动到最下面时，出现了一大片空白，如下图白色框框所示：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/897w4.png\" alt=\"\"></p>\n<p>这不是 Xcode 的 Bug ，而是 10 beta 版的新功能 overscroll 。以前版本的 Xcode ，在文件末尾添加函数的时候，视线只能一直盯着最下面几行，或者提前先使用几个空行做占位，让视线更趋近于 Source Editor 的中间。现在有了 overscroll 之后，滚动到文件末尾，Xcode 会预留更多空间，使 Source Editor 可以向下再滚动一段距离（估计只是修改了 Source Editor 的 ScrollerView 的 inset 。:] ）</p>\n<p>可滚动的距离也可以设置，在 Preference &gt; Text Editing &gt; Editor Overscroll 选择距离级别，分别有 None, Small, Medium, Large ，见名知意，就不多阐述了。</p>\n<h4 id=\"Quick-Help\"><a href=\"#Quick-Help\" class=\"headerlink\" title=\"Quick Help\"></a>Quick Help</h4><p>右侧 Quick Help 的 layout 也修改了，可读性更强。普天同庆啊~</p>\n<p>Quick Help 和 Documentation Viewer 的代码样式跟用户当前使用的主题是一样的，整体看起来更和谐一些。</p>\n<h3 id=\"New-Build-System\"><a href=\"#New-Build-System\" class=\"headerlink\" title=\"New Build System\"></a>New Build System</h3><p>Xcode 10 使用了新的 Build System ，当然也可以选择使用老的 Build System ，通过 File &gt; Project/Workspace Settings 中选择：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/aykpw.png\" alt=\"\"></p>\n<p>这样的话，在构建时， Toolbar 的 View Activity 的 Activity Indicators 区域会出现一个橘黄色的小锤子：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/u2dp7.png\" alt=\"\"></p>\n<p>新的 Build System 保证了构建时的可靠性和性能，能捕获到项目的配置问题。在我们没有能很好地使用新的 Build System 之前，使用新的工具总会遇到问题，常见的一些编译问题的解释和解决方法在 <a href=\"https://help.apple.com/xcode/mac/current/#/dev621201fb0\">Xcode Help</a> 。</p>\n<h3 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h3><h4 id=\"乱序\"><a href=\"#乱序\" class=\"headerlink\" title=\"乱序\"></a>乱序</h4><p>首先，支持乱序。Test Bundle 中的方法可以不按顺序进行测试，默认是关闭的，可以通过 Edit Scheme &gt; Test &gt; Info &gt; Tests 选择任意 Test Bundle ，打开 Options 勾选 Randomize execution order 来开启。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/tn1xw.png\" alt=\"\"></p>\n<h4 id=\"并行测试\"><a href=\"#并行测试\" class=\"headerlink\" title=\"并行测试\"></a>并行测试</h4><p>上图还透露了一个信息，在 Randomize execution order 上面，还有个选项 Execute in parallel on Simulator ，那就是可以并行测试了（并发已经满足不了广大开发者的需求了）。只限于 macOS 的 unit tests ，iOS 模拟器和 tvOS 模拟器的 unit 和 UI tests 。因为，要达到真正的并行，真机肯定是不支持的。并行测试时，Xcode 会开启多个线程运行多个我们选定的模拟器，然后在上面进行测试，在 Report navigator 也会记录线程启动和测试的日志，你会看到很多诸如 Clone X of iPhone X 的信息。</p>\n<p>命令行 <code>xcodebuild</code> 也支持并行测试，只需要加上参数 <code>-parallel-testing-enabled YES|NO</code> 去重写 seheme 的 pre-target 就可以了。还可以通过 <code>-parallel-testing-worker-count</code> 和 <code>-maximum-parallel-testing-workers</code> 控制测试模拟器的数量。</p>\n<p>具体请打开 iTerm 或 Terminals 敲 <code>xcodebuild -help</code> 。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f5vxe.png\" alt=\"\"></p>\n<h4 id=\"可变的测试集\"><a href=\"#可变的测试集\" class=\"headerlink\" title=\"可变的测试集\"></a>可变的测试集</h4><p>新建的测试默认状态是 enabled 的，这样我们在 Test navigator 中可以通过点击测试类或测试方法右边的运行按钮进行测试。</p>\n<p>然而，如果想固定当前的测试集，排除新建的测试类或方法时，可以取消勾选 Automatically include new tests ，见上图。此时测试方法的状态是 disabled ，将无法在 Test navigator 中进行测试，但可以在类中该方法的左侧点击运行按钮进行测试。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4jdy0.png\" alt=\"\"></p>\n<p>假设过了一段时间，想把 disabled 状态的测试类或方法变成 enabled ，在 Edit Scheme 中可以修改其状态。这样我们可以控制每次测试所运行的测试集，不必浪费时间去做一些不需要做的测试。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p99x5.png\" alt=\"\"></p>\n<h3 id=\"IB\"><a href=\"#IB\" class=\"headerlink\" title=\"IB\"></a>IB</h3><ul>\n<li>画布的渲染也并行了，scenes 的放大缩小和组件的修改，据说性能都得到提升。</li>\n</ul>\n<ul>\n<li><p>原来 storyboard 右下角的 “Embed in Stack View” 按钮也改成了 popup ，提供更多选项供开发者选择 embed ，如下图白色框框。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kij8a.png\" alt=\"\"> </p>\n<p>其中的 View Without Inset 会将选择的所有 View 紧凑地放在一个 Super View 里面。</p>\n</li>\n</ul>\n<ul>\n<li>打开 Xcode 5 的 .nib 或 .xib 文件，会提示格式问题并自动更新到当前版本所使用的格式。</li>\n<li>Attributes Inspector 的字体支持 iOS 11 发布的 Large Title ，且自定义字体可以看到样式预览，这个还挺不错的。</li>\n<li>同样是 Attributes Inspector 中，named color 和 图片右侧有个小按钮可以连接到 Assets ，在这个小按钮上 ⌥+Click 可以在 Assistant Editor 中打开。</li>\n</ul>\n<h3 id=\"Asset-Catalog\"><a href=\"#Asset-Catalog\" class=\"headerlink\" title=\"Asset Catalog\"></a>Asset Catalog</h3><p>macOS 10.14 有了 Dark Mode 之后，Assets 除了之前普通模式下单一的图片和 named color ，也支持 Light 和 Dark 。并且有个 High Contrast 的选项可以勾选，所以 macOS 开发如果要加入 Dark Mode ，要上传的图片和 named color 从原来的三张、一个颜色变成十三张图片、六个颜色，我的🐴🦆。</p>\n<p>不过感谢 Dark Mode 福泽，asset 的背景也可以切换成 Light , Dark , System Appearance(跟随系统) 。切换的按钮在 assets 的左下角。对了，View Debugger 也有这个切换背景的功能，也就是那个调试 UI 的界面。</p>\n<p>支持 Carplay assets，国内还没普及，暂时应该没多大用处。</p>\n<p>支持 ARKit 3D <code>ARReferenceObject</code> assets 。</p>\n<h3 id=\"Debugging\"><a href=\"#Debugging\" class=\"headerlink\" title=\"Debugging\"></a>Debugging</h3><p>Debugging 功能的完善主要是针对 macOS 开发：</p>\n<ul>\n<li><p>Disk Gauge Report 加入了已关闭文件的大小的显示和对硬盘的读写随时间推进的变化表。</p>\n</li>\n<li><p>Named color 在 View Debugger 的  Inspector 显示颜色的名称和是否属于系统颜色，仅 macOS 开发才有。</p>\n</li>\n<li><p>当 macOS App 在运行过程中，可以通过 Debug &gt; View Debugging &gt; Appearance menu 或者调试工具 Memory Graph 右边新加的按钮或 Touch Bar 来切换 Light 或 Dark 模式</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9nth5.png\" alt=\"\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a5le3.png\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li>Metal Frame Debugger ，笔者尚未深入了解，暂时不介绍了。</li>\n</ul>\n<h3 id=\"Playground\"><a href=\"#Playground\" class=\"headerlink\" title=\"Playground\"></a>Playground</h3><p>Playground 引入了一个增量执行? ( execute code incrementally ) 的 workflow 。</p>\n<ol>\n<li><p>在 Xcode 10 中，新建 Playground 默认是 Manually Run 。</p>\n</li>\n<li><p>当写完代码后，按 ⇧+Return 或点击代码左侧的执行按钮，Playground 会进入运行模式，执行到指定位置( ⇧+Return 或点击的执行按钮所在的上一行)，然后进入等待模式，没有结束执行。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/t5tiz.png\" alt=\"\"></p>\n</li>\n<li><p>我们可以不断地执行第2步，Playground 只会编译上一次暂停执行的位置到我们 ⇧+Return 或点击执行按钮的位置。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/opr4z.png\" alt=\"\"></p>\n</li>\n<li><p>点击 Stop Playground 结束操作 Playground 。</p>\n</li>\n</ol>\n<h3 id=\"Localization\"><a href=\"#Localization\" class=\"headerlink\" title=\"Localization\"></a>Localization</h3><p>Xcode 10 beta 版支持新的国际化 workflow ，使用新的国际化文件 .xcloc 取代以前的 .xliff 。喔，不，应该是包含 .xliff 。还支持其他可能需要国际化的文件，如图片。</p>\n<p>有兴趣的同学可以看看 <a href=\"https://developer.apple.com/videos/play/wwdc2018/404/\">New Localization Workflows in Xcode 10</a> 。</p>\n<h3 id=\"Signing-And-Distribution\"><a href=\"#Signing-And-Distribution\" class=\"headerlink\" title=\"Signing And Distribution\"></a>Signing And Distribution</h3><p>今年的 Xcode 10 完善了 macOS App 的发布和认证， Organizer Distribution 的 Developer ID 选项提供了上传到 Apple 进行认证的功能。Archive 后， Distribute App &gt; Developer ID ，可以选择 Upload 上传到 Apple 进行认证或 Export 到本地保存。要上传应用，需要在 Xcode 中添加苹果账号，并填写所需的App Store Connect role与提供者资格，此外，认证应用还需要有开发者ID证书签名。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97fpw.png\" alt=\"\"></p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/a05lh.png\" alt=\"\"></p>\n<p>在上传的应用被认证后，你可以在 Organizer 中选择你的档案并点击 Show Status Log 按钮，这样就能查看应用的状态。当收到认证通过的通知后，就可以从 Organizer 中将 App Export 出来，保存下来的 App 包含一个附加的票据，就意味着可以发布了。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>今年的 WWDC 没有专题讲述 Xcode 10 。很多都是穿插在各个 Session 中。理解并用好一个工具能提高我们开发的效率，每年 Xcode 都有很多新的功能和改进，虽然出 Bug 和闪退的问题依旧存在，依旧是开发者们诟病的一点，但是，苹果爸爸在改善开发者的工作环境和提高 Xcode 的友好度作出的努力，大家还是有目共睹的，至少黑夜模式照顾到了我们这群深夜加班<del>努力写 Bug</del> ，呸，努力写改变世界的代码的工程狮。</p>\n<p>本文是我一份小小的学习笔记，请各位批判性地看，肯定有写的不好或错误的地方，请斧正，我定虚心接受。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjonym6da0000qu0xcu82gwq3","tag_id":"cjonym6dh0003qu0xeeu971kw","_id":"cjonym6dp0008qu0xtnwej50c"},{"post_id":"cjonym6df0002qu0xq0h0ie39","tag_id":"cjonym6do0007qu0xywx4sp8d","_id":"cjonym6du000dqu0xjck0t54l"},{"post_id":"cjonym6dj0004qu0xyml8ep67","tag_id":"cjonym6dt000bqu0xdibctl65","_id":"cjonym6dw000hqu0x3xbd67ho"},{"post_id":"cjonym6dn0005qu0xdxm9vi19","tag_id":"cjonym6dv000fqu0xgphe3wls","_id":"cjonym6dz000lqu0xagz0mq7s"},{"post_id":"cjonym6dn0006qu0x8akg57t0","tag_id":"cjonym6dy000jqu0xutgy5jbx","_id":"cjonym6e1000pqu0xgmwu3l1n"},{"post_id":"cjonym6e1000qqu0xrccbct21","tag_id":"cjonym6dy000jqu0xutgy5jbx","_id":"cjonym6e5000tqu0xs34moo52"},{"post_id":"cjonym6dp0009qu0xpwbb2028","tag_id":"cjonym6e1000oqu0xcgkr00ww","_id":"cjonym6e6000vqu0xy8wd6xav"},{"post_id":"cjonym6ds000aqu0x2w7fu763","tag_id":"cjonym6dv000fqu0xgphe3wls","_id":"cjonym6e6000xqu0x8g3cmmyo"},{"post_id":"cjonym6du000cqu0xi3zdt141","tag_id":"cjonym6e6000wqu0xmcvr3g2g","_id":"cjonym6e6000zqu0xwu2yjxm0"},{"post_id":"cjonym6du000equ0xu1xtt318","tag_id":"cjonym6e6000yqu0x8lup7psa","_id":"cjonym6e70011qu0x59fw4kh9"},{"post_id":"cjonym6dw000gqu0xsjtk4nuw","tag_id":"cjonym6e1000oqu0xcgkr00ww","_id":"cjonym6e70013qu0xycxw6gz0"},{"post_id":"cjonym6dx000iqu0x56e77fqw","tag_id":"cjonym6dy000jqu0xutgy5jbx","_id":"cjonym6e80015qu0xrtmxe4zg"},{"post_id":"cjonym6dy000kqu0x82swjzfm","tag_id":"cjonym6e70014qu0xh2x14abz","_id":"cjonym6e80017qu0xmaveeh4y"},{"post_id":"cjonym6dz000mqu0xps5f8sgk","tag_id":"cjonym6e80016qu0xhzj4l7m0","_id":"cjonym6e90019qu0xqo793y4q"},{"post_id":"cjonym6e0000nqu0xsuufiown","tag_id":"cjonym6e80016qu0xhzj4l7m0","_id":"cjonym6e9001bqu0xu7fgonau"},{"post_id":"cjonym6e3000rqu0x5s95lyjq","tag_id":"cjonym6e9001aqu0xp8ug48hq","_id":"cjonym6e9001dqu0xghor0zcr"},{"post_id":"cjonym6e5000uqu0xsj9bc86d","tag_id":"cjonym6e9001cqu0xi55csj8k","_id":"cjonym6ea001equ0xkvqdlim3"}],"Tag":[{"name":"Animation","_id":"cjonym6dh0003qu0xeeu971kw"},{"name":"Swift","_id":"cjonym6do0007qu0xywx4sp8d"},{"name":"CI","_id":"cjonym6dt000bqu0xdibctl65"},{"name":"UIView","_id":"cjonym6dv000fqu0xgphe3wls"},{"name":"Mood","_id":"cjonym6dy000jqu0xutgy5jbx"},{"name":"Thread","_id":"cjonym6e1000oqu0xcgkr00ww"},{"name":"Distribution","_id":"cjonym6e6000wqu0xmcvr3g2g"},{"name":"Library","_id":"cjonym6e6000yqu0x8lup7psa"},{"name":"Block","_id":"cjonym6e70014qu0xh2x14abz"},{"name":"Security","_id":"cjonym6e80016qu0xhzj4l7m0"},{"name":"Summary","_id":"cjonym6e9001aqu0xp8ug48hq"},{"name":"WWDC2018","_id":"cjonym6e9001cqu0xi55csj8k"}]}}