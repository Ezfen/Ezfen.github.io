{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/about/index.html","path":"about/index.html","modified":0,"renderable":0},{"_id":"source/demo/index.html","path":"demo/index.html","modified":0,"renderable":0},{"_id":"source/demo/css/component.css","path":"demo/css/component.css","modified":0,"renderable":0},{"_id":"source/demo/css/demo.css","path":"demo/css/demo.css","modified":0,"renderable":0},{"_id":"source/demo/css/init.css","path":"demo/css/init.css","modified":0,"renderable":0},{"_id":"source/demo/css/normalize.css","path":"demo/css/normalize.css","modified":0,"renderable":0},{"_id":"source/demo/img/10.jpg","path":"demo/img/10.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/11.jpg","path":"demo/img/11.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/13.jpg","path":"demo/img/13.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/12.jpg","path":"demo/img/12.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/14.jpg","path":"demo/img/14.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/2.jpg","path":"demo/img/2.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/3.jpg","path":"demo/img/3.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/4.jpg","path":"demo/img/4.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/5.jpg","path":"demo/img/5.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/6.jpg","path":"demo/img/6.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/7.jpg","path":"demo/img/7.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/8.jpg","path":"demo/img/8.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/9.jpg","path":"demo/img/9.jpg","modified":0,"renderable":0},{"_id":"source/demo/img/Thumbs.db","path":"demo/img/Thumbs.db","modified":0,"renderable":0},{"_id":"source/demo/img/dummy.png","path":"demo/img/dummy.png","modified":0,"renderable":0},{"_id":"source/demo/js/classie.js","path":"demo/js/classie.js","modified":0,"renderable":0},{"_id":"source/demo/js/colorfinder-1.1.js","path":"demo/js/colorfinder-1.1.js","modified":0,"renderable":0},{"_id":"source/demo/img/loading.gif","path":"demo/img/loading.gif","modified":0,"renderable":0},{"_id":"source/demo/js/gridScrollFx.js","path":"demo/js/gridScrollFx.js","modified":0,"renderable":0},{"_id":"source/demo/js/imagesloaded.pkgd.min.js","path":"demo/js/imagesloaded.pkgd.min.js","modified":0,"renderable":0},{"_id":"source/demo/js/masonry.pkgd.min.js","path":"demo/js/masonry.pkgd.min.js","modified":0,"renderable":0},{"_id":"source/demo/js/modernizr.custom.js","path":"demo/js/modernizr.custom.js","modified":0,"renderable":0},{"_id":"themes/hollow/source/css/backtop.styl","path":"css/backtop.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/category.styl","path":"css/category.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/component.css","path":"css/component.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/content.css","path":"css/content.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/navigation.styl","path":"css/navigation.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/playball.css","path":"css/playball.css","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/default.cur","path":"images/default.cur","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/pointer.cur","path":"images/pointer.cur","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/classie.js","path":"js/classie.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/backtop.js","path":"js/backtop.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/uiMorphingButton_fixed.js","path":"js/uiMorphingButton_fixed.js","modified":0,"renderable":1},{"_id":"themes/hollow/source/js/modernizr.custom.js","path":"js/modernizr.custom.js","modified":0,"renderable":1},{"_id":"source/demo/img/1.jpg","path":"demo/img/1.jpg","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.eot","path":"demo/fonts/codropsicons/codropsicons.eot","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.svg","path":"demo/fonts/codropsicons/codropsicons.svg","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.ttf","path":"demo/fonts/codropsicons/codropsicons.ttf","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/codropsicons.woff","path":"demo/fonts/codropsicons/codropsicons.woff","modified":0,"renderable":0},{"_id":"source/demo/fonts/codropsicons/license.txt","path":"demo/fonts/codropsicons/license.txt","modified":0,"renderable":0},{"_id":"themes/hollow/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/background_1.jpg","path":"images/background_1.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1},{"_id":"themes/hollow/source/images/background_bak.png","path":"images/background_bak.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"486d7f3b56f8ae7beedc054731275ee0f4017e81","modified":1516690817561},{"_id":"source/.DS_Store","hash":"d7bd26bc1a52480485d139771c6985b6212baf77","modified":1522814220199},{"_id":"source/apple-touch-icon.png","hash":"80f6acded913cc59552a76af528873603f15558e","modified":1508167532000},{"_id":"source/README.md","hash":"8a6e95294f12e968c8fbecf220b8949b940a428b","modified":1521077883141},{"_id":"themes/hollow/LICENSE","hash":"0aa093714c449e496e41093e55e939d19dd791d6","modified":1508167532000},{"_id":"source/favicon.png","hash":"f19e255a25a7a47586074dee505d63c4db443438","modified":1508167532000},{"_id":"themes/hollow/.DS_Store","hash":"2abb4d41925a95c98c051344f2da8ac023dce75d","modified":1507558772000},{"_id":"themes/hollow/_config.yml","hash":"6a3c1e7d66c12f0b60ea567899e248331caf5ccb","modified":1508167532000},{"_id":"themes/hollow/README.md","hash":"9fb701d6366348c1d676a4f06e15cc6e4713b6fb","modified":1508167532000},{"_id":"source/about/index.html","hash":"7352f5d48164b8fad4133e47173e5f765da7531f","modified":1508771529000},{"_id":"source/about/.DS_Store","hash":"0026a41cc0ca8ce050d7446082c78516c5633432","modified":1487513878000},{"_id":"source/_posts/iOS-Event传递和响应链.md","hash":"bcde1e8e33cbabc7d1ecc1fa762525216a5c14bf","modified":1520414340763},{"_id":"source/_posts/autoresizingMask.md","hash":"30f4c67c40d7714bb7c32432bec0127d3ec0edfc","modified":1520410187228},{"_id":"source/_posts/EZHeartForLike.md","hash":"83bb6e0db730b6ffc716aeae79098515cd44da97","modified":1520410444050},{"_id":"source/_posts/hello-world.md","hash":"b922a6d5ee251eb0b561b1045c3eb950f991a975","modified":1522287893522},{"_id":"source/_posts/iOS下重要的多线程GCD.md","hash":"7fdcc87d1aef4ad4750032e4c139c4e9172e3533","modified":1521018707465},{"_id":"source/_posts/使用MakeFile创建静态库.md","hash":"5e3d75dc9953625306f65fb32ec897b8f260d675","modified":1520399115588},{"_id":"source/_posts/对线程的简单理解.md","hash":"ebfcc375fda62c82c98da06b53303551e8670cf8","modified":1522372593800},{"_id":"source/_posts/我有烦恼，你有答案.md","hash":"cc2bdfec50223976c7ca9e0459da70cabdab5309","modified":1520409977251},{"_id":"source/_posts/阿澤君的独白.md","hash":"55661df7808c918837ad9bd6e3d2b7ca1712c5dc","modified":1520409140607},{"_id":"source/_posts/类方法Block内存泄漏.md","hash":"80053b4d2c36b08747e1c0d2edc342e2daf34f63","modified":1520409925209},{"_id":"source/_posts/项目Beauty总结.md","hash":"356473766c4aa711f6d1894ab536caa3948579e5","modified":1521077547566},{"_id":"source/_posts/.DS_Store","hash":"993e36049897308cae34696176d7ccee84269d16","modified":1522294874734},{"_id":"source/demo/.DS_Store","hash":"49ecd8db5fa7aa0d33e9fa1902311d566c758061","modified":1487929005000},{"_id":"source/demo/index.html","hash":"3fc289d5180fc995f129436406047a150ad42d82","modified":1508167532000},{"_id":"source/tags/index.md","hash":"e4fcaa4a711ee1ed153ebf8cfdfb7eadc65365e4","modified":1508167532000},{"_id":"themes/hollow/languages/default.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1508167532000},{"_id":"themes/hollow/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1508167532000},{"_id":"themes/hollow/languages/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1508167532000},{"_id":"themes/hollow/languages/zh-Hans.yml","hash":"053c45b0db64929e9fa2b1dbf271588d1118b911","modified":1508167532000},{"_id":"themes/hollow/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1508167532000},{"_id":"themes/hollow/layout/.DS_Store","hash":"09637d84eac56c0bbeb9416686b898ea4bcdde92","modified":1487315304000},{"_id":"themes/hollow/layout/index.ejs","hash":"5afc72ef49187e8d29aa656547552bddb0d926d1","modified":1522831015940},{"_id":"themes/hollow/layout/archive.ejs","hash":"7ad2499729da4ae5bdf1af5c5a2df926a93a553a","modified":1508167532000},{"_id":"themes/hollow/layout/layout.ejs","hash":"e4a187f9fde9e00c9bdd0246792ed54a65e76384","modified":1522829769177},{"_id":"themes/hollow/layout/page.ejs","hash":"d74a7a45bdc65ce5b049bc622170032bf9940b56","modified":1508167532000},{"_id":"themes/hollow/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1508167532000},{"_id":"themes/hollow/source/.DS_Store","hash":"2da78585b61381e662a783b363f0bbf080f83a95","modified":1503217620000},{"_id":"source/_posts/简简单单说说PKIOniOS.md","hash":"36912515fcd38560fbbe5bc6cf9b2cb3932b98a4","modified":1520409844756},{"_id":"source/demo/css/component.css","hash":"3ee5f2a934986a74ab6fe1c24f2ffee8d9f0b40c","modified":1508167532000},{"_id":"source/demo/css/demo.css","hash":"5e610860218722103852254901ed4f561695bd38","modified":1508167532000},{"_id":"source/demo/css/init.css","hash":"19249942460483b83425fd9072329b6b4decc9d6","modified":1508167532000},{"_id":"source/demo/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1508167532000},{"_id":"source/demo/fonts/.DS_Store","hash":"f259329c67189902e9767884b6811df0ea138eb3","modified":1487298426000},{"_id":"source/demo/img/10.jpg","hash":"cf054dcda4fe76940264a2f7b45ace9a8f8788f2","modified":1508167532000},{"_id":"source/demo/img/11.jpg","hash":"9edc600344b745f9340fa041003254b6f60187ce","modified":1508167532000},{"_id":"source/demo/img/13.jpg","hash":"a5f476016a19effc9c588ba8938bf4c49414a089","modified":1508167532000},{"_id":"source/demo/img/12.jpg","hash":"e9857d9321c7b35847c24efd55e81a7657e3fc2d","modified":1508167532000},{"_id":"source/demo/img/14.jpg","hash":"99df3ffe7f7ce609402c27800ed758cddd8cd818","modified":1508167532000},{"_id":"source/demo/img/2.jpg","hash":"85d205dd455451e1235c33e27a1060ba5cf1b2c3","modified":1508167532000},{"_id":"source/demo/img/3.jpg","hash":"44945eec703223535155953fcf9c24c84e5b5056","modified":1508167532000},{"_id":"source/demo/img/4.jpg","hash":"769dbadadab1bd82b24b1a2cc4520a6713178120","modified":1508167532000},{"_id":"source/demo/img/5.jpg","hash":"4fff7c86ad034e7c5f7697b4f7b12f7525068c8f","modified":1508167532000},{"_id":"source/demo/img/6.jpg","hash":"688d59d3ddc43d117da60c2d86d4979d10b3e8f0","modified":1508167532000},{"_id":"source/demo/img/7.jpg","hash":"8069d3fc4a4737e3155799dcce2fedd4066d2bbb","modified":1508167532000},{"_id":"source/demo/img/8.jpg","hash":"5c1cc79f3c0dbab37493cb913f8f3a3b0ea38470","modified":1508167532000},{"_id":"source/demo/img/9.jpg","hash":"7c34266bb957f6b00a5d0bb5f5cedabd3a31fcf5","modified":1508167532000},{"_id":"source/demo/img/Thumbs.db","hash":"1f4318671088fdc6d057fa748a88f65519e721a8","modified":1508167532000},{"_id":"source/demo/img/dummy.png","hash":"b7bed4edd54d4b0d8dde97d03a102530fc9f9d54","modified":1508167532000},{"_id":"source/demo/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1508167532000},{"_id":"source/demo/js/colorfinder-1.1.js","hash":"fe47069f811272fcd33a7488642e30fd3f25d725","modified":1508167532000},{"_id":"source/demo/img/loading.gif","hash":"deedbc14742a4163d1fcce18211cfc76ba06505f","modified":1508167532000},{"_id":"source/demo/js/gridScrollFx.js","hash":"eaf98cdf8b39384e04ae61b901e08ed32aa485db","modified":1508167532000},{"_id":"source/demo/js/imagesloaded.pkgd.min.js","hash":"dea4f6ecff8935bba3323104fee273a173f1262e","modified":1508167532000},{"_id":"source/demo/js/masonry.pkgd.min.js","hash":"d87128d50e1c17e03ac7a2297dd0337158775301","modified":1508167532000},{"_id":"source/demo/js/modernizr.custom.js","hash":"897d01634e1728d281fa5c6e27f37d1d7652290c","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/about.ejs","hash":"7f96c9e91e80c1628f9aa7f91eb5429103001a6e","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/.DS_Store","hash":"4bf4464ddc7b8b0e28b6d858fbb2a1b810bc96ac","modified":1486563700000},{"_id":"themes/hollow/layout/_partial/all-tags-left.ejs","hash":"3247188df4892c281479662846b2e5e7ebac9189","modified":1521077721573},{"_id":"themes/hollow/layout/_partial/article-archive.ejs","hash":"d52b04f27427b0a4ff97522175bef8ec8e0a9130","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/all-tags.ejs","hash":"97a73c5e7274d234ee1314fc952d54c614a07c36","modified":1518399583266},{"_id":"themes/hollow/layout/_partial/article-categories.ejs","hash":"5a0bf5a20f670621d8013c9b9d7976b45c8aa80f","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/article-tags.ejs","hash":"156eb953ad23071f789c3f0566748a6209dc586d","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/article-index.ejs","hash":"d9ca79142cae43cabe7f4f3a83a2e66dba79fe7e","modified":1518229640302},{"_id":"themes/hollow/layout/_partial/article-full.ejs","hash":"bb84737a7c0169c0550354df69079b35f94383d5","modified":1519378310183},{"_id":"themes/hollow/layout/_partial/backhome.ejs","hash":"aa44bb3d5c3e902f9cb3aaab8b5cba24acacfe78","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/backtop.ejs","hash":"15e23a92e9ee7260384c55d9d4d10c36d7dbdb9f","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/comment.ejs","hash":"cf942107e02af29c19bda11358942e7fd97a84fd","modified":1520397580952},{"_id":"themes/hollow/layout/_partial/demo.ejs","hash":"c6c7e88348b8c14136b2a3925234a4aa51b8bbaa","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/pagination.ejs","hash":"9f086bd506077b121563ff66123cdae4ccfbed50","modified":1508167532000},{"_id":"themes/hollow/layout/_partial/scripts.ejs","hash":"7625d58d3ee2a9cde6caadfc0062e9865ead27d8","modified":1522830215596},{"_id":"themes/hollow/layout/_partial/head.ejs","hash":"889389a16e2ab9200b1251c28d4f370f5150157a","modified":1522824005085},{"_id":"themes/hollow/layout/_partial/searchfunc.ejs","hash":"f404a510979eea6db897bf470ef21d6ac917680a","modified":1522830998312},{"_id":"themes/hollow/layout/_partial/search.ejs","hash":"f161e4c8f001a21d76b219edda9447385a2119ba","modified":1522829316956},{"_id":"themes/hollow/source/css/backtop.styl","hash":"ce075cb7d12f71ca45c744c38f6398bc9ef04e1c","modified":1520319144807},{"_id":"themes/hollow/source/css/article.styl","hash":"cf8bfe76b59afb42522cdbae6f7d8fd5d40c858d","modified":1519907341467},{"_id":"themes/hollow/source/css/base.styl","hash":"9b6eb88234a5cef6edc5bc69a2af181fb9192bf9","modified":1522826196742},{"_id":"themes/hollow/source/css/category.styl","hash":"14b5e8826307c026ae2bfd5472ac87db3cd94d55","modified":1520242936726},{"_id":"themes/hollow/source/css/component.css","hash":"d1b9fedb2d82433c3af4205bd8392f6af671193c","modified":1522829242862},{"_id":"themes/hollow/source/css/content.css","hash":"54857361624e89c91efadfe5605d1c40a5a799e9","modified":1522829225464},{"_id":"themes/hollow/source/css/main.styl","hash":"3c947cc0705c2cebb00edf9934ced14a6a54d565","modified":1520242727167},{"_id":"themes/hollow/source/css/navigation.styl","hash":"3291c4be48550d0972652efd6dab8f7bc7fe9af6","modified":1522826248622},{"_id":"themes/hollow/source/css/mixins.styl","hash":"0b743c9bd7ecf2414687b2e06582d651298a24e8","modified":1521076116533},{"_id":"themes/hollow/source/css/playball.css","hash":"49045d0cceae613d902d2e1b3fac268e8e555ae8","modified":1508167532000},{"_id":"themes/hollow/source/css/search.styl","hash":"650681bd1750094c80e074453a43468648201de0","modified":1520298539383},{"_id":"themes/hollow/source/css/style.styl","hash":"15ba84b537171dc16622dbbcb9870b8dfa045885","modified":1508167532000},{"_id":"themes/hollow/source/css/variables.styl","hash":"c7a5d7efcf67c7790915353230c157aa14d25afd","modified":1520242772622},{"_id":"themes/hollow/source/images/.DS_Store","hash":"4866bf27e45c38043503c610af24b78f3c330c51","modified":1508080808000},{"_id":"themes/hollow/source/images/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1520241091047},{"_id":"themes/hollow/source/images/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1520242292639},{"_id":"themes/hollow/source/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1399708648000},{"_id":"themes/hollow/source/js/backtop.js","hash":"9f1c5967e3585d3ee323bf97f412af290ee4404f","modified":1518424165773},{"_id":"themes/hollow/source/js/main.js","hash":"4e14f8cbfe3645876991a3541ba46f85a39b7252","modified":1508167532000},{"_id":"themes/hollow/source/js/search.js","hash":"fe5812cd91d87eb083d5c02bba1c4570c3e5f84d","modified":1522830977483},{"_id":"themes/hollow/source/js/uiMorphingButton_fixed.js","hash":"7e45f9a7588328559ccc4446d19922227f2d378f","modified":1522828968594},{"_id":"themes/hollow/source/js/modernizr.custom.js","hash":"c36a15206943880cbb6a88016ab9f4b99a30570a","modified":1399485028000},{"_id":"source/demo/img/1.jpg","hash":"2d1d841ae831bc8d88adbd95df9c1f3c331fb518","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.eot","hash":"d3bd1eb3823f094524ddf6070c154ccab81e6951","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.svg","hash":"0de9f0aaf1cdf27ef9931d45c5eab3374c7142f4","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.ttf","hash":"e670d3deb662651d71461be5a41add4a48b8998a","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/codropsicons.woff","hash":"7c0ba611c947ddb5a82fa47a87a1ce63ed8bcd7f","modified":1508167532000},{"_id":"source/demo/fonts/codropsicons/license.txt","hash":"d3d34d2a512acf27557ea82ac82a51058df43091","modified":1508167532000},{"_id":"themes/hollow/source/images/avatar.jpg","hash":"159a800376aebf291e959414f8b19da833a10648","modified":1508167532000},{"_id":"themes/hollow/source/images/background_1.jpg","hash":"2dbf868225f7b454ca0c745c64a96ba948f00dc3","modified":1508167532000},{"_id":"themes/hollow/source/images/background.jpg","hash":"b28817e6107175d793fcab7f48120926db2a6217","modified":1508167532000},{"_id":"themes/hollow/source/images/background_bak.png","hash":"dcccd29a5e8b71153c3ed3f139c3de31f6fefd90","modified":1508167532000},{"_id":"public/search.xml","hash":"470552458b89b5912c70a1f2b6991a37642fd08c","modified":1522831028889},{"_id":"public/tags/index.html","hash":"ce5407e21292531b710d62a172384b854e3a1848","modified":1522831028999},{"_id":"public/2017/08/08/使用MakeFile创建静态库/index.html","hash":"995df30a47e640504fc6752331e8e44586d123fa","modified":1522831028999},{"_id":"public/2017/07/17/项目Beauty总结/index.html","hash":"1c0593890e52d1a3507712b422bb50f072b617f6","modified":1522831028999},{"_id":"public/2017/02/27/iOS-Event传递和响应链/index.html","hash":"17b29592265e51bd5829e1c4f4458838c7efd539","modified":1522831028999},{"_id":"public/2017/02/19/我有烦恼，你有答案/index.html","hash":"3fc05402aaa3852887e5e1b044ff42ef458cf678","modified":1522831028999},{"_id":"public/2017/02/17/hello-world/index.html","hash":"c498517aa5bd13a5614f385912b3ab1ce5b237e8","modified":1522831028999},{"_id":"public/2016/07/17/类方法Block内存泄漏/index.html","hash":"414d12c8eeff86562780460002126d2970e3624a","modified":1522831028999},{"_id":"public/2016/05/21/EZHeartForLike/index.html","hash":"d0634ca86e6a16662b5439ec498d5e57263bf450","modified":1522831028999},{"_id":"public/2016/04/02/阿澤君的独白/index.html","hash":"617d2d6fd97b352b92d8c283aab511f01813582a","modified":1522831029000},{"_id":"public/2016/03/19/autoresizingMask/index.html","hash":"a1ee71e6b4039e0a663903a9977528fa33378aa6","modified":1522831029000},{"_id":"public/archives/index.html","hash":"38508518677787ca8ae242ddf24da6e43de1558c","modified":1522831029000},{"_id":"public/archives/page/2/index.html","hash":"11d526c75eb43c1f50bbde0b8a0af959dc1b7d62","modified":1522831029000},{"_id":"public/archives/page/3/index.html","hash":"003ee00807d10ddb3f729fb7a5f92d017dbd165f","modified":1522831029000},{"_id":"public/archives/2016/index.html","hash":"abfb5a50619267c045d056f266bd42a3a44514c7","modified":1522831029000},{"_id":"public/archives/2016/03/index.html","hash":"13e2df45258c2b4cdc363a91aa3e56a53d24758e","modified":1522831029000},{"_id":"public/archives/2016/04/index.html","hash":"f5ed46257319545a3dff99b276e865bdedff5cd4","modified":1522831029000},{"_id":"public/archives/2016/05/index.html","hash":"cf30efa0a1b1eee2e5bdeffe4955e8fe238843db","modified":1522831029000},{"_id":"public/archives/2016/07/index.html","hash":"45b9dd6b8204d7992c1e8a69328a5f0fb9536030","modified":1522831029000},{"_id":"public/archives/2017/index.html","hash":"d7a2814ef82bd6503230439d7656503908492750","modified":1522831029000},{"_id":"public/archives/2017/page/2/index.html","hash":"b3dad3572bd6b3cccf9bce56f0263ffbf6fd3b1f","modified":1522831029001},{"_id":"public/archives/2017/02/index.html","hash":"6603c395371773166cca2e2e53aad197bb8437e5","modified":1522831029001},{"_id":"public/archives/2017/03/index.html","hash":"1631335cb9b4747ad186469acedef49640fbb7c9","modified":1522831029001},{"_id":"public/archives/2017/07/index.html","hash":"9f8fe48363ff3f8159c9385d0134ebdf00dbe164","modified":1522831029001},{"_id":"public/archives/2017/08/index.html","hash":"ff6e00463768888a6fef343aeb96ce42b885f067","modified":1522831029001},{"_id":"public/index.html","hash":"12e3b8c66fe84ebb4796408ce74e077b2a3aa357","modified":1522831029001},{"_id":"public/page/2/index.html","hash":"8e192df3b6caed6117eda834a119c49d5c1477c1","modified":1522831029001},{"_id":"public/page/3/index.html","hash":"06b5f02ee61d3ae5f3ffe194c7258d318afed403","modified":1522831029001},{"_id":"public/tags/UIView/index.html","hash":"cda1b6ab85d5cf5b89e519ed681d824ca965f0f1","modified":1522831029001},{"_id":"public/tags/Animation/index.html","hash":"e7c906935ee7a59f030ee6b9c35e323168a359e1","modified":1522831029001},{"_id":"public/tags/Mood/index.html","hash":"c1d7dbae1fac606aa09c1f9093c20d60bc6df119","modified":1522831029001},{"_id":"public/tags/Thread/index.html","hash":"933ed9818f2b73bc3685a15cdc8cd5ac71a4b077","modified":1522831029001},{"_id":"public/tags/Library/index.html","hash":"8cdd51dfd18d2999ad4c8cfd93353f00895aaeeb","modified":1522831029002},{"_id":"public/tags/Block/index.html","hash":"25f040fe769e82aa64433bb24a8d52d58c2c579f","modified":1522831029002},{"_id":"public/tags/Summary/index.html","hash":"50e9a99b0ac6671890034668368a8e64dd45111d","modified":1522831029002},{"_id":"public/tags/Security/index.html","hash":"81e3f82ee07288bfd815d70ff06d0e1d680a6d12","modified":1522831029002},{"_id":"public/2017/03/23/iOS下重要的多线程GCD/index.html","hash":"d25b8af84ab63a97a770f81115909cfb2054da4d","modified":1522831029002},{"_id":"public/2017/03/14/对线程的简单理解/index.html","hash":"715c43fdff066ba579ff1d264c9f6d972b20dba3","modified":1522831029002},{"_id":"public/2016/04/09/简简单单说说PKIOniOS/index.html","hash":"9712ce1f59c56a0012389b117056aa9834eca339","modified":1522831029002},{"_id":"public/CNAME","hash":"486d7f3b56f8ae7beedc054731275ee0f4017e81","modified":1522831029010},{"_id":"public/apple-touch-icon.png","hash":"80f6acded913cc59552a76af528873603f15558e","modified":1522831029010},{"_id":"public/README.md","hash":"8a6e95294f12e968c8fbecf220b8949b940a428b","modified":1522831029010},{"_id":"public/favicon.png","hash":"f19e255a25a7a47586074dee505d63c4db443438","modified":1522831029010},{"_id":"public/demo/index.html","hash":"3fc289d5180fc995f129436406047a150ad42d82","modified":1522831029010},{"_id":"public/about/index.html","hash":"7352f5d48164b8fad4133e47173e5f765da7531f","modified":1522831029010},{"_id":"public/demo/css/component.css","hash":"3ee5f2a934986a74ab6fe1c24f2ffee8d9f0b40c","modified":1522831029010},{"_id":"public/demo/css/demo.css","hash":"5e610860218722103852254901ed4f561695bd38","modified":1522831029010},{"_id":"public/demo/css/init.css","hash":"19249942460483b83425fd9072329b6b4decc9d6","modified":1522831029010},{"_id":"public/demo/css/normalize.css","hash":"a0ff1e2feee0b1bb7e54a88fd6367ba3e7435aaf","modified":1522831029010},{"_id":"public/demo/img/10.jpg","hash":"cf054dcda4fe76940264a2f7b45ace9a8f8788f2","modified":1522831029010},{"_id":"public/demo/img/11.jpg","hash":"9edc600344b745f9340fa041003254b6f60187ce","modified":1522831029011},{"_id":"public/demo/img/13.jpg","hash":"a5f476016a19effc9c588ba8938bf4c49414a089","modified":1522831029011},{"_id":"public/demo/img/12.jpg","hash":"e9857d9321c7b35847c24efd55e81a7657e3fc2d","modified":1522831029011},{"_id":"public/demo/img/14.jpg","hash":"99df3ffe7f7ce609402c27800ed758cddd8cd818","modified":1522831029011},{"_id":"public/demo/img/2.jpg","hash":"85d205dd455451e1235c33e27a1060ba5cf1b2c3","modified":1522831029011},{"_id":"public/demo/img/3.jpg","hash":"44945eec703223535155953fcf9c24c84e5b5056","modified":1522831029011},{"_id":"public/demo/img/4.jpg","hash":"769dbadadab1bd82b24b1a2cc4520a6713178120","modified":1522831029011},{"_id":"public/demo/img/5.jpg","hash":"4fff7c86ad034e7c5f7697b4f7b12f7525068c8f","modified":1522831029011},{"_id":"public/demo/img/6.jpg","hash":"688d59d3ddc43d117da60c2d86d4979d10b3e8f0","modified":1522831029011},{"_id":"public/demo/img/7.jpg","hash":"8069d3fc4a4737e3155799dcce2fedd4066d2bbb","modified":1522831029012},{"_id":"public/demo/img/8.jpg","hash":"5c1cc79f3c0dbab37493cb913f8f3a3b0ea38470","modified":1522831029012},{"_id":"public/demo/img/9.jpg","hash":"7c34266bb957f6b00a5d0bb5f5cedabd3a31fcf5","modified":1522831029012},{"_id":"public/demo/img/Thumbs.db","hash":"1f4318671088fdc6d057fa748a88f65519e721a8","modified":1522831029012},{"_id":"public/demo/img/dummy.png","hash":"b7bed4edd54d4b0d8dde97d03a102530fc9f9d54","modified":1522831029012},{"_id":"public/demo/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1522831029012},{"_id":"public/demo/js/colorfinder-1.1.js","hash":"fe47069f811272fcd33a7488642e30fd3f25d725","modified":1522831029012},{"_id":"public/demo/img/loading.gif","hash":"deedbc14742a4163d1fcce18211cfc76ba06505f","modified":1522831029012},{"_id":"public/demo/js/gridScrollFx.js","hash":"eaf98cdf8b39384e04ae61b901e08ed32aa485db","modified":1522831029012},{"_id":"public/demo/js/imagesloaded.pkgd.min.js","hash":"dea4f6ecff8935bba3323104fee273a173f1262e","modified":1522831029012},{"_id":"public/demo/js/masonry.pkgd.min.js","hash":"d87128d50e1c17e03ac7a2297dd0337158775301","modified":1522831029012},{"_id":"public/demo/js/modernizr.custom.js","hash":"897d01634e1728d281fa5c6e27f37d1d7652290c","modified":1522831029012},{"_id":"public/images/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1522831029012},{"_id":"public/images/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1522831029012},{"_id":"public/demo/img/1.jpg","hash":"2d1d841ae831bc8d88adbd95df9c1f3c331fb518","modified":1522831029012},{"_id":"public/demo/fonts/codropsicons/codropsicons.eot","hash":"d3bd1eb3823f094524ddf6070c154ccab81e6951","modified":1522831029012},{"_id":"public/demo/fonts/codropsicons/codropsicons.svg","hash":"0de9f0aaf1cdf27ef9931d45c5eab3374c7142f4","modified":1522831029012},{"_id":"public/demo/fonts/codropsicons/codropsicons.ttf","hash":"e670d3deb662651d71461be5a41add4a48b8998a","modified":1522831029012},{"_id":"public/demo/fonts/codropsicons/codropsicons.woff","hash":"7c0ba611c947ddb5a82fa47a87a1ce63ed8bcd7f","modified":1522831029012},{"_id":"public/demo/fonts/codropsicons/license.txt","hash":"d3d34d2a512acf27557ea82ac82a51058df43091","modified":1522831029012},{"_id":"public/css/article.css","hash":"5060d368c90ae89c685b671e17cdde20f1ef4da7","modified":1522831029772},{"_id":"public/css/backtop.css","hash":"f693d1f9ba2448427bd0e00985eebec9c9e8f752","modified":1522831029772},{"_id":"public/css/base.css","hash":"b169267e4f7644e3fdec722974d30b9eb0a8eb95","modified":1522831029773},{"_id":"public/css/category.css","hash":"5e8ed140ec7b3f192a26faf4b828ab655f476b80","modified":1522831029773},{"_id":"public/css/component.css","hash":"d1b9fedb2d82433c3af4205bd8392f6af671193c","modified":1522831029773},{"_id":"public/css/content.css","hash":"54857361624e89c91efadfe5605d1c40a5a799e9","modified":1522831029773},{"_id":"public/css/main.css","hash":"dd466f0a07445074140fa9771e8d605fbe690768","modified":1522831029773},{"_id":"public/css/mixins.css","hash":"c9f3e68e461ca4867ac76fd795cfcd93988a65a0","modified":1522831029773},{"_id":"public/css/navigation.css","hash":"18d3a17ce982a03ee7288a7d762f540a9905b906","modified":1522831029773},{"_id":"public/css/playball.css","hash":"49045d0cceae613d902d2e1b3fac268e8e555ae8","modified":1522831029773},{"_id":"public/css/search.css","hash":"02448d202f1f7871efb2791da81e7194bf93805a","modified":1522831029773},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522831029773},{"_id":"public/js/classie.js","hash":"782b9564f015a2ec7bdf9c89e238fab9b44bd587","modified":1522831029773},{"_id":"public/js/backtop.js","hash":"9f1c5967e3585d3ee323bf97f412af290ee4404f","modified":1522831029773},{"_id":"public/js/main.js","hash":"4e14f8cbfe3645876991a3541ba46f85a39b7252","modified":1522831029773},{"_id":"public/js/search.js","hash":"fe5812cd91d87eb083d5c02bba1c4570c3e5f84d","modified":1522831029773},{"_id":"public/js/uiMorphingButton_fixed.js","hash":"7e45f9a7588328559ccc4446d19922227f2d378f","modified":1522831029773},{"_id":"public/js/modernizr.custom.js","hash":"c36a15206943880cbb6a88016ab9f4b99a30570a","modified":1522831029773},{"_id":"public/css/style.css","hash":"d92209662d77bd14346b9b3f3e52349f8f8e38c7","modified":1522831029773},{"_id":"public/images/avatar.jpg","hash":"159a800376aebf291e959414f8b19da833a10648","modified":1522831029779},{"_id":"public/images/background_1.jpg","hash":"2dbf868225f7b454ca0c745c64a96ba948f00dc3","modified":1522831029779},{"_id":"public/images/background.jpg","hash":"b28817e6107175d793fcab7f48120926db2a6217","modified":1522831029808},{"_id":"public/images/background_bak.png","hash":"dcccd29a5e8b71153c3ed3f139c3de31f6fefd90","modified":1522831029819}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-10-09T14:51:34.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-10-09 22:51:34\n---\n","updated":"2017-10-16T15:25:32.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjfku9xo30001z4y8kddr26jh","content":"","excerpt":"","more":""}],"Post":[{"title":"iOS Touch Event传递和响应链","date":"2017-02-27T10:54:59.000Z","id":"8539A86063B11E16","typora-copy-images-to":"ipic","_content":"\n本来不想重复造轮子，因为网上已经很多关于iOS触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～\n\n<!-- more -->\n\n毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递(Event Delivery)，从UIApplication到响应事件的UIView是「从下往上」，反过来自然就是「从上往下」了。\n\n## 从下往上——寻找HitTest View\n\n当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象(Event Object)，携带着一些处理信息，eg:点击位置、事件类型等，然后将这个对象存放在UIApplication的事件队列中，等待处理。\n\n我们开发中使用的最多的是触碰事件(Touch Event)，也只有触碰事件才需要iOS为我们寻找**HitTest View**，即**寻找响应该事件的View**，这一过程，官方文档里称为***Hit-Testing***。\n\n了解这一过程，先了解UIView的两个可重载的方法：\n\n1. `- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event`\n\n   传入的参数类型是`CGPoint point`和`UIEvent *event` ，分别表示拥护触碰事件的**触碰点**和对应的**事件**，event可为nil，返回的是`Boolean`表示point是否在当前View的Bounds中。\n\n2. `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`\n\n   同样，传入的参数类型是`CGPoint point`和`UIEvent *event` ，event可为nil(我们本次讨论的是触碰事件的Hit-Testing，自然此参数不会为空)，此方法返回的是point所在的View。\n\n\n\n`hitTest:withEvent:`内部会先调用`pointInside:withEvent:`，来检测触碰点是否在当前View中\n\n- 若返回`NO`,则直接返回nil，且所有的SubView都不会响应当前事件。所以，敲重点啦，对于`clipsToBounds`设置为`NO`，允许SubView向外延伸的View，需要重载`pointInside:withEvent:`，例如：\n\n  ![TouchEvent_WechatIMG3](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg)\n\n  ```objective-c\n  - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n    \t//以下是伪代码  \n    \tif (point inside blueArea) return true;\n    \telse return false;\n  }\n  ```\n\n  如果没有重载`pointInside:withEvent:`，那么用户点击上图触碰点，SubView将不响应事件。\n\n\n- 若返回`YES`，则调用所有SubView的`hitTest:withEvent:`，继续寻找HitTest View。在视图层级树(这样翻译?! view hierarchy)中**最后添加的叶结点**且**包含触碰点**的View就会光荣地成为**HitTest View**(如下图最后一个UIView)，首先接受事件，并做下一步操作——寻找响应对象。\n\n  ![TouchEvent_WechatIMG1](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg)\n\n\n\n我们也可以在中途截断系统的Hit-Testing，如果你想让某个View的所有SubView都不响应事件，最简单的就是重载该View的`hitTest:withEvent:`，返回View（自己响应点击事件）或者nil（都不响应）。\n\n```objective-c\n-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n  \treturn self;\t// 自己成为HitTest View\n}\n```\n\n## 从上往下——寻找响应对象\n\n![1387344-cd500e5bd93d9606](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png)\n\n这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：\n\n当上一步找到的HitTest View没能响应事件时(eg:userInteractionEnabled为NO或者没有定义响应事件的方法)，那么事件就会被传递到SuperView或着Controller。直至Applicaion都不能处理该事件则忽略。\n\n需要注意的是：这里的传递只会给SuperView或着Controller，并不会传递给与自己相同级别的View，除非你自己控制。\n\niOS10的UIResponder中定义了两个新的Property：\n\n1. `nextResponder(Swift是next)`：这个比较蛋疼，因为UIResponder中它默认返回的是nil，所以如果我们想让特定的Responder响应事件，我们需要在我们的类中重载Get方法，返回自己想要的下一个Responder。\n2. `isFirstResponder`：判断当前View或Controller是否为即将响应事件的Responder。不能明白？！那么想想这两个方法：`becomeFirstResponder`和`resignFirstResponder`：）\n\n## 总结\n\n废话了这么多，三点：\n\n1. iOS的Touch Event先「从下往上」寻找HitTest View(FirstResponder)，再「从上往下」寻找真正响应该事件的Responder。\n2. 可以通过重载`hitTest:withEvent:`，决定HitTest View，即最开始**接收（敲重点，只是接收）**事件的Responder。\n3. Responder不一定会响应事件，看有没有响应事件的方法。\n\n\n\n所以，以后如果有人问你：两个View重叠在一起，在上面的View将下面的View完全覆盖，且上面的View不能响应事件，下面的View会响应吗？\n\n你不如先反问一句，两个View是否为SuperView和SubView的关系？！\n\n再分门别类地回答～\n\n以上\n\n\n\n## 参考文献\n\n[Event Handling Guide for iOS](https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1)\n\n","source":"_posts/iOS-Event传递和响应链.md","raw":"---\ntitle: iOS Touch Event传递和响应链\ndate: 2017-02-27 18:54:59\nid: 8539A86063B11E16\ntags: \n- UIView \ntypora-copy-images-to: ipic\n---\n\n本来不想重复造轮子，因为网上已经很多关于iOS触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～\n\n<!-- more -->\n\n毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递(Event Delivery)，从UIApplication到响应事件的UIView是「从下往上」，反过来自然就是「从上往下」了。\n\n## 从下往上——寻找HitTest View\n\n当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象(Event Object)，携带着一些处理信息，eg:点击位置、事件类型等，然后将这个对象存放在UIApplication的事件队列中，等待处理。\n\n我们开发中使用的最多的是触碰事件(Touch Event)，也只有触碰事件才需要iOS为我们寻找**HitTest View**，即**寻找响应该事件的View**，这一过程，官方文档里称为***Hit-Testing***。\n\n了解这一过程，先了解UIView的两个可重载的方法：\n\n1. `- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event`\n\n   传入的参数类型是`CGPoint point`和`UIEvent *event` ，分别表示拥护触碰事件的**触碰点**和对应的**事件**，event可为nil，返回的是`Boolean`表示point是否在当前View的Bounds中。\n\n2. `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event`\n\n   同样，传入的参数类型是`CGPoint point`和`UIEvent *event` ，event可为nil(我们本次讨论的是触碰事件的Hit-Testing，自然此参数不会为空)，此方法返回的是point所在的View。\n\n\n\n`hitTest:withEvent:`内部会先调用`pointInside:withEvent:`，来检测触碰点是否在当前View中\n\n- 若返回`NO`,则直接返回nil，且所有的SubView都不会响应当前事件。所以，敲重点啦，对于`clipsToBounds`设置为`NO`，允许SubView向外延伸的View，需要重载`pointInside:withEvent:`，例如：\n\n  ![TouchEvent_WechatIMG3](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg)\n\n  ```objective-c\n  - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n    \t//以下是伪代码  \n    \tif (point inside blueArea) return true;\n    \telse return false;\n  }\n  ```\n\n  如果没有重载`pointInside:withEvent:`，那么用户点击上图触碰点，SubView将不响应事件。\n\n\n- 若返回`YES`，则调用所有SubView的`hitTest:withEvent:`，继续寻找HitTest View。在视图层级树(这样翻译?! view hierarchy)中**最后添加的叶结点**且**包含触碰点**的View就会光荣地成为**HitTest View**(如下图最后一个UIView)，首先接受事件，并做下一步操作——寻找响应对象。\n\n  ![TouchEvent_WechatIMG1](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg)\n\n\n\n我们也可以在中途截断系统的Hit-Testing，如果你想让某个View的所有SubView都不响应事件，最简单的就是重载该View的`hitTest:withEvent:`，返回View（自己响应点击事件）或者nil（都不响应）。\n\n```objective-c\n-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n  \treturn self;\t// 自己成为HitTest View\n}\n```\n\n## 从上往下——寻找响应对象\n\n![1387344-cd500e5bd93d9606](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png)\n\n这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：\n\n当上一步找到的HitTest View没能响应事件时(eg:userInteractionEnabled为NO或者没有定义响应事件的方法)，那么事件就会被传递到SuperView或着Controller。直至Applicaion都不能处理该事件则忽略。\n\n需要注意的是：这里的传递只会给SuperView或着Controller，并不会传递给与自己相同级别的View，除非你自己控制。\n\niOS10的UIResponder中定义了两个新的Property：\n\n1. `nextResponder(Swift是next)`：这个比较蛋疼，因为UIResponder中它默认返回的是nil，所以如果我们想让特定的Responder响应事件，我们需要在我们的类中重载Get方法，返回自己想要的下一个Responder。\n2. `isFirstResponder`：判断当前View或Controller是否为即将响应事件的Responder。不能明白？！那么想想这两个方法：`becomeFirstResponder`和`resignFirstResponder`：）\n\n## 总结\n\n废话了这么多，三点：\n\n1. iOS的Touch Event先「从下往上」寻找HitTest View(FirstResponder)，再「从上往下」寻找真正响应该事件的Responder。\n2. 可以通过重载`hitTest:withEvent:`，决定HitTest View，即最开始**接收（敲重点，只是接收）**事件的Responder。\n3. Responder不一定会响应事件，看有没有响应事件的方法。\n\n\n\n所以，以后如果有人问你：两个View重叠在一起，在上面的View将下面的View完全覆盖，且上面的View不能响应事件，下面的View会响应吗？\n\n你不如先反问一句，两个View是否为SuperView和SubView的关系？！\n\n再分门别类地回答～\n\n以上\n\n\n\n## 参考文献\n\n[Event Handling Guide for iOS](https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1)\n\n","slug":"iOS-Event传递和响应链","published":1,"updated":"2018-03-07T09:19:00.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xnz0000z4y8a919o8t0","content":"<p>本来不想重复造轮子，因为网上已经很多关于iOS触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～</p>\n<a id=\"more\"></a>\n<p>毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递(Event Delivery)，从UIApplication到响应事件的UIView是「从下往上」，反过来自然就是「从上往下」了。</p>\n<h2 id=\"从下往上——寻找HitTest-View\"><a href=\"#从下往上——寻找HitTest-View\" class=\"headerlink\" title=\"从下往上——寻找HitTest View\"></a>从下往上——寻找HitTest View</h2><p>当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象(Event Object)，携带着一些处理信息，eg:点击位置、事件类型等，然后将这个对象存放在UIApplication的事件队列中，等待处理。</p>\n<p>我们开发中使用的最多的是触碰事件(Touch Event)，也只有触碰事件才需要iOS为我们寻找<strong>HitTest View</strong>，即<strong>寻找响应该事件的View</strong>，这一过程，官方文档里称为<strong><em>Hit-Testing</em></strong>。</p>\n<p>了解这一过程，先了解UIView的两个可重载的方法：</p>\n<ol>\n<li><p><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，分别表示拥护触碰事件的<strong>触碰点</strong>和对应的<strong>事件</strong>，event可为nil，返回的是<code>Boolean</code>表示point是否在当前View的Bounds中。</p>\n</li>\n<li><p><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>同样，传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，event可为nil(我们本次讨论的是触碰事件的Hit-Testing，自然此参数不会为空)，此方法返回的是point所在的View。</p>\n</li>\n</ol>\n<p><code>hitTest:withEvent:</code>内部会先调用<code>pointInside:withEvent:</code>，来检测触碰点是否在当前View中</p>\n<ul>\n<li><p>若返回<code>NO</code>,则直接返回nil，且所有的SubView都不会响应当前事件。所以，敲重点啦，对于<code>clipsToBounds</code>设置为<code>NO</code>，允许SubView向外延伸的View，需要重载<code>pointInside:withEvent:</code>，例如：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg\" alt=\"TouchEvent_WechatIMG3\"></p>\n<pre><code class=\"objective-c\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n      //以下是伪代码  \n      if (point inside blueArea) return true;\n      else return false;\n}\n</code></pre>\n<p>如果没有重载<code>pointInside:withEvent:</code>，那么用户点击上图触碰点，SubView将不响应事件。</p>\n</li>\n</ul>\n<ul>\n<li><p>若返回<code>YES</code>，则调用所有SubView的<code>hitTest:withEvent:</code>，继续寻找HitTest View。在视图层级树(这样翻译?! view hierarchy)中<strong>最后添加的叶结点</strong>且<strong>包含触碰点</strong>的View就会光荣地成为<strong>HitTest View</strong>(如下图最后一个UIView)，首先接受事件，并做下一步操作——寻找响应对象。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg\" alt=\"TouchEvent_WechatIMG1\"></p>\n</li>\n</ul>\n<p>我们也可以在中途截断系统的Hit-Testing，如果你想让某个View的所有SubView都不响应事件，最简单的就是重载该View的<code>hitTest:withEvent:</code>，返回View（自己响应点击事件）或者nil（都不响应）。</p>\n<pre><code class=\"objective-c\">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n      return self;    // 自己成为HitTest View\n}\n</code></pre>\n<h2 id=\"从上往下——寻找响应对象\"><a href=\"#从上往下——寻找响应对象\" class=\"headerlink\" title=\"从上往下——寻找响应对象\"></a>从上往下——寻找响应对象</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png\" alt=\"1387344-cd500e5bd93d9606\"></p>\n<p>这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：</p>\n<p>当上一步找到的HitTest View没能响应事件时(eg:userInteractionEnabled为NO或者没有定义响应事件的方法)，那么事件就会被传递到SuperView或着Controller。直至Applicaion都不能处理该事件则忽略。</p>\n<p>需要注意的是：这里的传递只会给SuperView或着Controller，并不会传递给与自己相同级别的View，除非你自己控制。</p>\n<p>iOS10的UIResponder中定义了两个新的Property：</p>\n<ol>\n<li><code>nextResponder(Swift是next)</code>：这个比较蛋疼，因为UIResponder中它默认返回的是nil，所以如果我们想让特定的Responder响应事件，我们需要在我们的类中重载Get方法，返回自己想要的下一个Responder。</li>\n<li><code>isFirstResponder</code>：判断当前View或Controller是否为即将响应事件的Responder。不能明白？！那么想想这两个方法：<code>becomeFirstResponder</code>和<code>resignFirstResponder</code>：）</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>废话了这么多，三点：</p>\n<ol>\n<li>iOS的Touch Event先「从下往上」寻找HitTest View(FirstResponder)，再「从上往下」寻找真正响应该事件的Responder。</li>\n<li>可以通过重载<code>hitTest:withEvent:</code>，决定HitTest View，即最开始<strong>接收（敲重点，只是接收）</strong>事件的Responder。</li>\n<li>Responder不一定会响应事件，看有没有响应事件的方法。</li>\n</ol>\n<p>所以，以后如果有人问你：两个View重叠在一起，在上面的View将下面的View完全覆盖，且上面的View不能响应事件，下面的View会响应吗？</p>\n<p>你不如先反问一句，两个View是否为SuperView和SubView的关系？！</p>\n<p>再分门别类地回答～</p>\n<p>以上</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1\" target=\"_blank\" rel=\"external\">Event Handling Guide for iOS</a></p>\n","excerpt":"<p>本来不想重复造轮子，因为网上已经很多关于iOS触碰事件传递响应链的文章，而且苹果官方文档也已经解释得很清楚。但是上周和朋友吃饭的时候聊到却不能很好地将想法表达出来，所以感觉还是写一写，加深印象吧～</p>","more":"<p>毋庸置疑地，在论及事件传递的时候我们都会很顺口地使用用上下方向来表达事件传递(Event Delivery)，从UIApplication到响应事件的UIView是「从下往上」，反过来自然就是「从上往下」了。</p>\n<h2 id=\"从下往上——寻找HitTest-View\"><a href=\"#从下往上——寻找HitTest-View\" class=\"headerlink\" title=\"从下往上——寻找HitTest View\"></a>从下往上——寻找HitTest View</h2><p>当一个用户产生的事件发生并被系统捕获到后，UIKit会创建一个事件对象(Event Object)，携带着一些处理信息，eg:点击位置、事件类型等，然后将这个对象存放在UIApplication的事件队列中，等待处理。</p>\n<p>我们开发中使用的最多的是触碰事件(Touch Event)，也只有触碰事件才需要iOS为我们寻找<strong>HitTest View</strong>，即<strong>寻找响应该事件的View</strong>，这一过程，官方文档里称为<strong><em>Hit-Testing</em></strong>。</p>\n<p>了解这一过程，先了解UIView的两个可重载的方法：</p>\n<ol>\n<li><p><code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，分别表示拥护触碰事件的<strong>触碰点</strong>和对应的<strong>事件</strong>，event可为nil，返回的是<code>Boolean</code>表示point是否在当前View的Bounds中。</p>\n</li>\n<li><p><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code></p>\n<p>同样，传入的参数类型是<code>CGPoint point</code>和<code>UIEvent *event</code> ，event可为nil(我们本次讨论的是触碰事件的Hit-Testing，自然此参数不会为空)，此方法返回的是point所在的View。</p>\n</li>\n</ol>\n<p><code>hitTest:withEvent:</code>内部会先调用<code>pointInside:withEvent:</code>，来检测触碰点是否在当前View中</p>\n<ul>\n<li><p>若返回<code>NO</code>,则直接返回nil，且所有的SubView都不会响应当前事件。所以，敲重点啦，对于<code>clipsToBounds</code>设置为<code>NO</code>，允许SubView向外延伸的View，需要重载<code>pointInside:withEvent:</code>，例如：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rkb9k.jpg\" alt=\"TouchEvent_WechatIMG3\"></p>\n<pre><code class=\"objective-c\">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{\n      //以下是伪代码  \n      if (point inside blueArea) return true;\n      else return false;\n}\n</code></pre>\n<p>如果没有重载<code>pointInside:withEvent:</code>，那么用户点击上图触碰点，SubView将不响应事件。</p>\n</li>\n</ul>\n<ul>\n<li><p>若返回<code>YES</code>，则调用所有SubView的<code>hitTest:withEvent:</code>，继续寻找HitTest View。在视图层级树(这样翻译?! view hierarchy)中<strong>最后添加的叶结点</strong>且<strong>包含触碰点</strong>的View就会光荣地成为<strong>HitTest View</strong>(如下图最后一个UIView)，首先接受事件，并做下一步操作——寻找响应对象。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zedzb.jpg\" alt=\"TouchEvent_WechatIMG1\"></p>\n</li>\n</ul>\n<p>我们也可以在中途截断系统的Hit-Testing，如果你想让某个View的所有SubView都不响应事件，最简单的就是重载该View的<code>hitTest:withEvent:</code>，返回View（自己响应点击事件）或者nil（都不响应）。</p>\n<pre><code class=\"objective-c\">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    //return nil; 本View和SubView都不成为HitTest View，都不响应事件\n      return self;    // 自己成为HitTest View\n}\n</code></pre>\n<h2 id=\"从上往下——寻找响应对象\"><a href=\"#从上往下——寻找响应对象\" class=\"headerlink\" title=\"从上往下——寻找响应对象\"></a>从上往下——寻找响应对象</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/2fznc.png\" alt=\"1387344-cd500e5bd93d9606\"></p>\n<p>这张图相信在其他地方已经看了一千遍了，但是有图还是容易理解，从上往下的意思是：</p>\n<p>当上一步找到的HitTest View没能响应事件时(eg:userInteractionEnabled为NO或者没有定义响应事件的方法)，那么事件就会被传递到SuperView或着Controller。直至Applicaion都不能处理该事件则忽略。</p>\n<p>需要注意的是：这里的传递只会给SuperView或着Controller，并不会传递给与自己相同级别的View，除非你自己控制。</p>\n<p>iOS10的UIResponder中定义了两个新的Property：</p>\n<ol>\n<li><code>nextResponder(Swift是next)</code>：这个比较蛋疼，因为UIResponder中它默认返回的是nil，所以如果我们想让特定的Responder响应事件，我们需要在我们的类中重载Get方法，返回自己想要的下一个Responder。</li>\n<li><code>isFirstResponder</code>：判断当前View或Controller是否为即将响应事件的Responder。不能明白？！那么想想这两个方法：<code>becomeFirstResponder</code>和<code>resignFirstResponder</code>：）</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>废话了这么多，三点：</p>\n<ol>\n<li>iOS的Touch Event先「从下往上」寻找HitTest View(FirstResponder)，再「从上往下」寻找真正响应该事件的Responder。</li>\n<li>可以通过重载<code>hitTest:withEvent:</code>，决定HitTest View，即最开始<strong>接收（敲重点，只是接收）</strong>事件的Responder。</li>\n<li>Responder不一定会响应事件，看有没有响应事件的方法。</li>\n</ol>\n<p>所以，以后如果有人问你：两个View重叠在一起，在上面的View将下面的View完全覆盖，且上面的View不能响应事件，下面的View会响应吗？</p>\n<p>你不如先反问一句，两个View是否为SuperView和SubView的关系？！</p>\n<p>再分门别类地回答～</p>\n<p>以上</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1\">Event Handling Guide for iOS</a></p>"},{"title":"Autoresizing Mask","date":"2016-03-19T15:41:26.000Z","typora-copy-images-to":"ipic","_content":"\n不知道大家在开发的时候会不会使用到UIView的autoresizingMask属性。我自己的话自从开始出现autoLayout就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。\n\n<!--more-->\n\n# autoresizingMask\n它对应着一个枚举，属性是自动调整SubView和SuperView之间的位置和宽高。\n```\nenum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n   UIViewAutoresizingFlexibleWidth        = 1 << 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n   UIViewAutoresizingFlexibleHeight       = 1 << 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n## 简单介绍\n### UIViewAutoresizingNone\n不设置自动调整，默认值\n### UIViewAutoresizingFlexibleRightMargin \n这里就只讲UIViewAutoresizingFlexibleRightMargin,因为上下左右四个方位是一致的原理\n![autoresizingMask_FlexibleRightMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg)\n### UIViewAutoresizingFlexibleWidth\nUIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight也是同样的原理\n![autoresizingMask_FlexibleWidthCompare](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg)\n\n### 组合起来\n枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：\n``` objc\nUIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n```\n表示左右间隔都可以修改，效果就像上面那张图一样~\n\n## 有点代码对比会好些\n``` objc\n#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@\"Ezfen\"];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n```\n\n上面的代码中尺寸宽度被限定为iPhone4s的320。没有设置子View（蓝色的View）的autoresizingMask属性的话运行结果如下：\n![autoresizingMask_4s](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg)\n\n设置了子View（蓝色的View）autoresizingMask后，再修改父View的宽度，可以看到随着赋值的不同，有不同的效果：\n设置了UIViewAutoresizingFlexibleLeftMargin\n![autoresizingMask_FlexibleLeftMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg)\n\n还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~\n","source":"_posts/autoresizingMask.md","raw":"---\ntitle: Autoresizing Mask\ndate: 2016-03-19 23:41:26\ntags: \n- UIView\ntypora-copy-images-to: ipic\n---\n\n不知道大家在开发的时候会不会使用到UIView的autoresizingMask属性。我自己的话自从开始出现autoLayout就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。\n\n<!--more-->\n\n# autoresizingMask\n它对应着一个枚举，属性是自动调整SubView和SuperView之间的位置和宽高。\n```\nenum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n   UIViewAutoresizingFlexibleWidth        = 1 << 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n   UIViewAutoresizingFlexibleHeight       = 1 << 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n## 简单介绍\n### UIViewAutoresizingNone\n不设置自动调整，默认值\n### UIViewAutoresizingFlexibleRightMargin \n这里就只讲UIViewAutoresizingFlexibleRightMargin,因为上下左右四个方位是一致的原理\n![autoresizingMask_FlexibleRightMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg)\n### UIViewAutoresizingFlexibleWidth\nUIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight也是同样的原理\n![autoresizingMask_FlexibleWidthCompare](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg)\n\n### 组合起来\n枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：\n``` objc\nUIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n```\n表示左右间隔都可以修改，效果就像上面那张图一样~\n\n## 有点代码对比会好些\n``` objc\n#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@\"Ezfen\"];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n```\n\n上面的代码中尺寸宽度被限定为iPhone4s的320。没有设置子View（蓝色的View）的autoresizingMask属性的话运行结果如下：\n![autoresizingMask_4s](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg)\n\n设置了子View（蓝色的View）autoresizingMask后，再修改父View的宽度，可以看到随着赋值的不同，有不同的效果：\n设置了UIViewAutoresizingFlexibleLeftMargin\n![autoresizingMask_FlexibleLeftMargin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg)\n\n还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~\n","slug":"autoresizingMask","published":1,"updated":"2018-03-07T08:09:47.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xob0002z4y8i0kd4esk","content":"<p>不知道大家在开发的时候会不会使用到UIView的autoresizingMask属性。我自己的话自从开始出现autoLayout就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"autoresizingMask\"><a href=\"#autoresizingMask\" class=\"headerlink\" title=\"autoresizingMask\"></a>autoresizingMask</h1><p>它对应着一个枚举，属性是自动调整SubView和SuperView之间的位置和宽高。</p>\n<pre><code>enum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,\n   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,\n   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5\n};\n</code></pre><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><h3 id=\"UIViewAutoresizingNone\"><a href=\"#UIViewAutoresizingNone\" class=\"headerlink\" title=\"UIViewAutoresizingNone\"></a>UIViewAutoresizingNone</h3><p>不设置自动调整，默认值</p>\n<h3 id=\"UIViewAutoresizingFlexibleRightMargin\"><a href=\"#UIViewAutoresizingFlexibleRightMargin\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleRightMargin\"></a>UIViewAutoresizingFlexibleRightMargin</h3><p>这里就只讲UIViewAutoresizingFlexibleRightMargin,因为上下左右四个方位是一致的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg\" alt=\"autoresizingMask_FlexibleRightMargin\"></p>\n<h3 id=\"UIViewAutoresizingFlexibleWidth\"><a href=\"#UIViewAutoresizingFlexibleWidth\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleWidth\"></a>UIViewAutoresizingFlexibleWidth</h3><p>UIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight也是同样的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg\" alt=\"autoresizingMask_FlexibleWidthCompare\"></p>\n<h3 id=\"组合起来\"><a href=\"#组合起来\" class=\"headerlink\" title=\"组合起来\"></a>组合起来</h3><p>枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：</p>\n<pre><code class=\"objc\">UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n</code></pre>\n<p>表示左右间隔都可以修改，效果就像上面那张图一样~</p>\n<h2 id=\"有点代码对比会好些\"><a href=\"#有点代码对比会好些\" class=\"headerlink\" title=\"有点代码对比会好些\"></a>有点代码对比会好些</h2><pre><code class=\"objc\">#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@&quot;Ezfen&quot;];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n</code></pre>\n<p>上面的代码中尺寸宽度被限定为iPhone4s的320。没有设置子View（蓝色的View）的autoresizingMask属性的话运行结果如下：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg\" alt=\"autoresizingMask_4s\"></p>\n<p>设置了子View（蓝色的View）autoresizingMask后，再修改父View的宽度，可以看到随着赋值的不同，有不同的效果：<br>设置了UIViewAutoresizingFlexibleLeftMargin<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg\" alt=\"autoresizingMask_FlexibleLeftMargin\"></p>\n<p>还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~</p>\n","excerpt":"<p>不知道大家在开发的时候会不会使用到UIView的autoresizingMask属性。我自己的话自从开始出现autoLayout就没再用过了。前几天翻看一些较老的书籍，发现了它静静躺在角落。不知不觉还真的有些忘记了，于是温故知新，再学习了一下。</p>","more":"<h1 id=\"autoresizingMask\"><a href=\"#autoresizingMask\" class=\"headerlink\" title=\"autoresizingMask\"></a>autoresizingMask</h1><p>它对应着一个枚举，属性是自动调整SubView和SuperView之间的位置和宽高。</p>\n<pre><code>enum {\n   UIViewAutoresizingNone                 = 0,\n   UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,\n   UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,\n   UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,\n   UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,\n   UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,\n   UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5\n};\n</code></pre><h2 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h2><h3 id=\"UIViewAutoresizingNone\"><a href=\"#UIViewAutoresizingNone\" class=\"headerlink\" title=\"UIViewAutoresizingNone\"></a>UIViewAutoresizingNone</h3><p>不设置自动调整，默认值</p>\n<h3 id=\"UIViewAutoresizingFlexibleRightMargin\"><a href=\"#UIViewAutoresizingFlexibleRightMargin\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleRightMargin\"></a>UIViewAutoresizingFlexibleRightMargin</h3><p>这里就只讲UIViewAutoresizingFlexibleRightMargin,因为上下左右四个方位是一致的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/skwhi.jpg\" alt=\"autoresizingMask_FlexibleRightMargin\"></p>\n<h3 id=\"UIViewAutoresizingFlexibleWidth\"><a href=\"#UIViewAutoresizingFlexibleWidth\" class=\"headerlink\" title=\"UIViewAutoresizingFlexibleWidth\"></a>UIViewAutoresizingFlexibleWidth</h3><p>UIViewAutoresizingFlexibleWidth和UIViewAutoresizingFlexibleHeight也是同样的原理<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wrxva.jpg\" alt=\"autoresizingMask_FlexibleWidthCompare\"></p>\n<h3 id=\"组合起来\"><a href=\"#组合起来\" class=\"headerlink\" title=\"组合起来\"></a>组合起来</h3><p>枚举中的值是允许使用|组合起来的，同时拥有多个值的功能，like this：</p>\n<pre><code class=\"objc\">UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleRIGHTMargin\n</code></pre>\n<p>表示左右间隔都可以修改，效果就像上面那张图一样~</p>\n<h2 id=\"有点代码对比会好些\"><a href=\"#有点代码对比会好些\" class=\"headerlink\" title=\"有点代码对比会好些\"></a>有点代码对比会好些</h2><pre><code class=\"objc\">#define kTopSpace 64\n#define kMargin 20\n#define kTopViewHeight 44\n#define kTopViewWidth 280\n#define kTextLabelWidth 200\n#define kTextLabelHeight 30\n//以Iphone4（320， 480）为基础，设置各控件的位置\n//注意：必须所有控件都按照Iphone4（320， 480）为基础初始化一次，不然按比例缩放时会发生错误！\nUIView *topView = [[UIView alloc] initWithFrame:CGRectMake(kMargin, kTopSpace, kTopViewWidth, kTopViewHeight)];\nCGFloat textLabelTop = (topView.frame.size.width - kTextLabelWidth) / 2;\nCGFloat textLabelWidth = (topView.frame.size.height - kTextLabelHeight) / 2;\nUILabel *textLabel = [[UILabel alloc] initWithFrame:CGRectMake(textLabelTop, textLabelWidth, kTextLabelWidth, kTextLabelHeight)];\n//设置文字及居中\n[textLabel setText:@&quot;Ezfen&quot;];\n[textLabel setTextAlignment:NSTextAlignmentCenter];\n//分别设置样式\n[topView setBackgroundColor:[UIColor redColor]];\n[textLabel setTextColor:[UIColor whiteColor]];\n//设置文字控件的宽度按照上一级视图（topView）的比例进行缩放\n[textLabel setAutoresizingMask:UIViewAutoresizingFlexibleWidth];\n//添加视图\n[topView addSubview:textLabel];\n[self.view addSubview:topView];\n//注意：重新设置topView位置的代码，必须要写在添加视图的后面，不然autoresizing的位置计算会出错！\nCGFloat topViewWidth = kUIScreen.size.width - kMargin * 2;\n[topView setFrame:CGRectMake(kMargin, kTopSpace, topViewWidth, kTopViewHeight)];\n</code></pre>\n<p>上面的代码中尺寸宽度被限定为iPhone4s的320。没有设置子View（蓝色的View）的autoresizingMask属性的话运行结果如下：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pmjrs.jpg\" alt=\"autoresizingMask_4s\"></p>\n<p>设置了子View（蓝色的View）autoresizingMask后，再修改父View的宽度，可以看到随着赋值的不同，有不同的效果：<br>设置了UIViewAutoresizingFlexibleLeftMargin<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m2hgw.jpg\" alt=\"autoresizingMask_FlexibleLeftMargin\"></p>\n<p>还有的其他值对应的效果图在上文已经摆出来了，请参阅哈~~</p>"},{"title":"穿越的桃心~","date":"2016-05-21T07:23:18.000Z","typora-copy-images-to":"ipic","_content":"\n最近没事看看Instagram的时候，对于双击点赞的功能感觉蛮Like。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)\n\n<!--more-->\n\n![EZHeartForLike_logo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png)    \n效果图(第一张是双击图片触发，第二张是单击按钮)：\n![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif)       ![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif)    \n先说说这是个什么东西。    \n一开始我是在Instagram的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。like this(专门截了我❤️GEM❤️过来，Instagram的心挡住她的脸了。。。)：\n![EZHeartForLike_gem](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg)    \n好吧，尺寸是是用我又爱又恨的4S的 320 x 480    \n紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样\n![aixin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg)\n很快我遇到问题：如果两个桃心都在同一个View中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个View中（现实中很多情况都不会），**位置不明确**是一个Super巨大的问题。因此跨View的动画是EZHeartForLike是这次的主要话题。当然动画是使用UIView来实现的~~    \n那么，讲讲我的思路历程吧：    \n首先，我想了下能不能在一个EZHeartForLikeView中分别放入下列三个View，已实现我的想法：    \n* ContentView ：用于让用户将自己的View放入其中。类似iOS8里面的UIVisualEffectView的contentView一样。    \n* SmallHeart ：被当做按钮的小桃心，是Public的，提供给用户改造它的样式、大小、位置等。 \n* BigHeart ：出现在图片(ImageView)中的大桃心\n\n在我自己涂涂画画后是这样的：    \n![EZHeartForLike_begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg)\n\n一开始觉得可能能行，因为两个桃心都在同一个View中(EZHeartForLikeView)，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为Public对外提供，那么用户就可以将它放入自己的View中。因此这个想法很快被否了。。。\n\n这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个SuperView，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：    \n简单一句话就是：**找到相同的SuperView，映射坐标，在SuperView上完成动画的实现**    \n![EZHeartForLike_findview](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg)\n具体怎么找到相同的SuperView嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。    \n这里我又要祭出我的灵魂画风了\n![EZHeartForLike_lianbiao](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg)    \n实现起来其实不是能难，且看代码：\n\n``` objc\n- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount > bigViewSuperViewCount) {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n```\n\n有了上面的思想，映射坐标同样变得简单：\n\n``` objc \n    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n```\n\n既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)    \n有兴趣的同学可以查看我的[Github](https://github.com/objchris/EZHeartForLike)，可以下载在项目中，顺便给我个Like吧![hahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)","source":"_posts/EZHeartForLike.md","raw":"---\ntitle: 穿越的桃心~\ndate: 2016-05-21 15:23:18\ntags: \n- Animation\ntypora-copy-images-to: ipic\n---\n\n最近没事看看Instagram的时候，对于双击点赞的功能感觉蛮Like。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)\n\n<!--more-->\n\n![EZHeartForLike_logo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png)    \n效果图(第一张是双击图片触发，第二张是单击按钮)：\n![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif)       ![](https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif)    \n先说说这是个什么东西。    \n一开始我是在Instagram的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。like this(专门截了我❤️GEM❤️过来，Instagram的心挡住她的脸了。。。)：\n![EZHeartForLike_gem](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg)    \n好吧，尺寸是是用我又爱又恨的4S的 320 x 480    \n紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样\n![aixin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg)\n很快我遇到问题：如果两个桃心都在同一个View中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个View中（现实中很多情况都不会），**位置不明确**是一个Super巨大的问题。因此跨View的动画是EZHeartForLike是这次的主要话题。当然动画是使用UIView来实现的~~    \n那么，讲讲我的思路历程吧：    \n首先，我想了下能不能在一个EZHeartForLikeView中分别放入下列三个View，已实现我的想法：    \n* ContentView ：用于让用户将自己的View放入其中。类似iOS8里面的UIVisualEffectView的contentView一样。    \n* SmallHeart ：被当做按钮的小桃心，是Public的，提供给用户改造它的样式、大小、位置等。 \n* BigHeart ：出现在图片(ImageView)中的大桃心\n\n在我自己涂涂画画后是这样的：    \n![EZHeartForLike_begin](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg)\n\n一开始觉得可能能行，因为两个桃心都在同一个View中(EZHeartForLikeView)，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为Public对外提供，那么用户就可以将它放入自己的View中。因此这个想法很快被否了。。。\n\n这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个SuperView，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：    \n简单一句话就是：**找到相同的SuperView，映射坐标，在SuperView上完成动画的实现**    \n![EZHeartForLike_findview](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg)\n具体怎么找到相同的SuperView嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。    \n这里我又要祭出我的灵魂画风了\n![EZHeartForLike_lianbiao](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg)    \n实现起来其实不是能难，且看代码：\n\n``` objc\n- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount > bigViewSuperViewCount) {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i < mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n```\n\n有了上面的思想，映射坐标同样变得简单：\n\n``` objc \n    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n```\n\n既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)    \n有兴趣的同学可以查看我的[Github](https://github.com/objchris/EZHeartForLike)，可以下载在项目中，顺便给我个Like吧![hahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)","slug":"EZHeartForLike","published":1,"updated":"2018-03-07T08:14:04.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xog0004z4y8o04c4pzf","content":"<p>最近没事看看Instagram的时候，对于双击点赞的功能感觉蛮Like。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png\" alt=\"EZHeartForLike_logo\"><br>效果图(第一张是双击图片触发，第二张是单击按钮)：<br><img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif\" alt=\"\">       <img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif\" alt=\"\"><br>先说说这是个什么东西。<br>一开始我是在Instagram的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。like this(专门截了我❤️GEM❤️过来，Instagram的心挡住她的脸了。。。)：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg\" alt=\"EZHeartForLike_gem\"><br>好吧，尺寸是是用我又爱又恨的4S的 320 x 480<br>紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg\" alt=\"aixin\"><br>很快我遇到问题：如果两个桃心都在同一个View中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个View中（现实中很多情况都不会），<strong>位置不明确</strong>是一个Super巨大的问题。因此跨View的动画是EZHeartForLike是这次的主要话题。当然动画是使用UIView来实现的~~<br>那么，讲讲我的思路历程吧：<br>首先，我想了下能不能在一个EZHeartForLikeView中分别放入下列三个View，已实现我的想法：    </p>\n<ul>\n<li>ContentView ：用于让用户将自己的View放入其中。类似iOS8里面的UIVisualEffectView的contentView一样。    </li>\n<li>SmallHeart ：被当做按钮的小桃心，是Public的，提供给用户改造它的样式、大小、位置等。 </li>\n<li>BigHeart ：出现在图片(ImageView)中的大桃心</li>\n</ul>\n<p>在我自己涂涂画画后是这样的：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg\" alt=\"EZHeartForLike_begin\"></p>\n<p>一开始觉得可能能行，因为两个桃心都在同一个View中(EZHeartForLikeView)，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为Public对外提供，那么用户就可以将它放入自己的View中。因此这个想法很快被否了。。。</p>\n<p>这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个SuperView，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：<br>简单一句话就是：<strong>找到相同的SuperView，映射坐标，在SuperView上完成动画的实现</strong><br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg\" alt=\"EZHeartForLike_findview\"><br>具体怎么找到相同的SuperView嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。<br>这里我又要祭出我的灵魂画风了<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg\" alt=\"EZHeartForLike_lianbiao\"><br>实现起来其实不是能难，且看代码：</p>\n<pre><code class=\"objc\">- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount &gt; bigViewSuperViewCount) {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n</code></pre>\n<p>有了上面的思想，映射坐标同样变得简单：</p>\n<pre><code class=\"objc\">    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n</code></pre>\n<p>既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)<br>有兴趣的同学可以查看我的<a href=\"https://github.com/objchris/EZHeartForLike\" target=\"_blank\" rel=\"external\">Github</a>，可以下载在项目中，顺便给我个Like吧<img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahaha\"></p>\n","excerpt":"<p>最近没事看看Instagram的时候，对于双击点赞的功能感觉蛮Like。所以就想自己仿照做一个。但是嘞，直接仿造感觉不是很好玩，所以就自己想添加点新东西，因此就有了EZHeartForLike。:)</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pwmtz.png\" alt=\"EZHeartForLike_logo\"><br>效果图(第一张是双击图片触发，第二张是单击按钮)：<br><img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/double.gif\" alt=\"\">       <img src=\"https://raw.githubusercontent.com/Ezfen/EZHeartForLike/master/single.gif\" alt=\"\"><br>先说说这是个什么东西。<br>一开始我是在Instagram的基础上开始做的。双击点击图片可以弹出一个桃心，随即下面的小桃心点亮。完成点赞的操作。like this(专门截了我❤️GEM❤️过来，Instagram的心挡住她的脸了。。。)：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/37lsw.jpg\" alt=\"EZHeartForLike_gem\"><br>好吧，尺寸是是用我又爱又恨的4S的 320 x 480<br>紧接着就想，能不能实现大桃心一边移动一边缩小，最后到大小桃心的位置并替换它？！就像上面最终效果一样<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/4p80z.jpg\" alt=\"aixin\"><br>很快我遇到问题：如果两个桃心都在同一个View中，话甘易啦！！！但是现在的情况是两个桃心并不在同一个View中（现实中很多情况都不会），<strong>位置不明确</strong>是一个Super巨大的问题。因此跨View的动画是EZHeartForLike是这次的主要话题。当然动画是使用UIView来实现的~~<br>那么，讲讲我的思路历程吧：<br>首先，我想了下能不能在一个EZHeartForLikeView中分别放入下列三个View，已实现我的想法：    </p>\n<ul>\n<li>ContentView ：用于让用户将自己的View放入其中。类似iOS8里面的UIVisualEffectView的contentView一样。    </li>\n<li>SmallHeart ：被当做按钮的小桃心，是Public的，提供给用户改造它的样式、大小、位置等。 </li>\n<li>BigHeart ：出现在图片(ImageView)中的大桃心</li>\n</ul>\n<p>在我自己涂涂画画后是这样的：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r0ov5.jpg\" alt=\"EZHeartForLike_begin\"></p>\n<p>一开始觉得可能能行，因为两个桃心都在同一个View中(EZHeartForLikeView)，要实现动画应该是没什么问题，但是后来想到，既然我把小桃心作为Public对外提供，那么用户就可以将它放入自己的View中。因此这个想法很快被否了。。。</p>\n<p>这个问题让我便秘了两天，哈哈哈哈。后来在洗澡时想到一个或许能解决问题的方法，虽然大小桃心的位置都不清楚，但是他们至少有同一个SuperView，或许加以利用就能实现这个想法。谁知道嘞，试一下吧：<br>简单一句话就是：<strong>找到相同的SuperView，映射坐标，在SuperView上完成动画的实现</strong><br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1c4s3.jpg\" alt=\"EZHeartForLike_findview\"><br>具体怎么找到相同的SuperView嘞，那就要扯到另外一个算法了，那就是判断两条链表是否相交，且交点是哪一个的问题。<br>这里我又要祭出我的灵魂画风了<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e0q6r.jpg\" alt=\"EZHeartForLike_lianbiao\"><br>实现起来其实不是能难，且看代码：</p>\n<pre><code class=\"objc\">- (UIView *)findTheMutualSuperView {\n    // 找出小桃心（self）和大桃心（self.BigHeart）的共同的SuperView\n    // 计算self到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view1 = self;\n    NSInteger smallViewSuperViewCount = 0;\n    while (![view1 isKindOfClass:[UIWindow class]]) {\n        smallViewSuperViewCount ++;\n        view1 = view1.superview;\n    }\n    // 计算self.BigHeart到UIWindow的距离（以中间View的层数为距离计量）\n    UIView *view2 = self.BigHeart;\n    NSInteger bigViewSuperViewCount = 0;\n    while (![view2 isKindOfClass:[UIWindow class]]) {\n        bigViewSuperViewCount ++;\n        view2 = view2.superview;\n    }\n    // 共同的SuperView之后的View肯定是一致的，因此小桃心和大桃心到UIWindow的距离之间的差\n    // 实在共同的SuperView之前就存在的。所以，判断二者到UIWindow的距离大小，并利用两者之间\n    // 的差距就可以找到共同的SuperView\n    NSInteger mutualViewCount = labs(smallViewSuperViewCount - bigViewSuperViewCount);\n    view1 = self;\n    view2 = self.BigHeart;\n    if (smallViewSuperViewCount &gt; bigViewSuperViewCount) {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view1 = view1.superview;\n        }\n    } else {\n        for (int i = 0; i &lt; mutualViewCount; ++ i) {\n            view2 = view2.superview;\n        }\n    }\n    while (view1 != view2) {\n        view1 = view1.superview;\n        view2 = view2.superview;\n    }\n    return view1;\n}\n</code></pre>\n<p>有了上面的思想，映射坐标同样变得简单：</p>\n<pre><code class=\"objc\">    //映射两个Heart的坐标。\n    // 首先是小桃心(self)\n    UIView *view1 = self;\n    CGPoint smallHeartPoint = CGPointZero;\n    while (view1 != mutualSuperView) {\n        smallHeartPoint.x += view1.frame.origin.x;\n        smallHeartPoint.y += view1.frame.origin.y;\n        view1 = view1.superview;\n    }\n    // 其次是大桃心(self.BigHeart)\n    UIView *view2 = self.BigHeart;\n    CGPoint bigHeartPoint = CGPointZero;\n    while (view2 != mutualSuperView) {\n        bigHeartPoint.x += view2.frame.origin.x;\n        bigHeartPoint.y += view2.frame.origin.y;\n        view2 = view2.superview;\n    }\n</code></pre>\n<p>既然得到两个桃心的坐标了，实现动画就自然变得简单啦，就不赘述了:)<br>有兴趣的同学可以查看我的<a href=\"https://github.com/objchris/EZHeartForLike\">Github</a>，可以下载在项目中，顺便给我个Like吧<img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahaha\"></p>"},{"title":"Hello World Again","date":"2017-02-17T12:04:10.000Z","typora-copy-images-to":"ipic","_content":"决定给博客的名字起为**童年CHILDHOOD**。\n\n**如童年般纯真，热爱，不朽。**\n\n趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前Hexo的yilia主题。所以换个博客主题，Hello World Again。\n\n<!-- more -->\n\n## 开始捣鼓\n\n不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了hollow主题，并在其上进行修改。\n\n### 主页\n\n主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了yilia，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。\n\nhollow主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。\n\n### Tags\n\n进入标签页面在主页右上角的 *井号* 按钮，标签页面是显示所有标签。\n\n因为暂时不支持站内搜索（还在构思中...），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。\n\n我是通过修改page.ejs来达到目的。\n\n``` html\n<section class=\"article-container\">\n<!-- Back Home -->\n<%- partial('_partial/backhome') %>\n\n<!-- Page Header -->\n<header class=\"intro-header\">\n    <div class=\"container\">\n        <div class=\"row\">\n            <div class=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <div class=\"post-heading\">\n                    <h1>TAGS</h1>\n                </div>\n            </div>\n        </div>\n    </div>\n</header>\n\n<!-- Post Content -->\n<article>\n    <div class=\"container\">\n        <div class=\"row\">\n            <!-- Post Main Content -->\n            <div class=\"post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <% site.tags.each(function(category){ %>\n                    <a class=\"category\" href=\"<%-category.name%>\"><%-category.name%></a>\n                <% }); %>\n            </div>\n        </div>\n    </div>\n</article>\n</section>\n<!-- Back to top -->\n<%- partial('_partial/backtop') %>\n```\n\n修改完page.ejs后，执行`hexo new page \"tags\"`就可以创建tags页了。然后调整格式就可以了。\n\n### About（最近修改中...）\n\n这个页面是自己添加的。\n\n这个页面是最复杂的。首先Hexo只支持`index`,`page`,`post`,`layout`,`archive`这几种自定义页面，所以修改了`page`后作为category页面之后就不能通过修改项目页面模板来添加新的自定义页面了。\n\n但是好在Hexo还是比较人性化的。\n\n除了修改Hexo的模板，有两种方法可以实现自定义页面\n\n1. 先执行`hexo new page \"xxx\"`，在source中出现xxx文件夹，其中有xxx.md，然后在xxx.md前加上layout：false，可以绕过Hexo解析，直接将md中的内容显示出来，这样就可以在md里面写html代码了。详见[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)\n2. 执行`hexo new page \"xxx\"`，同样得到xxx文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建html，css，js，whatever you want。然后记得在博客的主_config.yml中的skip_render项添加xxx/**，就可以了。\n\n### 评论\n\n评论就不加啦，毕竟清清爽爽还是最爱啊。\n\n而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。\n\n厌倦了多说等评论管理平台的话，推荐一个 [Gitment](https://github.com/imsun/gitment)，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在Github的issue里面，很适合托管在第三方服务器空间的博客使用。\n\n有问题在微博等社交平台联系吧。\n\n### 域名和全站HTTPS\n\n域名在万网上购买，实名认证，解析到github page。都是很简单的操作。\n\n在实现全站HTTPS的时候走了不少弯路。主要想实现的有如下几点：\n\n- [x] 全站小绿锁\n\n\n- [x] 怕HTTPS慢，所以上CDN\n\n\n- [ ] ~~自定义SSL证书~~ (无解)\n\n因为博客是托管在Github上的，要强制HTTPS，Coding可以做到，但是没有必要再部署一套到Coding上。所以就想到使用CDN来实现，顺便解决网页的访问速度问题。\n\nCDN有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义SSL证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。\n\n工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的CDN厂商[Cloudflare](https://www.cloudflare.com/)来解析我的域名，Cloudflare和百度云合作，在国内也有CDN服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。\n\n在Cloudflare成功解析后，在Page rules中定义重定向，将`http`301永久重定向到`https`。Cloudflare还可以设置缓存时间，设置用户与DNS、DNS与我们博客的服务器之间是否使用SSL，压缩CSS、JS，永久在线（不定时向服务器请求数据），安全级别（防DDoS）等。\n\n设置完后，看到了久违的小绿锁：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png)\n\n但是，点击文章，可以看到：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png)\n\n访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供`https`的二级域名，但现在已经关闭，要使用`https`需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云COS上，腾讯云COS就有支持SSL的图床测试域名，且提供CDN服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。\n\n所以，Congratulations~😄😄😄🎉🎉🎉~\n\n## 写在后面\n\n总有一些奇思妙想，所以本文仍在不断更新...\n\n博客是在hollow主题的[创作家](https://github.com/zchen9/hexo-theme-hollow)的基础上进行修改的，对此表示最真挚的感谢，开源万岁。\n\n如果要自己写主题，[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)记得多看看。\n\n对于域名购买和Cloudflare、腾讯云的使用，Google可以搜到许多精彩且详细的文章，此处就不再赘述了。\n\n### 对于这次实践的总结：\n\n* 虽然是Node.js小白，但勉强做得出来，因为一行nodejs的代码都没写到\n* HTML、CSS、JS可以做很多事情\n* 需要学习下ejs、stylus，都不是很难\n* 多看看别人的代码，很受启发","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World Again\ndate: 2017-2-17 20:04:10\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n决定给博客的名字起为**童年CHILDHOOD**。\n\n**如童年般纯真，热爱，不朽。**\n\n趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前Hexo的yilia主题。所以换个博客主题，Hello World Again。\n\n<!-- more -->\n\n## 开始捣鼓\n\n不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了hollow主题，并在其上进行修改。\n\n### 主页\n\n主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了yilia，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。\n\nhollow主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。\n\n### Tags\n\n进入标签页面在主页右上角的 *井号* 按钮，标签页面是显示所有标签。\n\n因为暂时不支持站内搜索（还在构思中...），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。\n\n我是通过修改page.ejs来达到目的。\n\n``` html\n<section class=\"article-container\">\n<!-- Back Home -->\n<%- partial('_partial/backhome') %>\n\n<!-- Page Header -->\n<header class=\"intro-header\">\n    <div class=\"container\">\n        <div class=\"row\">\n            <div class=\"col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <div class=\"post-heading\">\n                    <h1>TAGS</h1>\n                </div>\n            </div>\n        </div>\n    </div>\n</header>\n\n<!-- Post Content -->\n<article>\n    <div class=\"container\">\n        <div class=\"row\">\n            <!-- Post Main Content -->\n            <div class=\"post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1\">\n                <% site.tags.each(function(category){ %>\n                    <a class=\"category\" href=\"<%-category.name%>\"><%-category.name%></a>\n                <% }); %>\n            </div>\n        </div>\n    </div>\n</article>\n</section>\n<!-- Back to top -->\n<%- partial('_partial/backtop') %>\n```\n\n修改完page.ejs后，执行`hexo new page \"tags\"`就可以创建tags页了。然后调整格式就可以了。\n\n### About（最近修改中...）\n\n这个页面是自己添加的。\n\n这个页面是最复杂的。首先Hexo只支持`index`,`page`,`post`,`layout`,`archive`这几种自定义页面，所以修改了`page`后作为category页面之后就不能通过修改项目页面模板来添加新的自定义页面了。\n\n但是好在Hexo还是比较人性化的。\n\n除了修改Hexo的模板，有两种方法可以实现自定义页面\n\n1. 先执行`hexo new page \"xxx\"`，在source中出现xxx文件夹，其中有xxx.md，然后在xxx.md前加上layout：false，可以绕过Hexo解析，直接将md中的内容显示出来，这样就可以在md里面写html代码了。详见[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)\n2. 执行`hexo new page \"xxx\"`，同样得到xxx文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建html，css，js，whatever you want。然后记得在博客的主_config.yml中的skip_render项添加xxx/**，就可以了。\n\n### 评论\n\n评论就不加啦，毕竟清清爽爽还是最爱啊。\n\n而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。\n\n厌倦了多说等评论管理平台的话，推荐一个 [Gitment](https://github.com/imsun/gitment)，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在Github的issue里面，很适合托管在第三方服务器空间的博客使用。\n\n有问题在微博等社交平台联系吧。\n\n### 域名和全站HTTPS\n\n域名在万网上购买，实名认证，解析到github page。都是很简单的操作。\n\n在实现全站HTTPS的时候走了不少弯路。主要想实现的有如下几点：\n\n- [x] 全站小绿锁\n\n\n- [x] 怕HTTPS慢，所以上CDN\n\n\n- [ ] ~~自定义SSL证书~~ (无解)\n\n因为博客是托管在Github上的，要强制HTTPS，Coding可以做到，但是没有必要再部署一套到Coding上。所以就想到使用CDN来实现，顺便解决网页的访问速度问题。\n\nCDN有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义SSL证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。\n\n工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的CDN厂商[Cloudflare](https://www.cloudflare.com/)来解析我的域名，Cloudflare和百度云合作，在国内也有CDN服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。\n\n在Cloudflare成功解析后，在Page rules中定义重定向，将`http`301永久重定向到`https`。Cloudflare还可以设置缓存时间，设置用户与DNS、DNS与我们博客的服务器之间是否使用SSL，压缩CSS、JS，永久在线（不定时向服务器请求数据），安全级别（防DDoS）等。\n\n设置完后，看到了久违的小绿锁：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png)\n\n但是，点击文章，可以看到：\n\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png)\n\n访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供`https`的二级域名，但现在已经关闭，要使用`https`需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云COS上，腾讯云COS就有支持SSL的图床测试域名，且提供CDN服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。\n\n所以，Congratulations~😄😄😄🎉🎉🎉~\n\n## 写在后面\n\n总有一些奇思妙想，所以本文仍在不断更新...\n\n博客是在hollow主题的[创作家](https://github.com/zchen9/hexo-theme-hollow)的基础上进行修改的，对此表示最真挚的感谢，开源万岁。\n\n如果要自己写主题，[Hexo文档](https://hexo.io/zh-cn/docs/writing.html)记得多看看。\n\n对于域名购买和Cloudflare、腾讯云的使用，Google可以搜到许多精彩且详细的文章，此处就不再赘述了。\n\n### 对于这次实践的总结：\n\n* 虽然是Node.js小白，但勉强做得出来，因为一行nodejs的代码都没写到\n* HTML、CSS、JS可以做很多事情\n* 需要学习下ejs、stylus，都不是很难\n* 多看看别人的代码，很受启发","slug":"hello-world","published":1,"updated":"2018-03-29T01:44:53.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xoj0005z4y80nj5swkb","content":"<p>决定给博客的名字起为<strong>童年CHILDHOOD</strong>。</p>\n<p><strong>如童年般纯真，热爱，不朽。</strong></p>\n<p>趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前Hexo的yilia主题。所以换个博客主题，Hello World Again。</p>\n<a id=\"more\"></a>\n<h2 id=\"开始捣鼓\"><a href=\"#开始捣鼓\" class=\"headerlink\" title=\"开始捣鼓\"></a>开始捣鼓</h2><p>不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了hollow主题，并在其上进行修改。</p>\n<h3 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h3><p>主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了yilia，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。</p>\n<p>hollow主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。</p>\n<h3 id=\"Tags\"><a href=\"#Tags\" class=\"headerlink\" title=\"Tags\"></a>Tags</h3><p>进入标签页面在主页右上角的 <em>井号</em> 按钮，标签页面是显示所有标签。</p>\n<p>因为暂时不支持站内搜索（还在构思中…），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。</p>\n<p>我是通过修改page.ejs来达到目的。</p>\n<pre><code class=\"html\">&lt;section class=&quot;article-container&quot;&gt;\n&lt;!-- Back Home --&gt;\n&lt;%- partial(&#39;_partial/backhome&#39;) %&gt;\n\n&lt;!-- Page Header --&gt;\n&lt;header class=&quot;intro-header&quot;&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;div class=&quot;post-heading&quot;&gt;\n                    &lt;h1&gt;TAGS&lt;/h1&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/header&gt;\n\n&lt;!-- Post Content --&gt;\n&lt;article&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;!-- Post Main Content --&gt;\n            &lt;div class=&quot;post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;% site.tags.each(function(category){ %&gt;\n                    &lt;a class=&quot;category&quot; href=&quot;&lt;%-category.name%&gt;&quot;&gt;&lt;%-category.name%&gt;&lt;/a&gt;\n                &lt;% }); %&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/article&gt;\n&lt;/section&gt;\n&lt;!-- Back to top --&gt;\n&lt;%- partial(&#39;_partial/backtop&#39;) %&gt;\n</code></pre>\n<p>修改完page.ejs后，执行<code>hexo new page &quot;tags&quot;</code>就可以创建tags页了。然后调整格式就可以了。</p>\n<h3 id=\"About（最近修改中…）\"><a href=\"#About（最近修改中…）\" class=\"headerlink\" title=\"About（最近修改中…）\"></a>About（最近修改中…）</h3><p>这个页面是自己添加的。</p>\n<p>这个页面是最复杂的。首先Hexo只支持<code>index</code>,<code>page</code>,<code>post</code>,<code>layout</code>,<code>archive</code>这几种自定义页面，所以修改了<code>page</code>后作为category页面之后就不能通过修改项目页面模板来添加新的自定义页面了。</p>\n<p>但是好在Hexo还是比较人性化的。</p>\n<p>除了修改Hexo的模板，有两种方法可以实现自定义页面</p>\n<ol>\n<li>先执行<code>hexo new page &quot;xxx&quot;</code>，在source中出现xxx文件夹，其中有xxx.md，然后在xxx.md前加上layout：false，可以绕过Hexo解析，直接将md中的内容显示出来，这样就可以在md里面写html代码了。详见<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">Hexo文档</a></li>\n<li>执行<code>hexo new page &quot;xxx&quot;</code>，同样得到xxx文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建html，css，js，whatever you want。然后记得在博客的主_config.yml中的skip_render项添加xxx/**，就可以了。</li>\n</ol>\n<h3 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h3><p>评论就不加啦，毕竟清清爽爽还是最爱啊。</p>\n<p>而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。</p>\n<p>厌倦了多说等评论管理平台的话，推荐一个 <a href=\"https://github.com/imsun/gitment\" target=\"_blank\" rel=\"external\">Gitment</a>，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在Github的issue里面，很适合托管在第三方服务器空间的博客使用。</p>\n<p>有问题在微博等社交平台联系吧。</p>\n<h3 id=\"域名和全站HTTPS\"><a href=\"#域名和全站HTTPS\" class=\"headerlink\" title=\"域名和全站HTTPS\"></a>域名和全站HTTPS</h3><p>域名在万网上购买，实名认证，解析到github page。都是很简单的操作。</p>\n<p>在实现全站HTTPS的时候走了不少弯路。主要想实现的有如下几点：</p>\n<ul>\n<li>[x] 全站小绿锁</li>\n</ul>\n<ul>\n<li>[x] 怕HTTPS慢，所以上CDN</li>\n</ul>\n<ul>\n<li>[ ] <del>自定义SSL证书</del> (无解)</li>\n</ul>\n<p>因为博客是托管在Github上的，要强制HTTPS，Coding可以做到，但是没有必要再部署一套到Coding上。所以就想到使用CDN来实现，顺便解决网页的访问速度问题。</p>\n<p>CDN有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义SSL证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。</p>\n<p>工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的CDN厂商<a href=\"https://www.cloudflare.com/\" target=\"_blank\" rel=\"external\">Cloudflare</a>来解析我的域名，Cloudflare和百度云合作，在国内也有CDN服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。</p>\n<p>在Cloudflare成功解析后，在Page rules中定义重定向，将<code>http</code>301永久重定向到<code>https</code>。Cloudflare还可以设置缓存时间，设置用户与DNS、DNS与我们博客的服务器之间是否使用SSL，压缩CSS、JS，永久在线（不定时向服务器请求数据），安全级别（防DDoS）等。</p>\n<p>设置完后，看到了久违的小绿锁：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png\" alt=\"\"></p>\n<p>但是，点击文章，可以看到：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png\" alt=\"\"></p>\n<p>访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供<code>https</code>的二级域名，但现在已经关闭，要使用<code>https</code>需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云COS上，腾讯云COS就有支持SSL的图床测试域名，且提供CDN服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。</p>\n<p>所以，Congratulations~😄😄😄🎉🎉🎉~</p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>总有一些奇思妙想，所以本文仍在不断更新…</p>\n<p>博客是在hollow主题的<a href=\"https://github.com/zchen9/hexo-theme-hollow\" target=\"_blank\" rel=\"external\">创作家</a>的基础上进行修改的，对此表示最真挚的感谢，开源万岁。</p>\n<p>如果要自己写主题，<a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">Hexo文档</a>记得多看看。</p>\n<p>对于域名购买和Cloudflare、腾讯云的使用，Google可以搜到许多精彩且详细的文章，此处就不再赘述了。</p>\n<h3 id=\"对于这次实践的总结：\"><a href=\"#对于这次实践的总结：\" class=\"headerlink\" title=\"对于这次实践的总结：\"></a>对于这次实践的总结：</h3><ul>\n<li>虽然是Node.js小白，但勉强做得出来，因为一行nodejs的代码都没写到</li>\n<li>HTML、CSS、JS可以做很多事情</li>\n<li>需要学习下ejs、stylus，都不是很难</li>\n<li>多看看别人的代码，很受启发</li>\n</ul>\n","excerpt":"<p>决定给博客的名字起为<strong>童年CHILDHOOD</strong>。</p>\n<p><strong>如童年般纯真，热爱，不朽。</strong></p>\n<p>趁着最近没有动力看书，又不想脑袋生锈，又看腻了之前Hexo的yilia主题。所以换个博客主题，Hello World Again。</p>","more":"<h2 id=\"开始捣鼓\"><a href=\"#开始捣鼓\" class=\"headerlink\" title=\"开始捣鼓\"></a>开始捣鼓</h2><p>不是前端er要自己写个主题出来还真不是简单的事情。所以借鉴了hollow主题，并在其上进行修改。</p>\n<h3 id=\"主页\"><a href=\"#主页\" class=\"headerlink\" title=\"主页\"></a>主页</h3><p>主页大致上没有做太多的修改，因为一开始就是看上这种简简单单的，没有太多复杂成分的排版。厌倦了yilia，第一是：不想要左右版式的页面，显得左侧的菜单栏有点喧宾夺主。第二是：总把人脸留在左边显眼的位置，纯粹的不喜欢。</p>\n<p>hollow主题只是包含了主页，也就是显示文章序列和文章详情。其他的都没有。</p>\n<h3 id=\"Tags\"><a href=\"#Tags\" class=\"headerlink\" title=\"Tags\"></a>Tags</h3><p>进入标签页面在主页右上角的 <em>井号</em> 按钮，标签页面是显示所有标签。</p>\n<p>因为暂时不支持站内搜索（还在构思中…），如果要找某一篇文章需要一页页地翻，感觉会很繁琐。所以建立了个标签页面。</p>\n<p>我是通过修改page.ejs来达到目的。</p>\n<pre><code class=\"html\">&lt;section class=&quot;article-container&quot;&gt;\n&lt;!-- Back Home --&gt;\n&lt;%- partial(&#39;_partial/backhome&#39;) %&gt;\n\n&lt;!-- Page Header --&gt;\n&lt;header class=&quot;intro-header&quot;&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;div class=&quot;col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;div class=&quot;post-heading&quot;&gt;\n                    &lt;h1&gt;TAGS&lt;/h1&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/header&gt;\n\n&lt;!-- Post Content --&gt;\n&lt;article&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;row&quot;&gt;\n            &lt;!-- Post Main Content --&gt;\n            &lt;div class=&quot;post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1&quot;&gt;\n                &lt;% site.tags.each(function(category){ %&gt;\n                    &lt;a class=&quot;category&quot; href=&quot;&lt;%-category.name%&gt;&quot;&gt;&lt;%-category.name%&gt;&lt;/a&gt;\n                &lt;% }); %&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/article&gt;\n&lt;/section&gt;\n&lt;!-- Back to top --&gt;\n&lt;%- partial(&#39;_partial/backtop&#39;) %&gt;\n</code></pre>\n<p>修改完page.ejs后，执行<code>hexo new page &quot;tags&quot;</code>就可以创建tags页了。然后调整格式就可以了。</p>\n<h3 id=\"About（最近修改中…）\"><a href=\"#About（最近修改中…）\" class=\"headerlink\" title=\"About（最近修改中…）\"></a>About（最近修改中…）</h3><p>这个页面是自己添加的。</p>\n<p>这个页面是最复杂的。首先Hexo只支持<code>index</code>,<code>page</code>,<code>post</code>,<code>layout</code>,<code>archive</code>这几种自定义页面，所以修改了<code>page</code>后作为category页面之后就不能通过修改项目页面模板来添加新的自定义页面了。</p>\n<p>但是好在Hexo还是比较人性化的。</p>\n<p>除了修改Hexo的模板，有两种方法可以实现自定义页面</p>\n<ol>\n<li>先执行<code>hexo new page &quot;xxx&quot;</code>，在source中出现xxx文件夹，其中有xxx.md，然后在xxx.md前加上layout：false，可以绕过Hexo解析，直接将md中的内容显示出来，这样就可以在md里面写html代码了。详见<a href=\"https://hexo.io/zh-cn/docs/writing.html\">Hexo文档</a></li>\n<li>执行<code>hexo new page &quot;xxx&quot;</code>，同样得到xxx文件夹，你可以将这个文件夹当作一个项目的根目录，然后在其中尽情创建html，css，js，whatever you want。然后记得在博客的主_config.yml中的skip_render项添加xxx/**，就可以了。</li>\n</ol>\n<h3 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h3><p>评论就不加啦，毕竟清清爽爽还是最爱啊。</p>\n<p>而且好像也没有很多人来过这个博客，等以后有需要再加上评论吧。</p>\n<p>厌倦了多说等评论管理平台的话，推荐一个 <a href=\"https://github.com/imsun/gitment\">Gitment</a>，观望了很久还是觉得这个比较简洁，不需要依赖其他第三方平台，它是将评论放在Github的issue里面，很适合托管在第三方服务器空间的博客使用。</p>\n<p>有问题在微博等社交平台联系吧。</p>\n<h3 id=\"域名和全站HTTPS\"><a href=\"#域名和全站HTTPS\" class=\"headerlink\" title=\"域名和全站HTTPS\"></a>域名和全站HTTPS</h3><p>域名在万网上购买，实名认证，解析到github page。都是很简单的操作。</p>\n<p>在实现全站HTTPS的时候走了不少弯路。主要想实现的有如下几点：</p>\n<ul>\n<li>[x] 全站小绿锁</li>\n</ul>\n<ul>\n<li>[x] 怕HTTPS慢，所以上CDN</li>\n</ul>\n<ul>\n<li>[ ] <del>自定义SSL证书</del> (无解)</li>\n</ul>\n<p>因为博客是托管在Github上的，要强制HTTPS，Coding可以做到，但是没有必要再部署一套到Coding上。所以就想到使用CDN来实现，顺便解决网页的访问速度问题。</p>\n<p>CDN有国内几家云服务厂商有免费流量，又拍云、腾讯云等。都支持上传自定义SSL证书。但我的博客没有国内的服务器空间，自然没有私钥，无法申请证书。</p>\n<p>工信部的备案系统虽然减少了很多黑网站，但也让我们这些只有域名没有空间的人徒增了许多麻烦。所以最后选了国外的CDN厂商<a href=\"https://www.cloudflare.com/\">Cloudflare</a>来解析我的域名，Cloudflare和百度云合作，在国内也有CDN服务器，先试试速度如何，且免费版本基本能够满足要求，配置也不难。</p>\n<p>在Cloudflare成功解析后，在Page rules中定义重定向，将<code>http</code>301永久重定向到<code>https</code>。Cloudflare还可以设置缓存时间，设置用户与DNS、DNS与我们博客的服务器之间是否使用SSL，压缩CSS、JS，永久在线（不定时向服务器请求数据），安全级别（防DDoS）等。</p>\n<p>设置完后，看到了久违的小绿锁：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/rwfkq.png\" alt=\"\"></p>\n<p>但是，点击文章，可以看到：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/dw1rg.png\" alt=\"\"></p>\n<p>访问时就有『并非完成安全』的提示，这涉及一个小问题，就是图床，我的图片资源是托管在七牛云上的，之前七牛云还提供<code>https</code>的二级域名，但现在已经关闭，要使用<code>https</code>需要自定义域名，这又回到上面所说的备案问题。纠结之余，将七牛云迁移到腾讯云COS上，腾讯云COS就有支持SSL的图床测试域名，且提供CDN服务，同样是每月免费空间，免费流量，对于我这个小站来说，足够了。</p>\n<p>所以，Congratulations~😄😄😄🎉🎉🎉~</p>\n<h2 id=\"写在后面\"><a href=\"#写在后面\" class=\"headerlink\" title=\"写在后面\"></a>写在后面</h2><p>总有一些奇思妙想，所以本文仍在不断更新…</p>\n<p>博客是在hollow主题的<a href=\"https://github.com/zchen9/hexo-theme-hollow\">创作家</a>的基础上进行修改的，对此表示最真挚的感谢，开源万岁。</p>\n<p>如果要自己写主题，<a href=\"https://hexo.io/zh-cn/docs/writing.html\">Hexo文档</a>记得多看看。</p>\n<p>对于域名购买和Cloudflare、腾讯云的使用，Google可以搜到许多精彩且详细的文章，此处就不再赘述了。</p>\n<h3 id=\"对于这次实践的总结：\"><a href=\"#对于这次实践的总结：\" class=\"headerlink\" title=\"对于这次实践的总结：\"></a>对于这次实践的总结：</h3><ul>\n<li>虽然是Node.js小白，但勉强做得出来，因为一行nodejs的代码都没写到</li>\n<li>HTML、CSS、JS可以做很多事情</li>\n<li>需要学习下ejs、stylus，都不是很难</li>\n<li>多看看别人的代码，很受启发</li>\n</ul>"},{"title":"iOS下重要的多线程GCD","date":"2017-03-23T04:15:06.000Z","typora-copy-images-to":"ipic","_content":"\n**多线程**是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP的被使用率和被使用频率也会更加高。    \n此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。\n\n<!--more-->\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n## 一些概念\n\n### 串行（Serial）与 并发（Concurrent）\n- 任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。\n- 任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。\n\n### 同步（Synchronous）与 异步 （Asynchronous）\n- 同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 \n- 异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。\n\n### 临界区（Critical Section）\n一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。\n\n### 死锁（Deadlock）    \n停止等待事情的线程会导致多个线程相互维持等待，即死锁。    \n两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。\n\n### 线程安全（Thread Safe）\n线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：[helpful and somewhat chilling list](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html)\n\n### 上下文切换（Context Switch）\n一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。\n\n### 并发（Concurrency）与 并行 （Parallelism）\n并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。\n并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： \n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n\n## 队列（queue）\n\n|  队列  |   线程   |\n| :--: | :----: |\n|  串行  | 当前线程运行 |\n|  并发  | 另开线程运行 |\n\n### 串行队列（Serial Queues）\n---\n![Serial-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_SERIAL);`    \n串行队列最典型的是**main queue**：主线程所对应的queue，主要用于更新UI。\n\n\n### 并发队列（Concurrent Queues）\n---\n![Concurrent-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_CONCURRENT);`    \n除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）    \n`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)`\n\n\n## GCD语法和适用范围\n\n### dispatch_sync\n\n![dispatch_sync_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif)\n- 串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    \n- 并发队列：√\n\n\n### dispatch_async\n\n![dispatch_async_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif)    \n- 串行队列：√    \n- 并发队列：√\n\n\n### dispatch barriers\n\n![Dispatch-Barrier](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png)    \n正如上图所示：使用dispatch\\_barriers\\_sync或dispatch\\_barries\\_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    \n- 串行队列：完全没必要....\n- 并发队列：√\n\n#### read and write 读写问题\n\n```\n- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n```\n```\n- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n```\n\n### dispatch_after\n\ndispatch\\_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch\\_after.而且正如下文将说到的：dispatch\\_after最好只在main queue中使用。\n```\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@\"Add photos with faces to Googlyify them!\"]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n}); \n```\n**只能用于Main Queue！！！！！！！！！！！！！！**\n\n### dispatch_once\n\n```\nstatic PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager->_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager; \n```\n\n### dispatch_groups\n\n```\ndispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n}); \n```\ngroup中的任务不一定在同一个queue里面。串行队列和并发队列都可用。\n- 串行队列：√    \n- 并发队列：√\n\n### dispatch_apply\n\n```\ndispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n```\n- 串行队列：没什么必要....串行队列使用跟普通的循环没有区别。\n- 并发队列：√\n\n\n## 参考文献\n\n[Grand Central Dispatch In-Depth: Part 1/2](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)\n\n[Grand Central Dispatch In-Depth: Part 2/2](https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2)","source":"_posts/iOS下重要的多线程GCD.md","raw":"---\ntitle: iOS下重要的多线程GCD\ndate: 2017-03-23 12:15:06\ntags: \n- Thread\ntypora-copy-images-to: ipic\n---\n\n**多线程**是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP的被使用率和被使用频率也会更加高。    \n此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。\n\n<!--more-->\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n## 一些概念\n\n### 串行（Serial）与 并发（Concurrent）\n- 任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。\n- 任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。\n\n### 同步（Synchronous）与 异步 （Asynchronous）\n- 同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 \n- 异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。\n\n同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。\n\n### 临界区（Critical Section）\n一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。\n\n### 死锁（Deadlock）    \n停止等待事情的线程会导致多个线程相互维持等待，即死锁。    \n两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。\n\n### 线程安全（Thread Safe）\n线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：[helpful and somewhat chilling list](https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html)\n\n### 上下文切换（Context Switch）\n一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。\n\n### 并发（Concurrency）与 并行 （Parallelism）\n并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。\n并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： \n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n\n## 队列（queue）\n\n|  队列  |   线程   |\n| :--: | :----: |\n|  串行  | 当前线程运行 |\n|  并发  | 另开线程运行 |\n\n### 串行队列（Serial Queues）\n---\n![Serial-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_SERIAL);`    \n串行队列最典型的是**main queue**：主线程所对应的queue，主要用于更新UI。\n\n\n### 并发队列（Concurrent Queues）\n---\n![Concurrent-Queue](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png)\n`dispatch_queue_create(\"com.selander.GooglyPuff.photoQueue\",DISPATCH_QUEUE_CONCURRENT);`    \n除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）    \n`dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)`\n\n\n## GCD语法和适用范围\n\n### dispatch_sync\n\n![dispatch_sync_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif)\n- 串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    \n- 并发队列：√\n\n\n### dispatch_async\n\n![dispatch_async_in_action](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif)    \n- 串行队列：√    \n- 并发队列：√\n\n\n### dispatch barriers\n\n![Dispatch-Barrier](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png)    \n正如上图所示：使用dispatch\\_barriers\\_sync或dispatch\\_barries\\_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    \n- 串行队列：完全没必要....\n- 并发队列：√\n\n#### read and write 读写问题\n\n```\n- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n```\n```\n- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n```\n\n### dispatch_after\n\ndispatch\\_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch\\_after.而且正如下文将说到的：dispatch\\_after最好只在main queue中使用。\n```\ndouble delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@\"Add photos with faces to Googlyify them!\"]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n}); \n```\n**只能用于Main Queue！！！！！！！！！！！！！！**\n\n### dispatch_once\n\n```\nstatic PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager->_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager; \n```\n\n### dispatch_groups\n\n```\ndispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n}); \n```\ngroup中的任务不一定在同一个queue里面。串行队列和并发队列都可用。\n- 串行队列：√    \n- 并发队列：√\n\n### dispatch_apply\n\n```\ndispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n```\n- 串行队列：没什么必要....串行队列使用跟普通的循环没有区别。\n- 并发队列：√\n\n\n## 参考文献\n\n[Grand Central Dispatch In-Depth: Part 1/2](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)\n\n[Grand Central Dispatch In-Depth: Part 2/2](https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2)","slug":"iOS下重要的多线程GCD","published":1,"updated":"2018-03-14T09:11:47.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xok0006z4y8tpawopwz","content":"<p><strong>多线程</strong>是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP的被使用率和被使用频率也会更加高。<br>此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"串行（Serial）与-并发（Concurrent）\"><a href=\"#串行（Serial）与-并发（Concurrent）\" class=\"headerlink\" title=\"串行（Serial）与 并发（Concurrent）\"></a>串行（Serial）与 并发（Concurrent）</h3><ul>\n<li>任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。</li>\n<li>任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。</li>\n</ul>\n<h3 id=\"同步（Synchronous）与-异步-（Asynchronous）\"><a href=\"#同步（Synchronous）与-异步-（Asynchronous）\" class=\"headerlink\" title=\"同步（Synchronous）与 异步 （Asynchronous）\"></a>同步（Synchronous）与 异步 （Asynchronous）</h3><ul>\n<li>同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 </li>\n<li>异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。</li>\n</ul>\n<p>同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。</p>\n<h3 id=\"临界区（Critical-Section）\"><a href=\"#临界区（Critical-Section）\" class=\"headerlink\" title=\"临界区（Critical Section）\"></a>临界区（Critical Section）</h3><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。</p>\n<h3 id=\"死锁（Deadlock）\"><a href=\"#死锁（Deadlock）\" class=\"headerlink\" title=\"死锁（Deadlock）\"></a>死锁（Deadlock）</h3><p>停止等待事情的线程会导致多个线程相互维持等待，即死锁。<br>两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>\n<h3 id=\"线程安全（Thread-Safe）\"><a href=\"#线程安全（Thread-Safe）\" class=\"headerlink\" title=\"线程安全（Thread Safe）\"></a>线程安全（Thread Safe）</h3><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：<a href=\"https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html\" target=\"_blank\" rel=\"external\">helpful and somewhat chilling list</a></p>\n<h3 id=\"上下文切换（Context-Switch）\"><a href=\"#上下文切换（Context-Switch）\" class=\"headerlink\" title=\"上下文切换（Context Switch）\"></a>上下文切换（Context Switch）</h3><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>\n<h3 id=\"并发（Concurrency）与-并行-（Parallelism）\"><a href=\"#并发（Concurrency）与-并行-（Parallelism）\" class=\"headerlink\" title=\"并发（Concurrency）与 并行 （Parallelism）\"></a>并发（Concurrency）与 并行 （Parallelism）</h3><p>并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"队列（queue）\"><a href=\"#队列（queue）\" class=\"headerlink\" title=\"队列（queue）\"></a>队列（queue）</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">队列</th>\n<th style=\"text-align:center\">线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">串行</td>\n<td style=\"text-align:center\">当前线程运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">并发</td>\n<td style=\"text-align:center\">另开线程运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"串行队列（Serial-Queues）\"><a href=\"#串行队列（Serial-Queues）\" class=\"headerlink\" title=\"串行队列（Serial Queues）\"></a>串行队列（Serial Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png\" alt=\"Serial-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_SERIAL);</code><br>串行队列最典型的是<strong>main queue</strong>：主线程所对应的queue，主要用于更新UI。</p>\n<h3 id=\"并发队列（Concurrent-Queues）\"><a href=\"#并发队列（Concurrent-Queues）\" class=\"headerlink\" title=\"并发队列（Concurrent Queues）\"></a>并发队列（Concurrent Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png\" alt=\"Concurrent-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code><br>除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）<br><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)</code></p>\n<h2 id=\"GCD语法和适用范围\"><a href=\"#GCD语法和适用范围\" class=\"headerlink\" title=\"GCD语法和适用范围\"></a>GCD语法和适用范围</h2><h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif\" alt=\"dispatch_sync_in_action\"></p>\n<ul>\n<li>串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif\" alt=\"dispatch_async_in_action\">    </p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-barriers\"><a href=\"#dispatch-barriers\" class=\"headerlink\" title=\"dispatch barriers\"></a>dispatch barriers</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png\" alt=\"Dispatch-Barrier\"><br>正如上图所示：使用dispatch_barriers_sync或dispatch_barries_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    </p>\n<ul>\n<li>串行队列：完全没必要….</li>\n<li>并发队列：√</li>\n</ul>\n<h4 id=\"read-and-write-读写问题\"><a href=\"#read-and-write-读写问题\" class=\"headerlink\" title=\"read and write 读写问题\"></a>read and write 读写问题</h4><pre><code>- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n</code></pre><pre><code>- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n</code></pre><h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>dispatch_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch_after.而且正如下文将说到的：dispatch_after最好只在main queue中使用。</p>\n<pre><code>double delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n});\n</code></pre><p><strong>只能用于Main Queue！！！！！！！！！！！！！！</strong></p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><pre><code>static PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&amp;onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager;\n</code></pre><h3 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h3><pre><code>dispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n});\n</code></pre><p>group中的任务不一定在同一个queue里面。串行队列和并发队列都可用。</p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><pre><code>dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n</code></pre><ul>\n<li>串行队列：没什么必要….串行队列使用跟普通的循环没有区别。</li>\n<li>并发队列：√</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1\" target=\"_blank\" rel=\"external\">Grand Central Dispatch In-Depth: Part 1/2</a></p>\n<p><a href=\"https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2\" target=\"_blank\" rel=\"external\">Grand Central Dispatch In-Depth: Part 2/2</a></p>\n","excerpt":"<p><strong>多线程</strong>是每个系统都必须具备的功能，带给用户更多的便利，伴随着友好度的提升，APP的被使用率和被使用频率也会更加高。<br>此篇笔记参考了网络上一些好文，学习到了很多。在Ray Wenderlich上摘录了一些队列的常用情景，希望自己得到提高的同时分享给大家。</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><h3 id=\"串行（Serial）与-并发（Concurrent）\"><a href=\"#串行（Serial）与-并发（Concurrent）\" class=\"headerlink\" title=\"串行（Serial）与 并发（Concurrent）\"></a>串行（Serial）与 并发（Concurrent）</h3><ul>\n<li>任务串行，意味着在同一时间，有且只有一个任务被执行，即一个任务执行完毕之后再执行下一个任务。</li>\n<li>任务并发，意味着对于用户体验，在同一时间，有多个任务被执行。</li>\n</ul>\n<h3 id=\"同步（Synchronous）与-异步-（Asynchronous）\"><a href=\"#同步（Synchronous）与-异步-（Asynchronous）\" class=\"headerlink\" title=\"同步（Synchronous）与 异步 （Asynchronous）\"></a>同步（Synchronous）与 异步 （Asynchronous）</h3><ul>\n<li>同步派发(sync)会尽可能地在当前线程派发任务。但如果在其他队列往主队列同步派发，任务会在主线程执行。 </li>\n<li>异步派发(async)也不绝对会另开线程。例如在主线程异步派发到主线程，派发依旧是异步的，任务也会在主线程执行。</li>\n</ul>\n<p>同步异步的重要区别在于派发方法是否需要等待 block 完成后才能返回。</p>\n<h3 id=\"临界区（Critical-Section）\"><a href=\"#临界区（Critical-Section）\" class=\"headerlink\" title=\"临界区（Critical Section）\"></a>临界区（Critical Section）</h3><p>一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。</p>\n<h3 id=\"死锁（Deadlock）\"><a href=\"#死锁（Deadlock）\" class=\"headerlink\" title=\"死锁（Deadlock）\"></a>死锁（Deadlock）</h3><p>停止等待事情的线程会导致多个线程相互维持等待，即死锁。<br>两个（或更多）线程卡住了，等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>\n<h3 id=\"线程安全（Thread-Safe）\"><a href=\"#线程安全（Thread-Safe）\" class=\"headerlink\" title=\"线程安全（Thread Safe）\"></a>线程安全（Thread Safe）</h3><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是NSDictionary。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary就不是线程安全的，应该保证一次只能有一个线程访问它。更多请看：<a href=\"https://developer.apple.com/library/mac/documentation/cocoa/conceptual/multithreading/ThreadSafetySummary/ThreadSafetySummary.html\">helpful and somewhat chilling list</a></p>\n<h3 id=\"上下文切换（Context-Switch）\"><a href=\"#上下文切换（Context-Switch）\" class=\"headerlink\" title=\"上下文切换（Context Switch）\"></a>上下文切换（Context Switch）</h3><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>\n<h3 id=\"并发（Concurrency）与-并行-（Parallelism）\"><a href=\"#并发（Concurrency）与-并行-（Parallelism）\" class=\"headerlink\" title=\"并发（Concurrency）与 并行 （Parallelism）\"></a>并发（Concurrency）与 并行 （Parallelism）</h3><p>并行要求并发，但并发不能保证并行，就计算机操作系统来说，开启线程是很耗性能的，也就是说，事实上，在某次并发处理任务中，开启的线程是有上限的，如果上限为2，即每次开启的新线程为2，那么是有可能出现并发却不并行的情况。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<h2 id=\"队列（queue）\"><a href=\"#队列（queue）\" class=\"headerlink\" title=\"队列（queue）\"></a>队列（queue）</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">队列</th>\n<th style=\"text-align:center\">线程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">串行</td>\n<td style=\"text-align:center\">当前线程运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">并发</td>\n<td style=\"text-align:center\">另开线程运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"串行队列（Serial-Queues）\"><a href=\"#串行队列（Serial-Queues）\" class=\"headerlink\" title=\"串行队列（Serial Queues）\"></a>串行队列（Serial Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/26uxx.png\" alt=\"Serial-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_SERIAL);</code><br>串行队列最典型的是<strong>main queue</strong>：主线程所对应的queue，主要用于更新UI。</p>\n<h3 id=\"并发队列（Concurrent-Queues）\"><a href=\"#并发队列（Concurrent-Queues）\" class=\"headerlink\" title=\"并发队列（Concurrent Queues）\"></a>并发队列（Concurrent Queues）</h3><hr>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/ggsfu.png\" alt=\"Concurrent-Queue\"><br><code>dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code><br>除了通过DISPATCH_QUEUE_CONCURRENT创建的queue外，系统提供了Global Dispatch Queues：分别有四种优先级（background, low, default, high）<br><code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)</code></p>\n<h2 id=\"GCD语法和适用范围\"><a href=\"#GCD语法和适用范围\" class=\"headerlink\" title=\"GCD语法和适用范围\"></a>GCD语法和适用范围</h2><h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/wx3ao.gif\" alt=\"dispatch_sync_in_action\"></p>\n<ul>\n<li>串行队列：Caution！！需要注意不能往本队列派发任务，否则会造成死锁。    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-async\"><a href=\"#dispatch-async\" class=\"headerlink\" title=\"dispatch_async\"></a>dispatch_async</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/zst1c.gif\" alt=\"dispatch_async_in_action\">    </p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-barriers\"><a href=\"#dispatch-barriers\" class=\"headerlink\" title=\"dispatch barriers\"></a>dispatch barriers</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/b3668.png\" alt=\"Dispatch-Barrier\"><br>正如上图所示：使用dispatch_barriers_sync或dispatch_barries_async会在你创建的队列中插入Barrier Block，而这个Block被执行时确保当前仅有一个任务在执行中。这就很好地在并发队列中保持一段暂时串行的任务执行顺序。这很适合于：如对某一个数组或存储结构添加数据时，就可以将该任务作为Barrier Block插入到队列中，即保证了该数组的原子性，防止脏数据的产生。    </p>\n<ul>\n<li>串行队列：完全没必要….</li>\n<li>并发队列：√</li>\n</ul>\n<h4 id=\"read-and-write-读写问题\"><a href=\"#read-and-write-读写问题\" class=\"headerlink\" title=\"read and write 读写问题\"></a>read and write 读写问题</h4><pre><code>- (void)addPhoto:(Photo *)photo \n{ \nif (photo) { // 1 \ndispatch_barrier_async(self.concurrentPhotoQueue, ^{ // 2 \n[_photosArray addObject:photo]; // 3 \ndispatch_async(dispatch_get_main_queue(), ^{ // 4 \n[self postContentAddedNotification]; \n}); \n}); \n} \n}\n</code></pre><pre><code>- (NSArray *)photos \n{ \n__block NSArray *array; // 1 \ndispatch_sync(self.concurrentPhotoQueue, ^{ // 2 \narray = [NSArray arrayWithArray:_photosArray]; // 3 \n}); \nreturn array; \n}\n</code></pre><h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>dispatch_after有一个非常使用的情景：当你需要在APP启动时让启动图片再显示就一些，让APP有更充足的时间准备一些初始化的工作时，就使用dispatch_after.而且正如下文将说到的：dispatch_after最好只在main queue中使用。</p>\n<pre><code>double delayInSeconds = 1.0; \ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 \ndispatch_after(popTime, dispatch_get_main_queue(), ^(void){ // 2 \nif (!count) { \n[self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;]; \n} else { \n[self.navigationItem setPrompt:nil]; \n} \n});\n</code></pre><p><strong>只能用于Main Queue！！！！！！！！！！！！！！</strong></p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><pre><code>static PhotoManager *sharedPhotoManager = nil; \nstatic dispatch_once_t onceToken; \ndispatch_once(&amp;onceToken, ^{ \nsharedPhotoManager = [[PhotoManager alloc] init]; \nsharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; \n}); \nreturn sharedPhotoManager;\n</code></pre><h3 id=\"dispatch-groups\"><a href=\"#dispatch-groups\" class=\"headerlink\" title=\"dispatch_groups\"></a>dispatch_groups</h3><pre><code>dispatch_group_t downloadGroup = dispatch_group_create(); \n//任务开始之前要执行下面的enter函数 \ndispatch_group_enter(downloadGroup); \n//在任务结束的时候要执行下面的leave函数 \ndispatch_group_leave(downloadGroup); \ndispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);//阻塞进程等待所有任务结束 \n// or 交给group通知 \ndispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ // 4 \nif (completionBlock) { \ncompletionBlock(error); \n} \n});\n</code></pre><p>group中的任务不一定在同一个queue里面。串行队列和并发队列都可用。</p>\n<ul>\n<li>串行队列：√    </li>\n<li>并发队列：√</li>\n</ul>\n<h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><pre><code>dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) { \n}//就像for循环一样\n</code></pre><ul>\n<li>串行队列：没什么必要….串行队列使用跟普通的循环没有区别。</li>\n<li>并发队列：√</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1\">Grand Central Dispatch In-Depth: Part 1/2</a></p>\n<p><a href=\"https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2\">Grand Central Dispatch In-Depth: Part 2/2</a></p>"},{"title":"使用makefile创建静态库","thumbnail":"http://7xs4ed.com1.z0.glb.clouddn.com/Dubai_paohui.jpg","date":"2017-08-08T14:17:57.000Z","id":"42F1A99632F0B88D","_content":"\n最近工作上需要将Win上的一个C库移植到iOS上以支持业务的开展，修改代码后需要编译成静态库供iOS使用，为了使用Windows或Linux的同事在修改完代码后也能编译出静态库而无需再搬到Mac上操作，学习了一下makefile。    \n\n<!--more-->\n\n说来惭愧，自己的C/C++水平还没有到达很高的水平，最开始想到的最简单的方式就是创建`Cocoa Touch Static Library`项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    \n\n但是为了让其他同事更快捷地完成工作，学习了如何使用makefile来编译静态库。\n\n本文只是皮毛，主要是在此次工作中的一些历程。     \n\n## 静态库特点\n\n> - 静态库对函数库的链接是放在编译时期完成的。\n> - 程序在运行时与函数库再无关系，移植方便。\n> - 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n> - 更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。\n\n留下疑问：是否可以理解为：只需要其他库的头文件？\n\n## makefile\n\nmakefile本身只是一个文件，用来辅助make命令执行时，告诉make命令怎么去编译和链接程序。    \n\n那编译和链接的规则是：\n\n> - 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。\n> - 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。\n> - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。\n\nGoogle可以搜索到很多makefile的好文章，这里简略介绍一下：\n\n### 基本语句\n\n```\ntarget : prerequisites\n\tcommand\n```\n\n- target : 编译或链接最终得到的目标文件，例如.o结尾的中间文件、由.o文件链接而成的Win下的可执行文件，.o文件打包而成的静态库文件\n- prerequisites : 依赖，也就是编译成.o的.c、.cpp、.m和.h，链接成动态库、静态库、可执行文件的.o\n- command : 命令，即如何将上述的依赖编译或链接成我们要的target，需要注意的是，command前必须要有一个制表符(tab)，不能是一连串的空格，也不能缺失。\n\n\n\n\n\n#### Phony Target\n\nPHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    \n\n像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行`make clean`，这里的clean就是makefile中被定义的Phony Target。下面例子会说到。    \n\n一个makefile只能有一个总的Target(编译链接得到我们最终需要的文件)，如果需要多个Target，可以使用Phony Target来实现。当然，上述说到的除编译链接之外的操作用Phony Target也是很好的选择。\n\n\n\n### 变量\n\n像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过`${变量}`使用，例如：\n\n```\nDEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n```\n\n\n\n### 文件名及使用\n\n当然，既然叫makefile，文件名最好就叫makefile啦，Makefile也是可以的，但是是在makefile不存在的时候，make命令才会去使用。\n\n如果再不喜欢，文件名写成`chris`也可以，只是make的时候加上-f和文件名就好了~\n\n`make -f chris`\n\n\n\n## 栗子🌰\n\n好啦，说起来简单，但是实际操作却需要些许耐心~\n\n以下是我写的一个简单的makefile，用于编译资源文件和打包成静态库，还有一个脚本，结合makefile，打包armv7,armv7s,arm64,i386,x86_64这五个平台的静态库，并使用lipo合成为\"Fat Library\"。\n\n### makefile\n\n```cmake\nOUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 由于C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \\\n\t${OBJ_D}/lock.o \\\n    ${OBJ_D}/time.o \\\n    ${OBJ_D}/NETCA_Alloc.o \\\n    ${OBJ_D}/NETCA_ArrayList.o \\\n    ${OBJ_D}/NETCA_BigInteger.o \\\n    ${OBJ_D}/NETCA_BitSet.o \\\n    ${OBJ_D}/NETCA_Error.o \\\n    ${OBJ_D}/NETCA_Stream.o \\\n\t${OBJ_D}/NETCA_Stream_Base64.o \\\n    ${OBJ_D}/NETCA_Stream_File.o \\\n    ${OBJ_D}/NETCA_Stream_Hex.o \\\n    ${OBJ_D}/NETCA_Stream_HMAC.o \\\n    ${OBJ_D}/NETCA_Stream_MD.o \\\n    ${OBJ_D}/NETCA_Stream_Mem.o \\\n    ${OBJ_D}/NETCA_Stream_Null.o \\\n    ${OBJ_D}/NETCA_Time.o \\\n    ${OBJ_D}/NETCA_UString.o \\\n    ${OBJ_D}/NETCA_Util.o \\\n\t${OBJ_D}/NETCA_JSON.o\n\t\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libnetca_util.2.5.1.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n\t${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n${OBJ_D}/time.o:unix/time.c\n\t${CC} ${CFLAG} -c unix/time.c -o ${OBJ_D}/time.o\n\n${OBJ_D}/lock.o:unix/lock.c\n\t${CC} -D_GNU_SOURCE ${CFLAG} -c unix/lock.c -o ${OBJ_D}/lock.o\n\n${OBJ_D}/NETCA_Alloc.o:NETCA_Alloc.c\n\t${CC} ${CFLAG} -c NETCA_Alloc.c -o ${OBJ_D}/NETCA_Alloc.o\n\n${OBJ_D}/NETCA_ArrayList.o:NETCA_ArrayList.c\n\t${CC} ${CFLAG} -c NETCA_ArrayList.c -o ${OBJ_D}/NETCA_ArrayList.o\n\t\n${OBJ_D}/NETCA_BigInteger.o:NETCA_BigInteger_Openssl.c\n\t${CC} ${CFLAG} -Wno-deprecated-declarations -c NETCA_BigInteger_Openssl.c -o ${OBJ_D}/NETCA_BigInteger.o\n\n${OBJ_D}/NETCA_BitSet.o:NETCA_BitSet.c\n\t${CC} ${CFLAG} -c NETCA_BitSet.c -o ${OBJ_D}/NETCA_BitSet.o\n\n${OBJ_D}/NETCA_Error.o:NETCA_Error.c\n\t${CC} ${CFLAG} -c NETCA_Error.c -o ${OBJ_D}/NETCA_Error.o\n\n${OBJ_D}/NETCA_Stream.o:NETCA_Stream.c\n\t${CC} ${CFLAG} -c NETCA_Stream.c -o ${OBJ_D}/NETCA_Stream.o\n\n${OBJ_D}/NETCA_Stream_Base64.o:NETCA_Stream_Base64.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Base64.c -o ${OBJ_D}/NETCA_Stream_Base64.o\n\n${OBJ_D}/NETCA_Stream_File.o:NETCA_Stream_File.c\n\t${CC} ${CFLAG} -c NETCA_Stream_File.c -o ${OBJ_D}/NETCA_Stream_File.o\n\n${OBJ_D}/NETCA_Stream_Hex.o:NETCA_Stream_Hex.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Hex.c -o ${OBJ_D}/NETCA_Stream_Hex.o\n\n${OBJ_D}/NETCA_Stream_HMAC.o:NETCA_Stream_HMAC.c\n\t${CC} ${CFLAG} -c NETCA_Stream_HMAC.c -o ${OBJ_D}/NETCA_Stream_HMAC.o\n\n${OBJ_D}/NETCA_Stream_MD.o:NETCA_Stream_MD.c\n\t${CC} ${CFLAG} -c NETCA_Stream_MD.c -o ${OBJ_D}/NETCA_Stream_MD.o\n\n${OBJ_D}/NETCA_Stream_Mem.o:NETCA_Stream_Mem.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Mem.c -o ${OBJ_D}/NETCA_Stream_Mem.o\n\n${OBJ_D}/NETCA_Stream_Null.o:NETCA_Stream_Null.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Null.c -o ${OBJ_D}/NETCA_Stream_Null.o\n\n${OBJ_D}/NETCA_Time.o:NETCA_Time.c\n\t${CC} ${CFLAG} -std=c99 -c NETCA_Time.c -o ${OBJ_D}/NETCA_Time.o\n\n${OBJ_D}/NETCA_UString.o:NETCA_UString.c NETCA_UString_Unicode_Data.c\n\t${CC} ${CFLAG} -c NETCA_UString.c -o ${OBJ_D}/NETCA_UString.o\n\n\n${OBJ_D}/NETCA_Util.o:NETCA_Util.c\n\t${CC} ${CFLAG} -c NETCA_Util.c -o ${OBJ_D}/NETCA_Util.o\n\n${OBJ_D}/NETCA_JSON.o:NETCA_JSON.c\n\t${CC} ${CFLAG} -c NETCA_JSON.c -o ${OBJ_D}/NETCA_JSON.o\n\n\n$(OBJ_D):\n\t${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n\t${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n\t${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libnetca_util.2.5.1.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n\tlibtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libnetca_util.2.5.1.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\t\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n\t${RM} -rf ${OUT_D}\n\nclean:\n\t${RM} -rf ${OBJ_D}\n```\n\n### Shell\n\n```shell\nLIB_NAME=libnetca_util.2.5.1.a\nLIB_OS_NAME=libnetca_util.2.5.1_os.a\nLIB_SIMULATOR_NAME=libnetca_util.2.5.1_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(\"armv7\" \"armv7s\" \"arm64\")\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(\"armv7/libnetca_util.2.5.1_os.a\",...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(\"i386\" \"x86_64\")\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n\tmake -f makefile.ios clean\n\tmake -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_OS_COUNT}; i++))\ndo\n\tarch_make ${ARCH_OS_LIST[i]} \"OS\"\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_SIM_COUNT}; i++))\ndo\n\tarch_make ${ARCH_SIM_LIST[i]} \"Simulator\"\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp NETCA_*.h ${HEADER_D}/\n\n#LIPO 合成为\"Fat Library\"\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n\n\n```\n\n## 总结\n\n1. 感觉makefile还是有必要学会，因为编译和链接可以由自己掌握。\n2. 此次编写makefile的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。\n3. makefile在iOS上的使用方面，最主要的困难还是如何指定SDK，毕竟移植到iOS的时候，Win上或Linux上的代码并不是都可用，像这次就需要用到iOS的SDK里CoreFoundation的内容去替换一些已有的实现。\n\n\n\n","source":"_posts/使用MakeFile创建静态库.md","raw":"---\ntitle: 使用makefile创建静态库\nthumbnail: http://7xs4ed.com1.z0.glb.clouddn.com/Dubai_paohui.jpg\ndate: 2017-08-08 22:17:57\nid: 42F1A99632F0B88D\ntags: \n- Library\n---\n\n最近工作上需要将Win上的一个C库移植到iOS上以支持业务的开展，修改代码后需要编译成静态库供iOS使用，为了使用Windows或Linux的同事在修改完代码后也能编译出静态库而无需再搬到Mac上操作，学习了一下makefile。    \n\n<!--more-->\n\n说来惭愧，自己的C/C++水平还没有到达很高的水平，最开始想到的最简单的方式就是创建`Cocoa Touch Static Library`项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    \n\n但是为了让其他同事更快捷地完成工作，学习了如何使用makefile来编译静态库。\n\n本文只是皮毛，主要是在此次工作中的一些历程。     \n\n## 静态库特点\n\n> - 静态库对函数库的链接是放在编译时期完成的。\n> - 程序在运行时与函数库再无关系，移植方便。\n> - 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。\n> - 更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。\n\n留下疑问：是否可以理解为：只需要其他库的头文件？\n\n## makefile\n\nmakefile本身只是一个文件，用来辅助make命令执行时，告诉make命令怎么去编译和链接程序。    \n\n那编译和链接的规则是：\n\n> - 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。\n> - 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。\n> - 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。\n\nGoogle可以搜索到很多makefile的好文章，这里简略介绍一下：\n\n### 基本语句\n\n```\ntarget : prerequisites\n\tcommand\n```\n\n- target : 编译或链接最终得到的目标文件，例如.o结尾的中间文件、由.o文件链接而成的Win下的可执行文件，.o文件打包而成的静态库文件\n- prerequisites : 依赖，也就是编译成.o的.c、.cpp、.m和.h，链接成动态库、静态库、可执行文件的.o\n- command : 命令，即如何将上述的依赖编译或链接成我们要的target，需要注意的是，command前必须要有一个制表符(tab)，不能是一连串的空格，也不能缺失。\n\n\n\n\n\n#### Phony Target\n\nPHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    \n\n像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行`make clean`，这里的clean就是makefile中被定义的Phony Target。下面例子会说到。    \n\n一个makefile只能有一个总的Target(编译链接得到我们最终需要的文件)，如果需要多个Target，可以使用Phony Target来实现。当然，上述说到的除编译链接之外的操作用Phony Target也是很好的选择。\n\n\n\n### 变量\n\n像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过`${变量}`使用，例如：\n\n```\nDEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n```\n\n\n\n### 文件名及使用\n\n当然，既然叫makefile，文件名最好就叫makefile啦，Makefile也是可以的，但是是在makefile不存在的时候，make命令才会去使用。\n\n如果再不喜欢，文件名写成`chris`也可以，只是make的时候加上-f和文件名就好了~\n\n`make -f chris`\n\n\n\n## 栗子🌰\n\n好啦，说起来简单，但是实际操作却需要些许耐心~\n\n以下是我写的一个简单的makefile，用于编译资源文件和打包成静态库，还有一个脚本，结合makefile，打包armv7,armv7s,arm64,i386,x86_64这五个平台的静态库，并使用lipo合成为\"Fat Library\"。\n\n### makefile\n\n```cmake\nOUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 由于C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \\\n\t${OBJ_D}/lock.o \\\n    ${OBJ_D}/time.o \\\n    ${OBJ_D}/NETCA_Alloc.o \\\n    ${OBJ_D}/NETCA_ArrayList.o \\\n    ${OBJ_D}/NETCA_BigInteger.o \\\n    ${OBJ_D}/NETCA_BitSet.o \\\n    ${OBJ_D}/NETCA_Error.o \\\n    ${OBJ_D}/NETCA_Stream.o \\\n\t${OBJ_D}/NETCA_Stream_Base64.o \\\n    ${OBJ_D}/NETCA_Stream_File.o \\\n    ${OBJ_D}/NETCA_Stream_Hex.o \\\n    ${OBJ_D}/NETCA_Stream_HMAC.o \\\n    ${OBJ_D}/NETCA_Stream_MD.o \\\n    ${OBJ_D}/NETCA_Stream_Mem.o \\\n    ${OBJ_D}/NETCA_Stream_Null.o \\\n    ${OBJ_D}/NETCA_Time.o \\\n    ${OBJ_D}/NETCA_UString.o \\\n    ${OBJ_D}/NETCA_Util.o \\\n\t${OBJ_D}/NETCA_JSON.o\n\t\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libnetca_util.2.5.1.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n\t${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n${OBJ_D}/time.o:unix/time.c\n\t${CC} ${CFLAG} -c unix/time.c -o ${OBJ_D}/time.o\n\n${OBJ_D}/lock.o:unix/lock.c\n\t${CC} -D_GNU_SOURCE ${CFLAG} -c unix/lock.c -o ${OBJ_D}/lock.o\n\n${OBJ_D}/NETCA_Alloc.o:NETCA_Alloc.c\n\t${CC} ${CFLAG} -c NETCA_Alloc.c -o ${OBJ_D}/NETCA_Alloc.o\n\n${OBJ_D}/NETCA_ArrayList.o:NETCA_ArrayList.c\n\t${CC} ${CFLAG} -c NETCA_ArrayList.c -o ${OBJ_D}/NETCA_ArrayList.o\n\t\n${OBJ_D}/NETCA_BigInteger.o:NETCA_BigInteger_Openssl.c\n\t${CC} ${CFLAG} -Wno-deprecated-declarations -c NETCA_BigInteger_Openssl.c -o ${OBJ_D}/NETCA_BigInteger.o\n\n${OBJ_D}/NETCA_BitSet.o:NETCA_BitSet.c\n\t${CC} ${CFLAG} -c NETCA_BitSet.c -o ${OBJ_D}/NETCA_BitSet.o\n\n${OBJ_D}/NETCA_Error.o:NETCA_Error.c\n\t${CC} ${CFLAG} -c NETCA_Error.c -o ${OBJ_D}/NETCA_Error.o\n\n${OBJ_D}/NETCA_Stream.o:NETCA_Stream.c\n\t${CC} ${CFLAG} -c NETCA_Stream.c -o ${OBJ_D}/NETCA_Stream.o\n\n${OBJ_D}/NETCA_Stream_Base64.o:NETCA_Stream_Base64.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Base64.c -o ${OBJ_D}/NETCA_Stream_Base64.o\n\n${OBJ_D}/NETCA_Stream_File.o:NETCA_Stream_File.c\n\t${CC} ${CFLAG} -c NETCA_Stream_File.c -o ${OBJ_D}/NETCA_Stream_File.o\n\n${OBJ_D}/NETCA_Stream_Hex.o:NETCA_Stream_Hex.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Hex.c -o ${OBJ_D}/NETCA_Stream_Hex.o\n\n${OBJ_D}/NETCA_Stream_HMAC.o:NETCA_Stream_HMAC.c\n\t${CC} ${CFLAG} -c NETCA_Stream_HMAC.c -o ${OBJ_D}/NETCA_Stream_HMAC.o\n\n${OBJ_D}/NETCA_Stream_MD.o:NETCA_Stream_MD.c\n\t${CC} ${CFLAG} -c NETCA_Stream_MD.c -o ${OBJ_D}/NETCA_Stream_MD.o\n\n${OBJ_D}/NETCA_Stream_Mem.o:NETCA_Stream_Mem.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Mem.c -o ${OBJ_D}/NETCA_Stream_Mem.o\n\n${OBJ_D}/NETCA_Stream_Null.o:NETCA_Stream_Null.c\n\t${CC} ${CFLAG} -c NETCA_Stream_Null.c -o ${OBJ_D}/NETCA_Stream_Null.o\n\n${OBJ_D}/NETCA_Time.o:NETCA_Time.c\n\t${CC} ${CFLAG} -std=c99 -c NETCA_Time.c -o ${OBJ_D}/NETCA_Time.o\n\n${OBJ_D}/NETCA_UString.o:NETCA_UString.c NETCA_UString_Unicode_Data.c\n\t${CC} ${CFLAG} -c NETCA_UString.c -o ${OBJ_D}/NETCA_UString.o\n\n\n${OBJ_D}/NETCA_Util.o:NETCA_Util.c\n\t${CC} ${CFLAG} -c NETCA_Util.c -o ${OBJ_D}/NETCA_Util.o\n\n${OBJ_D}/NETCA_JSON.o:NETCA_JSON.c\n\t${CC} ${CFLAG} -c NETCA_JSON.c -o ${OBJ_D}/NETCA_JSON.o\n\n\n$(OBJ_D):\n\t${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n\t${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n\t${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libnetca_util.2.5.1.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n\tlibtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libnetca_util.2.5.1.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\t\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n\t${RM} -rf ${OUT_D}\n\nclean:\n\t${RM} -rf ${OBJ_D}\n```\n\n### Shell\n\n```shell\nLIB_NAME=libnetca_util.2.5.1.a\nLIB_OS_NAME=libnetca_util.2.5.1_os.a\nLIB_SIMULATOR_NAME=libnetca_util.2.5.1_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(\"armv7\" \"armv7s\" \"arm64\")\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(\"armv7/libnetca_util.2.5.1_os.a\",...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(\"i386\" \"x86_64\")\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n\tmake -f makefile.ios clean\n\tmake -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_OS_COUNT}; i++))\ndo\n\tarch_make ${ARCH_OS_LIST[i]} \"OS\"\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i < ${ARCH_SIM_COUNT}; i++))\ndo\n\tarch_make ${ARCH_SIM_LIST[i]} \"Simulator\"\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp NETCA_*.h ${HEADER_D}/\n\n#LIPO 合成为\"Fat Library\"\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n\n\n```\n\n## 总结\n\n1. 感觉makefile还是有必要学会，因为编译和链接可以由自己掌握。\n2. 此次编写makefile的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。\n3. makefile在iOS上的使用方面，最主要的困难还是如何指定SDK，毕竟移植到iOS的时候，Win上或Linux上的代码并不是都可用，像这次就需要用到iOS的SDK里CoreFoundation的内容去替换一些已有的实现。\n\n\n\n","slug":"使用MakeFile创建静态库","published":1,"updated":"2018-03-07T05:05:15.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xom0009z4y8azxp31gx","content":"<p>最近工作上需要将Win上的一个C库移植到iOS上以支持业务的开展，修改代码后需要编译成静态库供iOS使用，为了使用Windows或Linux的同事在修改完代码后也能编译出静态库而无需再搬到Mac上操作，学习了一下makefile。    </p>\n<a id=\"more\"></a>\n<p>说来惭愧，自己的C/C++水平还没有到达很高的水平，最开始想到的最简单的方式就是创建<code>Cocoa Touch Static Library</code>项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    </p>\n<p>但是为了让其他同事更快捷地完成工作，学习了如何使用makefile来编译静态库。</p>\n<p>本文只是皮毛，主要是在此次工作中的一些历程。     </p>\n<h2 id=\"静态库特点\"><a href=\"#静态库特点\" class=\"headerlink\" title=\"静态库特点\"></a>静态库特点</h2><blockquote>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的。</li>\n<li>程序在运行时与函数库再无关系，移植方便。</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n<li>更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。</li>\n</ul>\n</blockquote>\n<p>留下疑问：是否可以理解为：只需要其他库的头文件？</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><p>makefile本身只是一个文件，用来辅助make命令执行时，告诉make命令怎么去编译和链接程序。    </p>\n<p>那编译和链接的规则是：</p>\n<blockquote>\n<ul>\n<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>\n<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>\n<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>\n</ul>\n</blockquote>\n<p>Google可以搜索到很多makefile的好文章，这里简略介绍一下：</p>\n<h3 id=\"基本语句\"><a href=\"#基本语句\" class=\"headerlink\" title=\"基本语句\"></a>基本语句</h3><pre><code>target : prerequisites\n    command\n</code></pre><ul>\n<li>target : 编译或链接最终得到的目标文件，例如.o结尾的中间文件、由.o文件链接而成的Win下的可执行文件，.o文件打包而成的静态库文件</li>\n<li>prerequisites : 依赖，也就是编译成.o的.c、.cpp、.m和.h，链接成动态库、静态库、可执行文件的.o</li>\n<li>command : 命令，即如何将上述的依赖编译或链接成我们要的target，需要注意的是，command前必须要有一个制表符(tab)，不能是一连串的空格，也不能缺失。</li>\n</ul>\n<h4 id=\"Phony-Target\"><a href=\"#Phony-Target\" class=\"headerlink\" title=\"Phony Target\"></a>Phony Target</h4><p>PHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    </p>\n<p>像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行<code>make clean</code>，这里的clean就是makefile中被定义的Phony Target。下面例子会说到。    </p>\n<p>一个makefile只能有一个总的Target(编译链接得到我们最终需要的文件)，如果需要多个Target，可以使用Phony Target来实现。当然，上述说到的除编译链接之外的操作用Phony Target也是很好的选择。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过<code>${变量}</code>使用，例如：</p>\n<pre><code>DEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n</code></pre><h3 id=\"文件名及使用\"><a href=\"#文件名及使用\" class=\"headerlink\" title=\"文件名及使用\"></a>文件名及使用</h3><p>当然，既然叫makefile，文件名最好就叫makefile啦，Makefile也是可以的，但是是在makefile不存在的时候，make命令才会去使用。</p>\n<p>如果再不喜欢，文件名写成<code>chris</code>也可以，只是make的时候加上-f和文件名就好了~</p>\n<p><code>make -f chris</code></p>\n<h2 id=\"栗子🌰\"><a href=\"#栗子🌰\" class=\"headerlink\" title=\"栗子🌰\"></a>栗子🌰</h2><p>好啦，说起来简单，但是实际操作却需要些许耐心~</p>\n<p>以下是我写的一个简单的makefile，用于编译资源文件和打包成静态库，还有一个脚本，结合makefile，打包armv7,armv7s,arm64,i386,x86_64这五个平台的静态库，并使用lipo合成为”Fat Library”。</p>\n<h3 id=\"makefile-1\"><a href=\"#makefile-1\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><pre><code class=\"cmake\">OUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 由于C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \\\n    ${OBJ_D}/lock.o \\\n    ${OBJ_D}/time.o \\\n    ${OBJ_D}/NETCA_Alloc.o \\\n    ${OBJ_D}/NETCA_ArrayList.o \\\n    ${OBJ_D}/NETCA_BigInteger.o \\\n    ${OBJ_D}/NETCA_BitSet.o \\\n    ${OBJ_D}/NETCA_Error.o \\\n    ${OBJ_D}/NETCA_Stream.o \\\n    ${OBJ_D}/NETCA_Stream_Base64.o \\\n    ${OBJ_D}/NETCA_Stream_File.o \\\n    ${OBJ_D}/NETCA_Stream_Hex.o \\\n    ${OBJ_D}/NETCA_Stream_HMAC.o \\\n    ${OBJ_D}/NETCA_Stream_MD.o \\\n    ${OBJ_D}/NETCA_Stream_Mem.o \\\n    ${OBJ_D}/NETCA_Stream_Null.o \\\n    ${OBJ_D}/NETCA_Time.o \\\n    ${OBJ_D}/NETCA_UString.o \\\n    ${OBJ_D}/NETCA_Util.o \\\n    ${OBJ_D}/NETCA_JSON.o\n\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libnetca_util.2.5.1.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n    ${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n${OBJ_D}/time.o:unix/time.c\n    ${CC} ${CFLAG} -c unix/time.c -o ${OBJ_D}/time.o\n\n${OBJ_D}/lock.o:unix/lock.c\n    ${CC} -D_GNU_SOURCE ${CFLAG} -c unix/lock.c -o ${OBJ_D}/lock.o\n\n${OBJ_D}/NETCA_Alloc.o:NETCA_Alloc.c\n    ${CC} ${CFLAG} -c NETCA_Alloc.c -o ${OBJ_D}/NETCA_Alloc.o\n\n${OBJ_D}/NETCA_ArrayList.o:NETCA_ArrayList.c\n    ${CC} ${CFLAG} -c NETCA_ArrayList.c -o ${OBJ_D}/NETCA_ArrayList.o\n\n${OBJ_D}/NETCA_BigInteger.o:NETCA_BigInteger_Openssl.c\n    ${CC} ${CFLAG} -Wno-deprecated-declarations -c NETCA_BigInteger_Openssl.c -o ${OBJ_D}/NETCA_BigInteger.o\n\n${OBJ_D}/NETCA_BitSet.o:NETCA_BitSet.c\n    ${CC} ${CFLAG} -c NETCA_BitSet.c -o ${OBJ_D}/NETCA_BitSet.o\n\n${OBJ_D}/NETCA_Error.o:NETCA_Error.c\n    ${CC} ${CFLAG} -c NETCA_Error.c -o ${OBJ_D}/NETCA_Error.o\n\n${OBJ_D}/NETCA_Stream.o:NETCA_Stream.c\n    ${CC} ${CFLAG} -c NETCA_Stream.c -o ${OBJ_D}/NETCA_Stream.o\n\n${OBJ_D}/NETCA_Stream_Base64.o:NETCA_Stream_Base64.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Base64.c -o ${OBJ_D}/NETCA_Stream_Base64.o\n\n${OBJ_D}/NETCA_Stream_File.o:NETCA_Stream_File.c\n    ${CC} ${CFLAG} -c NETCA_Stream_File.c -o ${OBJ_D}/NETCA_Stream_File.o\n\n${OBJ_D}/NETCA_Stream_Hex.o:NETCA_Stream_Hex.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Hex.c -o ${OBJ_D}/NETCA_Stream_Hex.o\n\n${OBJ_D}/NETCA_Stream_HMAC.o:NETCA_Stream_HMAC.c\n    ${CC} ${CFLAG} -c NETCA_Stream_HMAC.c -o ${OBJ_D}/NETCA_Stream_HMAC.o\n\n${OBJ_D}/NETCA_Stream_MD.o:NETCA_Stream_MD.c\n    ${CC} ${CFLAG} -c NETCA_Stream_MD.c -o ${OBJ_D}/NETCA_Stream_MD.o\n\n${OBJ_D}/NETCA_Stream_Mem.o:NETCA_Stream_Mem.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Mem.c -o ${OBJ_D}/NETCA_Stream_Mem.o\n\n${OBJ_D}/NETCA_Stream_Null.o:NETCA_Stream_Null.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Null.c -o ${OBJ_D}/NETCA_Stream_Null.o\n\n${OBJ_D}/NETCA_Time.o:NETCA_Time.c\n    ${CC} ${CFLAG} -std=c99 -c NETCA_Time.c -o ${OBJ_D}/NETCA_Time.o\n\n${OBJ_D}/NETCA_UString.o:NETCA_UString.c NETCA_UString_Unicode_Data.c\n    ${CC} ${CFLAG} -c NETCA_UString.c -o ${OBJ_D}/NETCA_UString.o\n\n\n${OBJ_D}/NETCA_Util.o:NETCA_Util.c\n    ${CC} ${CFLAG} -c NETCA_Util.c -o ${OBJ_D}/NETCA_Util.o\n\n${OBJ_D}/NETCA_JSON.o:NETCA_JSON.c\n    ${CC} ${CFLAG} -c NETCA_JSON.c -o ${OBJ_D}/NETCA_JSON.o\n\n\n$(OBJ_D):\n    ${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n    ${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n    ${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libnetca_util.2.5.1.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n    libtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libnetca_util.2.5.1.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n    ${RM} -rf ${OUT_D}\n\nclean:\n    ${RM} -rf ${OBJ_D}\n</code></pre>\n<h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><pre><code class=\"shell\">LIB_NAME=libnetca_util.2.5.1.a\nLIB_OS_NAME=libnetca_util.2.5.1_os.a\nLIB_SIMULATOR_NAME=libnetca_util.2.5.1_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(&quot;armv7&quot; &quot;armv7s&quot; &quot;arm64&quot;)\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(&quot;armv7/libnetca_util.2.5.1_os.a&quot;,...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(&quot;i386&quot; &quot;x86_64&quot;)\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n    make -f makefile.ios clean\n    make -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_OS_COUNT}; i++))\ndo\n    arch_make ${ARCH_OS_LIST[i]} &quot;OS&quot;\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_SIM_COUNT}; i++))\ndo\n    arch_make ${ARCH_SIM_LIST[i]} &quot;Simulator&quot;\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp NETCA_*.h ${HEADER_D}/\n\n#LIPO 合成为&quot;Fat Library&quot;\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>感觉makefile还是有必要学会，因为编译和链接可以由自己掌握。</li>\n<li>此次编写makefile的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。</li>\n<li>makefile在iOS上的使用方面，最主要的困难还是如何指定SDK，毕竟移植到iOS的时候，Win上或Linux上的代码并不是都可用，像这次就需要用到iOS的SDK里CoreFoundation的内容去替换一些已有的实现。</li>\n</ol>\n","excerpt":"<p>最近工作上需要将Win上的一个C库移植到iOS上以支持业务的开展，修改代码后需要编译成静态库供iOS使用，为了使用Windows或Linux的同事在修改完代码后也能编译出静态库而无需再搬到Mac上操作，学习了一下makefile。    </p>","more":"<p>说来惭愧，自己的C/C++水平还没有到达很高的水平，最开始想到的最简单的方式就是创建<code>Cocoa Touch Static Library</code>项目，然后直接将所需要的代码文件无脑添加到项目里面，编译，合成。    </p>\n<p>但是为了让其他同事更快捷地完成工作，学习了如何使用makefile来编译静态库。</p>\n<p>本文只是皮毛，主要是在此次工作中的一些历程。     </p>\n<h2 id=\"静态库特点\"><a href=\"#静态库特点\" class=\"headerlink\" title=\"静态库特点\"></a>静态库特点</h2><blockquote>\n<ul>\n<li>静态库对函数库的链接是放在编译时期完成的。</li>\n<li>程序在运行时与函数库再无关系，移植方便。</li>\n<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>\n<li>更新困难。当程序所依赖的静态库有任何更新，整个程序就要重新链接。</li>\n</ul>\n</blockquote>\n<p>留下疑问：是否可以理解为：只需要其他库的头文件？</p>\n<h2 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h2><p>makefile本身只是一个文件，用来辅助make命令执行时，告诉make命令怎么去编译和链接程序。    </p>\n<p>那编译和链接的规则是：</p>\n<blockquote>\n<ul>\n<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>\n<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>\n<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>\n</ul>\n</blockquote>\n<p>Google可以搜索到很多makefile的好文章，这里简略介绍一下：</p>\n<h3 id=\"基本语句\"><a href=\"#基本语句\" class=\"headerlink\" title=\"基本语句\"></a>基本语句</h3><pre><code>target : prerequisites\n    command\n</code></pre><ul>\n<li>target : 编译或链接最终得到的目标文件，例如.o结尾的中间文件、由.o文件链接而成的Win下的可执行文件，.o文件打包而成的静态库文件</li>\n<li>prerequisites : 依赖，也就是编译成.o的.c、.cpp、.m和.h，链接成动态库、静态库、可执行文件的.o</li>\n<li>command : 命令，即如何将上述的依赖编译或链接成我们要的target，需要注意的是，command前必须要有一个制表符(tab)，不能是一连串的空格，也不能缺失。</li>\n</ul>\n<h4 id=\"Phony-Target\"><a href=\"#Phony-Target\" class=\"headerlink\" title=\"Phony Target\"></a>Phony Target</h4><p>PHONY 目标并非实际的文件名：只是在显式请求时执行命令的名字。    </p>\n<p>像平常我们需要自己编译第三方库的时候，在执行完链接后需要清楚产生的中间文件或其他配置等，需要执行<code>make clean</code>，这里的clean就是makefile中被定义的Phony Target。下面例子会说到。    </p>\n<p>一个makefile只能有一个总的Target(编译链接得到我们最终需要的文件)，如果需要多个Target，可以使用Phony Target来实现。当然，上述说到的除编译链接之外的操作用Phony Target也是很好的选择。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>像写程序一样直接定义变量，变量在左侧，值在右侧，等号分开，然后通过<code>${变量}</code>使用，例如：</p>\n<pre><code>DEVICE=OS\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\n</code></pre><h3 id=\"文件名及使用\"><a href=\"#文件名及使用\" class=\"headerlink\" title=\"文件名及使用\"></a>文件名及使用</h3><p>当然，既然叫makefile，文件名最好就叫makefile啦，Makefile也是可以的，但是是在makefile不存在的时候，make命令才会去使用。</p>\n<p>如果再不喜欢，文件名写成<code>chris</code>也可以，只是make的时候加上-f和文件名就好了~</p>\n<p><code>make -f chris</code></p>\n<h2 id=\"栗子🌰\"><a href=\"#栗子🌰\" class=\"headerlink\" title=\"栗子🌰\"></a>栗子🌰</h2><p>好啦，说起来简单，但是实际操作却需要些许耐心~</p>\n<p>以下是我写的一个简单的makefile，用于编译资源文件和打包成静态库，还有一个脚本，结合makefile，打包armv7,armv7s,arm64,i386,x86_64这五个平台的静态库，并使用lipo合成为”Fat Library”。</p>\n<h3 id=\"makefile-1\"><a href=\"#makefile-1\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><pre><code class=\"cmake\">OUT_D=out\nARCH_D=${OUT_D}/${ARCH}\nOBJ_D=tmp\n# DEVICE 和 ARCH 是外部传入的值，用于区分是OS还是SIMULATOR，平台是哪种\n# 由于C代码中使用到了CoreFoundation和跨平台编译使用到__APPLE__、TARGET_OS_IPHONE等宏，所以需要引入iOS的SDK\nDEV_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhone${DEVICE}.platform/Developer\nSDK_PATH=${DEV_PATH}/SDKs/iPhone${DEVICE}10.3.sdk\n\nCPP=clang\nCC=clang\n\nINC_PATH_FLAG=-I. \n# iOS平台的编译选项\nIOS_FLAG=-arch ${ARCH} -isysroot ${SDK_PATH} -miphoneos-version-min=8.0\nCFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\nCPPFLAG=-Wall -O2  ${INC_PATH_FLAG} ${IOS_FLAG}\n\nIOS_LINK_FLAG=-framework CoreFoundation \n\nRM=rm\nMKDIR=mkdir\n\n# OBJECTS变量，后文会通过${OBJECTS}来使用\nOBJECTS=${OBJ_D}/string.o \\\n    ${OBJ_D}/lock.o \\\n    ${OBJ_D}/time.o \\\n    ${OBJ_D}/NETCA_Alloc.o \\\n    ${OBJ_D}/NETCA_ArrayList.o \\\n    ${OBJ_D}/NETCA_BigInteger.o \\\n    ${OBJ_D}/NETCA_BitSet.o \\\n    ${OBJ_D}/NETCA_Error.o \\\n    ${OBJ_D}/NETCA_Stream.o \\\n    ${OBJ_D}/NETCA_Stream_Base64.o \\\n    ${OBJ_D}/NETCA_Stream_File.o \\\n    ${OBJ_D}/NETCA_Stream_Hex.o \\\n    ${OBJ_D}/NETCA_Stream_HMAC.o \\\n    ${OBJ_D}/NETCA_Stream_MD.o \\\n    ${OBJ_D}/NETCA_Stream_Mem.o \\\n    ${OBJ_D}/NETCA_Stream_Null.o \\\n    ${OBJ_D}/NETCA_Time.o \\\n    ${OBJ_D}/NETCA_UString.o \\\n    ${OBJ_D}/NETCA_Util.o \\\n    ${OBJ_D}/NETCA_JSON.o\n\n# 最终target，make解析makefile的时候会将第一个遇到的target作为最终target来执行本次操作\nall:${ARCH_D}/libnetca_util.2.5.1.a\n\n#下面是对资源文件的编译，生成.o中间文件        \n${OBJ_D}/string.o:unix/string.c\n    ${CC} ${CFLAG} -c unix/string.c -o ${OBJ_D}/string.o\n\n${OBJ_D}/time.o:unix/time.c\n    ${CC} ${CFLAG} -c unix/time.c -o ${OBJ_D}/time.o\n\n${OBJ_D}/lock.o:unix/lock.c\n    ${CC} -D_GNU_SOURCE ${CFLAG} -c unix/lock.c -o ${OBJ_D}/lock.o\n\n${OBJ_D}/NETCA_Alloc.o:NETCA_Alloc.c\n    ${CC} ${CFLAG} -c NETCA_Alloc.c -o ${OBJ_D}/NETCA_Alloc.o\n\n${OBJ_D}/NETCA_ArrayList.o:NETCA_ArrayList.c\n    ${CC} ${CFLAG} -c NETCA_ArrayList.c -o ${OBJ_D}/NETCA_ArrayList.o\n\n${OBJ_D}/NETCA_BigInteger.o:NETCA_BigInteger_Openssl.c\n    ${CC} ${CFLAG} -Wno-deprecated-declarations -c NETCA_BigInteger_Openssl.c -o ${OBJ_D}/NETCA_BigInteger.o\n\n${OBJ_D}/NETCA_BitSet.o:NETCA_BitSet.c\n    ${CC} ${CFLAG} -c NETCA_BitSet.c -o ${OBJ_D}/NETCA_BitSet.o\n\n${OBJ_D}/NETCA_Error.o:NETCA_Error.c\n    ${CC} ${CFLAG} -c NETCA_Error.c -o ${OBJ_D}/NETCA_Error.o\n\n${OBJ_D}/NETCA_Stream.o:NETCA_Stream.c\n    ${CC} ${CFLAG} -c NETCA_Stream.c -o ${OBJ_D}/NETCA_Stream.o\n\n${OBJ_D}/NETCA_Stream_Base64.o:NETCA_Stream_Base64.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Base64.c -o ${OBJ_D}/NETCA_Stream_Base64.o\n\n${OBJ_D}/NETCA_Stream_File.o:NETCA_Stream_File.c\n    ${CC} ${CFLAG} -c NETCA_Stream_File.c -o ${OBJ_D}/NETCA_Stream_File.o\n\n${OBJ_D}/NETCA_Stream_Hex.o:NETCA_Stream_Hex.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Hex.c -o ${OBJ_D}/NETCA_Stream_Hex.o\n\n${OBJ_D}/NETCA_Stream_HMAC.o:NETCA_Stream_HMAC.c\n    ${CC} ${CFLAG} -c NETCA_Stream_HMAC.c -o ${OBJ_D}/NETCA_Stream_HMAC.o\n\n${OBJ_D}/NETCA_Stream_MD.o:NETCA_Stream_MD.c\n    ${CC} ${CFLAG} -c NETCA_Stream_MD.c -o ${OBJ_D}/NETCA_Stream_MD.o\n\n${OBJ_D}/NETCA_Stream_Mem.o:NETCA_Stream_Mem.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Mem.c -o ${OBJ_D}/NETCA_Stream_Mem.o\n\n${OBJ_D}/NETCA_Stream_Null.o:NETCA_Stream_Null.c\n    ${CC} ${CFLAG} -c NETCA_Stream_Null.c -o ${OBJ_D}/NETCA_Stream_Null.o\n\n${OBJ_D}/NETCA_Time.o:NETCA_Time.c\n    ${CC} ${CFLAG} -std=c99 -c NETCA_Time.c -o ${OBJ_D}/NETCA_Time.o\n\n${OBJ_D}/NETCA_UString.o:NETCA_UString.c NETCA_UString_Unicode_Data.c\n    ${CC} ${CFLAG} -c NETCA_UString.c -o ${OBJ_D}/NETCA_UString.o\n\n\n${OBJ_D}/NETCA_Util.o:NETCA_Util.c\n    ${CC} ${CFLAG} -c NETCA_Util.c -o ${OBJ_D}/NETCA_Util.o\n\n${OBJ_D}/NETCA_JSON.o:NETCA_JSON.c\n    ${CC} ${CFLAG} -c NETCA_JSON.c -o ${OBJ_D}/NETCA_JSON.o\n\n\n$(OBJ_D):\n    ${MKDIR} ${OBJ_D}\n\n$(OUT_D):\n    ${MKDIR} ${OUT_D}\n\n$(ARCH_D):\n    ${MKDIR} ${ARCH_D}\n\n# 对应于上面的all，依赖项是${OUT_D} ${ARCH_D} ${OBJ_D}对应的文件夹的创建和${OBJECTS} 对应的资源文件的编译\n${ARCH_D}/libnetca_util.2.5.1.a: ${OUT_D} ${ARCH_D} ${OBJ_D} ${OBJECTS} \n    libtool -static ${IOS_LINK_FLAG} -o ${ARCH_D}/libnetca_util.2.5.1.a ${OBJECTS} #此处其实也可以使用Linux的 ar 命令\n\n# Phony Target: realclean 依赖于clean的执行，调用make realclean会先调用make clean清除编译过程中的中间文件，再清除目标文件(为了多平台)\nrealclean: clean\n    ${RM} -rf ${OUT_D}\n\nclean:\n    ${RM} -rf ${OBJ_D}\n</code></pre>\n<h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><pre><code class=\"shell\">LIB_NAME=libnetca_util.2.5.1.a\nLIB_OS_NAME=libnetca_util.2.5.1_os.a\nLIB_SIMULATOR_NAME=libnetca_util.2.5.1_simulator.a\n\nOUT_D=out\nHEADER_D=${OUT_D}/include\n\nARCH_OS_LIST=(&quot;armv7&quot; &quot;armv7s&quot; &quot;arm64&quot;)\n# 得到ARCH_OS_LIST的数量\nARCH_OS_COUNT=${#ARCH_OS_LIST[@]}\n# 组合ARCH_OS_LIST中每一个元素和LIB_OS_NAME，得到数组(&quot;armv7/libnetca_util.2.5.1_os.a&quot;,...)\nLIB_OS_PATHS=(${ARCH_OS_LIST[@]/%//${LIB_NAME}})\n\nARCH_SIM_LIST=(&quot;i386&quot; &quot;x86_64&quot;)\nARCH_SIM_COUNT=${#ARCH_SIM_LIST[@]}\nLIB_SIM_PATHS=(${ARCH_SIM_LIST[@]/%//${LIB_NAME}})\n\n#Compile 使用-f指定makefile，Phony Target realclean清除所有中间文件和目标文件\nmake -f makefile.ios realclean\n\n#定义函数\narch_make() {\n    make -f makefile.ios clean\n    make -f makefile.ios ARCH=$1 DEVICE=$2\n}\n\n#遍历上面定义的数组，为OS的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_OS_COUNT}; i++))\ndo\n    arch_make ${ARCH_OS_LIST[i]} &quot;OS&quot;\ndone\n#遍历上面定义的数组，为SIMULATOR的每个架构创建.a文件\nfor ((i=0; i &lt; ${ARCH_SIM_COUNT}; i++))\ndo\n    arch_make ${ARCH_SIM_LIST[i]} &quot;Simulator&quot;\ndone\n\n#HEADER FILE 头文件提取出来\nmkdir ${HEADER_D}\ncp NETCA_*.h ${HEADER_D}/\n\n#LIPO 合成为&quot;Fat Library&quot;\ncd ${OUT_D}\nlipo -create ${LIB_OS_PATHS[@]} -output ${LIB_OS_NAME}\nlipo -create ${LIB_SIM_PATHS[@]} -output ${LIB_SIMULATOR_NAME}\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>感觉makefile还是有必要学会，因为编译和链接可以由自己掌握。</li>\n<li>此次编写makefile的工作不是很难，因为这只是要移植部分里面最简单最小的一个库。</li>\n<li>makefile在iOS上的使用方面，最主要的困难还是如何指定SDK，毕竟移植到iOS的时候，Win上或Linux上的代码并不是都可用，像这次就需要用到iOS的SDK里CoreFoundation的内容去替换一些已有的实现。</li>\n</ol>"},{"title":"对线程的简单理解","date":"2017-03-14T08:57:48.000Z","_content":"\n在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。\n\n<!--more-->\n\n## 什么是线程\n\n老生常谈，但还是先说一下概念：\n\n> *线程*，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  \n\n有两点需要注意：\n\n1. 线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈\n2. 共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。\n\n\n数据是否私有，如下表所示\n\n|     线程私有     |              线程间共享              |\n| :----------: | :-----------------------------: |\n| 局部变量<br>函数参数 | 全局变量<br>堆上的数据<br>函数内的静态变量<br>代码 |\n\n\n## 线程调度\n\n如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。\n\n但更经常地，我们可以看到类似这样的图：\n\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为*线程调度*。\n\n在线程调度中，线程有三种状态：\n\n- 运行：拥有时间片，可以执行代码\n- 就绪：在等待队列中，随时可以被执行\n- 等待：等待IO或者因为其他原因被阻塞，等待结束后进入就绪状态\n\n三者的状态切换如下图所示：\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg)\n线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。\n\n轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了CPU让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：\n\n- 在我们的编程中，我们可以手动设置优先级，最常见的，如iOS中GDC的`global queue`:\n\n\n```Objc\n// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n```\n- 操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（**IO密集型线程**）通常只占用很少的时间，这种线程比用完时间片的线程（**CPU密集型线程**）更受欢迎，在操作系统的调度中优先级更容易被提高。\n- 在调度过程中，还存在*线程饿死(Starvation)* 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。\n\n## 线程安全\n\nQ : 为什么会有线程安全问题？\n\nA : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 `i` 执行 `i++`，线程A和线程B都各自拥有自己的寄存器，对`i++`这种操作，线程A先将`i`的值存放在线程的寄存器中，执行计算后再赋值回去给`i`这个变量，中间如果线程B在A赋值之前先获取到`i`的值，那么最后赋值的结果肯定不正确。这就是线程不安全。\n\nQ : 怎么保证线程安全？\n\nA : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。\n\n- 原子操作（Atomic）\n  原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。\n- 同步与锁\n  同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。\n\n### 锁\n\n同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。\n\n最简单的（关于锁的详细内容，不在本文的讨论范围内）：\n\n```objc\nNSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n```\n\n### 信号量\n\n信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如GCD中：\n\n```objc\n// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n```\n\n当信号量`semaphore`小于0时，线程会暂停执行，直到`semaphore`重新变成0。\n\n### 临界区\n\n临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。\n\n信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用`signal`或`wait`来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：\n\n```objc\n@synchronized(self) {\n\t// 临界区代码\n}\n```\n\n### 可重入(Reentrant)\n\n可重入的概念，适用于函数。\n\n首先了解一下什么是*函数被重入*：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。\n\n可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：\n\n```objc\n- (int)sqr:(int) x {\n\treturn x * x;\n}\n```\n\n保证可重入，需要保证以下几个方面：\n\n- 不使用静态或全局非const的变量\n- 不返还静态或全局非const变量的指针\n- 仅依赖入参\n- 不调用不可重入的函数\n\n## 线程和队列的关系\n\n线程和队列的关系，一直都纠缠不清。\n\n在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。\n\n举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。\n\n串行队列：它是有序的传输带，编号是SQ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者A拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到SQ上，那就要等待A吃完面包了，B分享的面包才会被消费。此时传输带SQ就被暂停了。\n\n并行队列：任务的执行时无需等待前面的任务执行完，编号是CQ，同样，我的面包吃不完，放到CQ上，A正在享用，此时B也将面包放在CQ上，但是A无法享用（因为正在享用我的），因此CQ就发出警鸣，叫来了消费者C来将B的面包吃掉，以维持CQ的继续运转，当A吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。\n\n## 死锁\n\n首先，概念：\n\n> *死锁* 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  \n\n死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。\n\n上述关于*死锁* 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个iOS应用开发者，我使用GCD来说明一下：\n\n```objc\n// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n```\n\n上述代码必将造成死锁，但是此例只涉及一个线程，那就是iOS App的主线程（亦称UI线程）。我们知道，在iOS中，`main queue`是串行队列，其任务只能由主线程去完成。而`dispatch_sync `会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将`block`放在`main queue`中，等主线程执行完`block`中的代码后才释放主线程，然而主线程已被阻塞，无法执行`main queue`中的`block`，所以造成死锁。\n\n## 总结\n\n本文对线程做了一个简单的描述，在每个App都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级iOS文章，如有写得不好的地方，请各位斧正。\n\n","source":"_posts/对线程的简单理解.md","raw":"---\ntitle: 对线程的简单理解\ndate: 2017-03-14 16:57:48\ntags: \n- Thread\n---\n\n在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。\n\n<!--more-->\n\n## 什么是线程\n\n老生常谈，但还是先说一下概念：\n\n> *线程*，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  \n\n有两点需要注意：\n\n1. 线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈\n2. 共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。\n\n\n数据是否私有，如下表所示\n\n|     线程私有     |              线程间共享              |\n| :----------: | :-----------------------------: |\n| 局部变量<br>函数参数 | 全局变量<br>堆上的数据<br>函数内的静态变量<br>代码 |\n\n\n## 线程调度\n\n如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。\n\n但更经常地，我们可以看到类似这样的图：\n\n![Concurrency_vs_Parallelism](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png)\n\n上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为*线程调度*。\n\n在线程调度中，线程有三种状态：\n\n- 运行：拥有时间片，可以执行代码\n- 就绪：在等待队列中，随时可以被执行\n- 等待：等待IO或者因为其他原因被阻塞，等待结束后进入就绪状态\n\n三者的状态切换如下图所示：\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg)\n线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。\n\n轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了CPU让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：\n\n- 在我们的编程中，我们可以手动设置优先级，最常见的，如iOS中GDC的`global queue`:\n\n\n```Objc\n// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n```\n- 操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（**IO密集型线程**）通常只占用很少的时间，这种线程比用完时间片的线程（**CPU密集型线程**）更受欢迎，在操作系统的调度中优先级更容易被提高。\n- 在调度过程中，还存在*线程饿死(Starvation)* 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。\n\n## 线程安全\n\nQ : 为什么会有线程安全问题？\n\nA : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 `i` 执行 `i++`，线程A和线程B都各自拥有自己的寄存器，对`i++`这种操作，线程A先将`i`的值存放在线程的寄存器中，执行计算后再赋值回去给`i`这个变量，中间如果线程B在A赋值之前先获取到`i`的值，那么最后赋值的结果肯定不正确。这就是线程不安全。\n\nQ : 怎么保证线程安全？\n\nA : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。\n\n- 原子操作（Atomic）\n  原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。\n- 同步与锁\n  同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。\n\n### 锁\n\n同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。\n\n最简单的（关于锁的详细内容，不在本文的讨论范围内）：\n\n```objc\nNSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n```\n\n### 信号量\n\n信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如GCD中：\n\n```objc\n// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n```\n\n当信号量`semaphore`小于0时，线程会暂停执行，直到`semaphore`重新变成0。\n\n### 临界区\n\n临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。\n\n信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用`signal`或`wait`来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：\n\n```objc\n@synchronized(self) {\n\t// 临界区代码\n}\n```\n\n### 可重入(Reentrant)\n\n可重入的概念，适用于函数。\n\n首先了解一下什么是*函数被重入*：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。\n\n可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：\n\n```objc\n- (int)sqr:(int) x {\n\treturn x * x;\n}\n```\n\n保证可重入，需要保证以下几个方面：\n\n- 不使用静态或全局非const的变量\n- 不返还静态或全局非const变量的指针\n- 仅依赖入参\n- 不调用不可重入的函数\n\n## 线程和队列的关系\n\n线程和队列的关系，一直都纠缠不清。\n\n在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。\n\n举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。\n\n串行队列：它是有序的传输带，编号是SQ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者A拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到SQ上，那就要等待A吃完面包了，B分享的面包才会被消费。此时传输带SQ就被暂停了。\n\n并行队列：任务的执行时无需等待前面的任务执行完，编号是CQ，同样，我的面包吃不完，放到CQ上，A正在享用，此时B也将面包放在CQ上，但是A无法享用（因为正在享用我的），因此CQ就发出警鸣，叫来了消费者C来将B的面包吃掉，以维持CQ的继续运转，当A吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。\n\n## 死锁\n\n首先，概念：\n\n> *死锁* 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  \n\n死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。\n\n上述关于*死锁* 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个iOS应用开发者，我使用GCD来说明一下：\n\n```objc\n// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n```\n\n上述代码必将造成死锁，但是此例只涉及一个线程，那就是iOS App的主线程（亦称UI线程）。我们知道，在iOS中，`main queue`是串行队列，其任务只能由主线程去完成。而`dispatch_sync `会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将`block`放在`main queue`中，等主线程执行完`block`中的代码后才释放主线程，然而主线程已被阻塞，无法执行`main queue`中的`block`，所以造成死锁。\n\n## 总结\n\n本文对线程做了一个简单的描述，在每个App都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级iOS文章，如有写得不好的地方，请各位斧正。\n\n","slug":"对线程的简单理解","published":1,"updated":"2018-03-30T01:16:33.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xop000az4y8zsbt73d5","content":"<p>在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h2><p>老生常谈，但还是先说一下概念：</p>\n<blockquote>\n<p><em>线程</em>，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  </p>\n</blockquote>\n<p>有两点需要注意：</p>\n<ol>\n<li>线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈</li>\n<li>共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。</li>\n</ol>\n<p>数据是否私有，如下表所示</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">线程私有</th>\n<th style=\"text-align:center\">线程间共享</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">局部变量<br>函数参数</td>\n<td style=\"text-align:center\">全局变量<br>堆上的数据<br>函数内的静态变量<br>代码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><p>如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。</p>\n<p>但更经常地，我们可以看到类似这样的图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<p>上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为<em>线程调度</em>。</p>\n<p>在线程调度中，线程有三种状态：</p>\n<ul>\n<li>运行：拥有时间片，可以执行代码</li>\n<li>就绪：在等待队列中，随时可以被执行</li>\n<li>等待：等待IO或者因为其他原因被阻塞，等待结束后进入就绪状态</li>\n</ul>\n<p>三者的状态切换如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg\" alt=\"\"><br>线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。</p>\n<p>轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了CPU让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：</p>\n<ul>\n<li>在我们的编程中，我们可以手动设置优先级，最常见的，如iOS中GDC的<code>global queue</code>:</li>\n</ul>\n<pre><code class=\"Objc\">// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n</code></pre>\n<ul>\n<li>操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（<strong>IO密集型线程</strong>）通常只占用很少的时间，这种线程比用完时间片的线程（<strong>CPU密集型线程</strong>）更受欢迎，在操作系统的调度中优先级更容易被提高。</li>\n<li>在调度过程中，还存在<em>线程饿死(Starvation)</em> 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。</li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><p>Q : 为什么会有线程安全问题？</p>\n<p>A : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 <code>i</code> 执行 <code>i++</code>，线程A和线程B都各自拥有自己的寄存器，对<code>i++</code>这种操作，线程A先将<code>i</code>的值存放在线程的寄存器中，执行计算后再赋值回去给<code>i</code>这个变量，中间如果线程B在A赋值之前先获取到<code>i</code>的值，那么最后赋值的结果肯定不正确。这就是线程不安全。</p>\n<p>Q : 怎么保证线程安全？</p>\n<p>A : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。</p>\n<ul>\n<li>原子操作（Atomic）<br>原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。</li>\n<li>同步与锁<br>同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。</p>\n<p>最简单的（关于锁的详细内容，不在本文的讨论范围内）：</p>\n<pre><code class=\"objc\">NSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n</code></pre>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如GCD中：</p>\n<pre><code class=\"objc\">// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n</code></pre>\n<p>当信号量<code>semaphore</code>小于0时，线程会暂停执行，直到<code>semaphore</code>重新变成0。</p>\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。</p>\n<p>信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用<code>signal</code>或<code>wait</code>来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：</p>\n<pre><code class=\"objc\">@synchronized(self) {\n    // 临界区代码\n}\n</code></pre>\n<h3 id=\"可重入-Reentrant\"><a href=\"#可重入-Reentrant\" class=\"headerlink\" title=\"可重入(Reentrant)\"></a>可重入(Reentrant)</h3><p>可重入的概念，适用于函数。</p>\n<p>首先了解一下什么是<em>函数被重入</em>：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。</p>\n<p>可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：</p>\n<pre><code class=\"objc\">- (int)sqr:(int) x {\n    return x * x;\n}\n</code></pre>\n<p>保证可重入，需要保证以下几个方面：</p>\n<ul>\n<li>不使用静态或全局非const的变量</li>\n<li>不返还静态或全局非const变量的指针</li>\n<li>仅依赖入参</li>\n<li>不调用不可重入的函数</li>\n</ul>\n<h2 id=\"线程和队列的关系\"><a href=\"#线程和队列的关系\" class=\"headerlink\" title=\"线程和队列的关系\"></a>线程和队列的关系</h2><p>线程和队列的关系，一直都纠缠不清。</p>\n<p>在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。</p>\n<p>举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。</p>\n<p>串行队列：它是有序的传输带，编号是SQ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者A拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到SQ上，那就要等待A吃完面包了，B分享的面包才会被消费。此时传输带SQ就被暂停了。</p>\n<p>并行队列：任务的执行时无需等待前面的任务执行完，编号是CQ，同样，我的面包吃不完，放到CQ上，A正在享用，此时B也将面包放在CQ上，但是A无法享用（因为正在享用我的），因此CQ就发出警鸣，叫来了消费者C来将B的面包吃掉，以维持CQ的继续运转，当A吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>首先，概念：</p>\n<blockquote>\n<p><em>死锁</em> 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  </p>\n</blockquote>\n<p>死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。</p>\n<p>上述关于<em>死锁</em> 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个iOS应用开发者，我使用GCD来说明一下：</p>\n<pre><code class=\"objc\">// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n</code></pre>\n<p>上述代码必将造成死锁，但是此例只涉及一个线程，那就是iOS App的主线程（亦称UI线程）。我们知道，在iOS中，<code>main queue</code>是串行队列，其任务只能由主线程去完成。而<code>dispatch_sync</code>会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将<code>block</code>放在<code>main queue</code>中，等主线程执行完<code>block</code>中的代码后才释放主线程，然而主线程已被阻塞，无法执行<code>main queue</code>中的<code>block</code>，所以造成死锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文对线程做了一个简单的描述，在每个App都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级iOS文章，如有写得不好的地方，请各位斧正。</p>\n","excerpt":"<p>在软件系统中，随着一个程序被打开，意味着一个进程的启动和调度的开始。对于我们程序员来说，相对于进程，我们更关注粒度更小的线程，它是我们都需要与之打交道的用来实现多任务并发执行的利器。</p>","more":"<h2 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h2><p>老生常谈，但还是先说一下概念：</p>\n<blockquote>\n<p><em>线程</em>，又称轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源。  </p>\n</blockquote>\n<p>有两点需要注意：</p>\n<ol>\n<li>线程有私有的数据单元：仅仅可以让当前线程访问的寄存器和栈</li>\n<li>共享进程的内存空间：多个线程同时访问一个数据段或同时执行一块代码，就会有线程安全的问题出现。</li>\n</ol>\n<p>数据是否私有，如下表所示</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">线程私有</th>\n<th style=\"text-align:center\">线程间共享</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">局部变量<br>函数参数</td>\n<td style=\"text-align:center\">全局变量<br>堆上的数据<br>函数内的静态变量<br>代码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"线程调度\"><a href=\"#线程调度\" class=\"headerlink\" title=\"线程调度\"></a>线程调度</h2><p>如果线程数量小于等于处理器数量时，线程是真正意义的并发，不同的线程运行在不同的处理器上。这很理想。</p>\n<p>但更经常地，我们可以看到类似这样的图：</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/cjuwz.png\" alt=\"Concurrency_vs_Parallelism\"></p>\n<p>上图中并发的情况是针对线程数量大于处理器数量（多CPU或多核时代，处理器数量不止一个）的情况。学过计算机原理，我们都知道，这种“并发”是一种模拟出来的状态，快速的时间片切换让用户觉得像是同时在执行。这种时间片切换，称为<em>线程调度</em>。</p>\n<p>在线程调度中，线程有三种状态：</p>\n<ul>\n<li>运行：拥有时间片，可以执行代码</li>\n<li>就绪：在等待队列中，随时可以被执行</li>\n<li>等待：等待IO或者因为其他原因被阻塞，等待结束后进入就绪状态</li>\n</ul>\n<p>三者的状态切换如下图所示：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/eltyq.jpg\" alt=\"\"><br>线程有状态了，需要等待调度的发生，自然就涉及到轮换调度和优先级。</p>\n<p>轮换调度让各个线程轮流执行一小段时间后进入就绪状态或等待状态，而优先级则决定了CPU让处于就绪状态的哪个线程先执行。优先级改变有以下三种方式：</p>\n<ul>\n<li>在我们的编程中，我们可以手动设置优先级，最常见的，如iOS中GDC的<code>global queue</code>:</li>\n</ul>\n<pre><code class=\"Objc\">// 创建一个优先级为HIGH的全局队列\ndispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n</code></pre>\n<ul>\n<li>操作系统也是会根据场景来适当提高线程的优先级，让更多的线程可以执行。通常情况下，频繁等待的线程（<strong>IO密集型线程</strong>）通常只占用很少的时间，这种线程比用完时间片的线程（<strong>CPU密集型线程</strong>）更受欢迎，在操作系统的调度中优先级更容易被提高。</li>\n<li>在调度过程中，还存在<em>线程饿死(Starvation)</em> 的现象，就是优先级很低的线程一直得不到时间片。为了解决这一问题，操作系统会逐步提高这些线程的优先级。</li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><p>Q : 为什么会有线程安全问题？</p>\n<p>A : 如上所述，线程间有共享的数据：全局变量、堆上的数据、函数内的静态变量、代码等。两个线程同时修改一个全局变量，会导致修改后的结果不确定。如，两个线程同时对一个变量 <code>i</code> 执行 <code>i++</code>，线程A和线程B都各自拥有自己的寄存器，对<code>i++</code>这种操作，线程A先将<code>i</code>的值存放在线程的寄存器中，执行计算后再赋值回去给<code>i</code>这个变量，中间如果线程B在A赋值之前先获取到<code>i</code>的值，那么最后赋值的结果肯定不正确。这就是线程不安全。</p>\n<p>Q : 怎么保证线程安全？</p>\n<p>A : 保证数据或代码段在一段时间内只有一个线程在访问，方法有：原子操作、同步。</p>\n<ul>\n<li>原子操作（Atomic）<br>原子操作，简单点来说就是单条指令的执行。但仅适用于特定的场合，在复杂的场合下，比如我们要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了。</li>\n<li>同步与锁<br>同步也是一种保证线程安全的方式，是指在一个线程访问数据未结束的时候，其他线程不能对同一个数据进行访问。同步常见的有锁、信号量、临界区等。</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>同步最常见的操作就是锁，线程再访问数据之前视图获取锁，访问结束后释放锁。在获取锁时，如果锁被占用了，则线程会等待，直到锁重新可用。</p>\n<p>最简单的（关于锁的详细内容，不在本文的讨论范围内）：</p>\n<pre><code class=\"objc\">NSLock *theLock = [[NSLock alloc] init];\nif ([theLock lock]) {\n   // 需要同步的代码\n   [theLock unlock];\n}\n</code></pre>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量也可以用在同步方面，但是这里所说的是二元信号量，即只表示占用与非占用。例如GCD中：</p>\n<pre><code class=\"objc\">// 创建一个二元信号量，dispatch_semaphore_create的入参为0\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n// 使用wait让semaphore减1\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n// 使用signal让semaphore加1\ndispatch_semaphore_signal(semaphore);\n</code></pre>\n<p>当信号量<code>semaphore</code>小于0时，线程会暂停执行，直到<code>semaphore</code>重新变成0。</p>\n<h3 id=\"临界区\"><a href=\"#临界区\" class=\"headerlink\" title=\"临界区\"></a>临界区</h3><p>临界区更多的是指一个访问共用资源的代码块，而这些共用资源又无法同时被多个线程访问的特性。</p>\n<p>信号量，我们知道，在本线程创建，可以在其他线程被获取到并调用<code>signal</code>或<code>wait</code>来操作信号量。相对来说，临界区显得更加严格。本线程进入临界区，只有当退出临界区了，其他线程才能访问临界区的代码块。如下代码，相信大家肯定不陌生：</p>\n<pre><code class=\"objc\">@synchronized(self) {\n    // 临界区代码\n}\n</code></pre>\n<h3 id=\"可重入-Reentrant\"><a href=\"#可重入-Reentrant\" class=\"headerlink\" title=\"可重入(Reentrant)\"></a>可重入(Reentrant)</h3><p>可重入的概念，适用于函数。</p>\n<p>首先了解一下什么是<em>函数被重入</em>：一个函数被重入，表示这个函数没有执行完成，由于外部因素（多线程同时调用）或内部调用（递归函数），又一次进入了该函数。</p>\n<p>可重入函数也保证线程安全，因为该种函数被重入之后不会产生任何不良的后果，比如：</p>\n<pre><code class=\"objc\">- (int)sqr:(int) x {\n    return x * x;\n}\n</code></pre>\n<p>保证可重入，需要保证以下几个方面：</p>\n<ul>\n<li>不使用静态或全局非const的变量</li>\n<li>不返还静态或全局非const变量的指针</li>\n<li>仅依赖入参</li>\n<li>不调用不可重入的函数</li>\n</ul>\n<h2 id=\"线程和队列的关系\"><a href=\"#线程和队列的关系\" class=\"headerlink\" title=\"线程和队列的关系\"></a>线程和队列的关系</h2><p>线程和队列的关系，一直都纠缠不清。</p>\n<p>在开发中，我们会接触到两种队列，串行队列和并行队列，二者的区别是：串行队列中的任务是有序被执行的，并行队列中的任务是利用多线程并发执行，不能保证执行顺序。</p>\n<p>举个可能不太恰当的例子：线程是消费者，队列是传输纽带，任务是面包，线程执行任务，比作将面包吃掉。对于面包呢，我（当前线程）可以自己享用，也可以通过传输带给其他消费者享用（任务可以自己完成，也可以交由其他线程去完成）。</p>\n<p>串行队列：它是有序的传输带，编号是SQ，我的面包吃不完，所以我往上面放了一个面包，给其他人享用，此时有消费者A拿了，并开始吃。同时消费者B也想分享他的面包，他也把面包放到SQ上，那就要等待A吃完面包了，B分享的面包才会被消费。此时传输带SQ就被暂停了。</p>\n<p>并行队列：任务的执行时无需等待前面的任务执行完，编号是CQ，同样，我的面包吃不完，放到CQ上，A正在享用，此时B也将面包放在CQ上，但是A无法享用（因为正在享用我的），因此CQ就发出警鸣，叫来了消费者C来将B的面包吃掉，以维持CQ的继续运转，当A吃完后，还可以继续享用其他人分享的面包。所以，并行队列并不是一定会产生新的线程，如果有空闲的线程还是会被继续叫来执行任务，只是平时线程执行完就被销毁，所以队列在需要执行新任务的时候就给我们造成一个创建新线程的假象。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>首先，概念：</p>\n<blockquote>\n<p><em>死锁</em> 是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。  </p>\n</blockquote>\n<p>死锁不需要多说，相信学过计算机理论的同学都知道。多线程改善了系统资源的利用率和提高了系统的处理能力，多线程并发执行很有可能造成死锁，无外力作用的情况下，整个进程就无法继续推进。用户对程序内部的运作不知情，但看到界面毫无响应，怎么点击都没用，此时就会责怪应用的不完善。</p>\n<p>上述关于<em>死锁</em> 的概念来自百科，有一点我觉得要更正的是，死锁也有可能是由单一线程造成。作为一个iOS应用开发者，我使用GCD来说明一下：</p>\n<pre><code class=\"objc\">// 主线程中调用\ndispatch_sync(dispatch_get_main_queue(), ^{\n    // do something\n})\n</code></pre>\n<p>上述代码必将造成死锁，但是此例只涉及一个线程，那就是iOS App的主线程（亦称UI线程）。我们知道，在iOS中，<code>main queue</code>是串行队列，其任务只能由主线程去完成。而<code>dispatch_sync</code>会阻塞当前线程，因此，当上述代码用在主线程中调用时，主线程被会阻塞，然后将<code>block</code>放在<code>main queue</code>中，等主线程执行完<code>block</code>中的代码后才释放主线程，然而主线程已被阻塞，无法执行<code>main queue</code>中的<code>block</code>，所以造成死锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文对线程做了一个简单的描述，在每个App都涉及多线程开发的现在，需要注意线程安全的问题，通过原子操作、同步等方式可以保证。还讲述了串行队列和并行队列，最后浅浅地点了一下死锁的概念，算是一篇写给线程小白看的入门级iOS文章，如有写得不好的地方，请各位斧正。</p>"},{"title":"我有烦恼，你有答案","date":"2017-02-19T13:01:52.000Z","typora-copy-images-to":"ipic","_content":"\n被友人种草东野圭吾，拾取碎片时间，拜读了这本书。    \n怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。\n\n<!--more-->\n\n![jyzhd_bg](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png)\n\n正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。\n\n> 这里不只卖日常生活用品\n>\n> 还提供消烦解忧的谘询\n>\n> 困惑不安的你，纠结不安的你\n>\n> 欢迎来信讨论心中的问题\n\n小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。\n\n小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。\n\n小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。\n\n小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。\n\n时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。\n\n在终篇还是没有点明时空错乱的原因，但是这已经不重要了。\n\n最后你会发现：你的赞叹，你的感动，都是东野的本事...\n\n\n\n以上\n\n写于读完《解忧杂货店》的13小时后，广州，晴\n","source":"_posts/我有烦恼，你有答案.md","raw":"---\ntitle: 我有烦恼，你有答案\ndate: 2017-02-19 21:01:52\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n\n被友人种草东野圭吾，拾取碎片时间，拜读了这本书。    \n怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。\n\n<!--more-->\n\n![jyzhd_bg](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png)\n\n正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。\n\n> 这里不只卖日常生活用品\n>\n> 还提供消烦解忧的谘询\n>\n> 困惑不安的你，纠结不安的你\n>\n> 欢迎来信讨论心中的问题\n\n小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。\n\n小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。\n\n小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。\n\n小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。\n\n时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。\n\n在终篇还是没有点明时空错乱的原因，但是这已经不重要了。\n\n最后你会发现：你的赞叹，你的感动，都是东野的本事...\n\n\n\n以上\n\n写于读完《解忧杂货店》的13小时后，广州，晴\n","slug":"我有烦恼，你有答案","published":1,"updated":"2018-03-07T08:06:17.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xor000dz4y8zfhph87v","content":"<p>被友人种草东野圭吾，拾取碎片时间，拜读了这本书。<br>怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png\" alt=\"jyzhd_bg\"></p>\n<p>正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。</p>\n<blockquote>\n<p>这里不只卖日常生活用品</p>\n<p>还提供消烦解忧的谘询</p>\n<p>困惑不安的你，纠结不安的你</p>\n<p>欢迎来信讨论心中的问题</p>\n</blockquote>\n<p>小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。</p>\n<p>小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。</p>\n<p>小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。</p>\n<p>小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。</p>\n<p>时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。</p>\n<p>在终篇还是没有点明时空错乱的原因，但是这已经不重要了。</p>\n<p>最后你会发现：你的赞叹，你的感动，都是东野的本事…</p>\n<p>以上</p>\n<p>写于读完《解忧杂货店》的13小时后，广州，晴</p>\n","excerpt":"<p>被友人种草东野圭吾，拾取碎片时间，拜读了这本书。<br>怎么说呢，《解忧杂货店》那么多人宣扬还是有它的道理的。</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/kk1if.png\" alt=\"jyzhd_bg\"></p>\n<p>正如译者所言：他的作品并非只有谜团，只是卖弄诡计。一个更重要的元素，即他过人的说故事能力，以及有温度的文字书写。</p>\n<blockquote>\n<p>这里不只卖日常生活用品</p>\n<p>还提供消烦解忧的谘询</p>\n<p>困惑不安的你，纠结不安的你</p>\n<p>欢迎来信讨论心中的问题</p>\n</blockquote>\n<p>小说从三个盗窃的小偷开始，讲述他们在九月十三日误入荒废的“浪矢杂货店”，误打误撞开始帮助三十三年前的谘询者解决问题。到最后从盗来的皮包中发现了谘询者对自己帮助的感谢信。</p>\n<p>小说的五章讲的是五个不同的故事，但却彼此有着联系。在“照顾患病男友”和“完成两人梦想”之间犹豫的运动员，“追求音乐梦想”和“继承渔松家业”之间踌躇的年轻人，被男人抛弃谘询是否生下孩子的女人，喜欢披头四考虑是否应该跟负债的父母跑路的少年，想赚钱报答亲人的酒店女郎。不管是在人物之间还是境遇的串联，环环相扣，描写让人动容，平淡的语言中写的才是最真的情感。看完整本小说，能感受到其中的温暖和奇妙。</p>\n<p>小说围绕“浪矢杂货店”和“丸光园”两个特定的场所展开，到杂货店谘询的人都跟孤儿院，即丸光园有着一丝一缕的联系。小说的中间讲到丸光园时，你并不会知道这两处地方会有什么联系，但东野在最后告诉你：他们的主人曾经是一对恋人，虽然最后没有私奔成功，但是彼此深爱对方，默默在付出。</p>\n<p>小说以倒叙的方式开始讲述东野圭吾脑中天马行空的故事。前一晚在杂货店投入谘询的信件，第二天清晨会在店后的牛奶箱里得到真诚的回复。而信件却奇妙地在时空穿梭，三十三年后的九月十三号收到了三十三年前的信件，而放在牛奶箱的回信会被投递到三十三年前。三十三年后的浪矢杂货店跟外部的时空是错乱的，里面几天，外面可能只过了几秒。正因为一瞬间的交会，跨越三十年时空，才演变成一生一世的救赎。</p>\n<p>时空的跳转和人物的变换，让你会努力地去回忆故事的情节和人物设定，真正地去读书，而不是一目千行地浏览。东野能抓住大多数人都有烦恼都渴望得到帮助的心理，将各种人物的心理精妙地表达。而浪矢杂货店开在无名小镇的静僻的街道旁，旁敲侧击地指出有烦恼的想寻求帮助的人会尽量避开别人的眼光，这一点，也在小说中得到正面的证实。</p>\n<p>在终篇还是没有点明时空错乱的原因，但是这已经不重要了。</p>\n<p>最后你会发现：你的赞叹，你的感动，都是东野的本事…</p>\n<p>以上</p>\n<p>写于读完《解忧杂货店》的13小时后，广州，晴</p>"},{"title":"阿澤君的独白","date":"2016-04-02T03:37:39.000Z","typora-copy-images-to":"ipic","_content":"\n接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~\n\n<!--more-->\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg)\n　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。    \n　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。    \n　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。    \n　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。    \n　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>    \n　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！    \n　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。    \n　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。    \n　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。    \n曾经还发过朋友圈宣泄负能量\n![Dubai_piaoquan](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg)\n　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。    \n　　**最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。**但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：\n![Dubai_douzhi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg)\n　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。\n![Dubai_gongsi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg)\n　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。    \n　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>","source":"_posts/阿澤君的独白.md","raw":"---\ntitle: 阿澤君的独白\ndate: 2016-04-02 11:37:39\ntags: \n- Mood\ntypora-copy-images-to: ipic\n---\n\n接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~\n\n<!--more-->\n![](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg)\n　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。    \n　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。    \n　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。    \n　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。    \n　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>    \n　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！    \n　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。    \n　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。    \n　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。    \n曾经还发过朋友圈宣泄负能量\n![Dubai_piaoquan](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg)\n　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。    \n　　**最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。**但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：\n![Dubai_douzhi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg)\n　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。\n![Dubai_gongsi](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg)\n　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。    \n　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font>","slug":"阿澤君的独白","published":1,"updated":"2018-03-07T07:52:20.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xos000ez4y81g3ewzgw","content":"<p>接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg\" alt=\"\"><br>　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。<br>　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。<br>　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。<br>　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。<br>　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=\"#ff7073\" size=\"3\" face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font><br>　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！<br>　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。<br>　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。<br>　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。<br>曾经还发过朋友圈宣泄负能量<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg\" alt=\"Dubai_piaoquan\"><br>　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。<br>　　<strong>最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。</strong>但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg\" alt=\"Dubai_douzhi\"><br>　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg\" alt=\"Dubai_gongsi\"><br>　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。<br>　　最后，我想说：<font color=\"#ff7073\" size=\"3\" face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font></p>\n","excerpt":"<p>接近两个星期没有发博客了，可能是因为最近毕业季忙于东跑西跑找工作，加上毕业设计、论文等东西的烦扰。没什么自己可以支配的时间，所以这篇博文只是随便扯扯，发发牢骚，并没有干货~~</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/l44uf.jpg\" alt=\"\"><br>　　对于一个学iOS只有半年左右的人来说，我不知道自己是不是认真地在学，但是我知道自己对iOS是热枕的。。。<br>　　四年前，大学是多么憧憬的地方，我凭着不好不坏的成绩顺利被华南师范大学录取，算是广东不错的一本院校了。当其时因为爸爸妈妈都希望我能就读经济专业，以后从事经济方面的工作，而我自己从小就喜欢玩电脑，比较倾向于选择计算机类的吧。但是爸爸妈妈的要求那么坚定，所以我最后还是迷迷糊糊地将经济学摆在志愿第一项。若果你以为我是经济学的学生，那你就错了，哈哈哈哈。志愿第一项没有被录取，我被调剂到软件工程。家里人也没办法，只能任由我了。。<br>　　进入大学，感觉什么都是新的。不同的上课模式让我体会到新鲜感，一开始是很少逃课的（我是个好孩子😄😄）。爸爸妈妈希望我从事经济方面工作的想法还没有打消，他们希望我读多个学位，利用周末时间辅修，进一步加强自己。我没有拒绝，因为我自己也有点试试看的想法。所以在大一第一学期即将结束的时候递上了经济学的辅修申请表。<br>　　自从辅修了经济学，时间似乎追赶得更快了。我花费在本专业上的时间也被占据了相当一部分。辅修听回来的东西有一些还是很有趣的，但是绝大部分让我这个理科生感觉枯燥。很多科目都是考试前一两周疯狂复习。那些时候心里总会抱怨，觉得特别辛苦。四年说长不长，说短不短，但是我还是坚持了下来。直到最近赶完辅修论文，算是结束了辅修生涯，我才意识到，原来很多事情只要咬咬牙就过来了。你们说我怎么才意识到。。。<br>　　为什么要说辅修，我只是想说最后一句，为什么现在才意识到<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font><br>　　我想成为iOS开发者，学习iOS时间不长。其实一开始接触的是C、Cpp。可能这是大部分甚至是全部计算机专业同学都会学到的。因为接触的都是Console，不免让人觉得无聊吧。大一年少无知，不知道原来C、Cpp也是很牛逼的语言。当时对专业方向也没多大想法，处于迷茫期吧可能，谁的青春不迷茫呢？！<br>　　后来又一段时间，身边有几个同学在学iOS开发，但是电脑非果机。折腾安装个黑苹果都要两个星期，原因大家都知道，驱动难求、各种五国。。。我也想去尝试，因为iPhone的界面、UI等等确实看起来好看且用户体验也不错。我的iPhone4s陪我走到现在整整四年，还没换（没钱💔 + 有感情❤️）。所以我也加入了安装黑苹果的行列，我的电脑是Acer，当时默认是很好装黑苹果的机器，但是来来去去折腾了很久（具体忘了多久）都没有装成功。那时候就气馁了。。现在想起来真想扇自己巴掌，跳打再飞踢。。<br>　　我觉得自己很容易摇摆，很容易就跟着别人的脚步走。所以在接触到Java的时候就果断放弃了前者。Java是大二的一门课程，实验课也蛮多，所以学起来比较省心。后来也萌生了做后台的想法。大二下学期和大三上学期都在看关于J2EE的知识。大三下也出去实习过一段时间，辗辗转转发现自己真心不喜欢，说实在的，学习成本大，真的大。。而且很多时候出错信息十分冗长，很难看得下去。。<br>　　所以，我又作死地想回到iOS行列，因为我很喜欢看起来漂亮的事物。身为大四狗，转方向是非常危险且不理智的行为。但是我还是这样做了。这次花了两周时间成功装上了黑苹果，也意识到快毕业了，很多事情都不是自己想得那么简单。时间在背后追得很紧，有时候发发呆一天就TM地过去了。经常后悔之前没有坚持弄完黑苹果开始学习iOS，导致现在这么被动。。。<br>曾经还发过朋友圈宣泄负能量<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pkram.jpg\" alt=\"Dubai_piaoquan\"><br>　　错过了秋招，我把希望都放在了春招了，似乎一切都这么顺利，然而这只是我的幻想。面试了第一家公司感觉还行，可能是急需人，所以问题都很简单。工资不高，所以我也没有特别大的想法，所以还是拒绝了。接下来的其他公司的面试让我觉得简直就是地狱，也就是最近这段时间的事，每次挫败感都超级强，压得我喘不过气来。<br>　　<strong>最近经历的跌宕起伏确实是人生一段会经常想起来的经历，鞭笞自己变得更好，我总这样安慰自己。</strong>但是要感谢何君(づ￣ 3￣)づ（真名我才不说呢）给我的鼓励：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/8ooyk.jpg\" alt=\"Dubai_douzhi\"><br>　　很多时候都想放弃，但是自己深深知道不能。。。所以最近面试的这短短两周时间学到的东西比过去两个月还多，真的很多事情只要咬咬牙就过来了。现在也找到了毕业后栖身的公司，继续发展我的iOS开发事业。现在我有了更好的心态，不会好高骛远，还是脚踏实地吧。<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/e8so3.jpg\" alt=\"Dubai_gongsi\"><br>　　最近在听五月天的《勇敢》，为了那个将来，要自己，勇敢再勇敢。<br>　　最后，我想说：<font color=#ff7073 size=3 face=\"黑体\">很多事情只要咬咬牙就过来了！！！</font></p>"},{"title":"类方法的Block不会内存泄漏....吗？！","date":"2016-07-17T11:57:39.000Z","typora-copy-images-to":"ipic","_content":"\nBlock在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：    \n在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    \n\n<!--more-->\n　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。    \n　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。    \n　　\n　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！    \n　　**不是。**    \n　　**不是。**    \n　　**不是。**    \n\n## 举个栗子\n\n　　平常使用UIView的Animation之时，例如`[UIView animateWithDuration:animations:];`使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于`[UIView animateWithDuration: animations: completion:];`除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     \n\n\n``` objectivec\n- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];\t\t// 递归调用，再次执行此函数\n    }];\n}\n```\n\n　　别告诉我你没这样用过，科科。    \n\n　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    \n\n　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    \n\n1. 多次创建QRCodeScanner并销毁：\n   ![block_self](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg)    \n   QRCodeScanner被销毁后：\n   ![block_self2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg)     \n\n\n2. 将上述代码的self改成weakSelf，再来看看Instruments：\n   ![block_weakSelf](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg)     \n   QRCodeScanner被销毁后：\n   ![block_weakSelf2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg)     \n\n\n　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了`[self startAnimation];`因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(\n\n　　此文有点晦涩，附上[DEMO地址](https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo)\n\n\n## 总结\n\n1. 关于Block的内存泄漏不只是循环引用会引起。\n2. 不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上\\_\\_weak。你说，在Block被调用的时候self被释放了怎么办？！去看看\\_\\_strong的资料吧。\n3. ~~很多iOS的类方法传入的Block是\\_NSConcreteStackBlock，可见\\_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)~~确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：\n   1.手动调用copy    \n   2.Block是函数的返回值    \n   3.Block被强引用，Block被赋值给__strong或者id类型    \n   4.调用系统API入参中含有usingBlcok的方法    \n   系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。\n4. 关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题[Objective-C Blocks Quiz](http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/)\n\n","source":"_posts/类方法Block内存泄漏.md","raw":"---\ntitle: 类方法的Block不会内存泄漏....吗？！\ndate: 2016-7-17 19:57:39\ntags: \n- Block\ntypora-copy-images-to: ipic\n---\n\nBlock在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：    \n在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    \n\n<!--more-->\n　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。    \n　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。    \n　　\n　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！    \n　　**不是。**    \n　　**不是。**    \n　　**不是。**    \n\n## 举个栗子\n\n　　平常使用UIView的Animation之时，例如`[UIView animateWithDuration:animations:];`使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于`[UIView animateWithDuration: animations: completion:];`除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     \n\n\n``` objectivec\n- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];\t\t// 递归调用，再次执行此函数\n    }];\n}\n```\n\n　　别告诉我你没这样用过，科科。    \n\n　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    \n\n　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    \n\n1. 多次创建QRCodeScanner并销毁：\n   ![block_self](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg)    \n   QRCodeScanner被销毁后：\n   ![block_self2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg)     \n\n\n2. 将上述代码的self改成weakSelf，再来看看Instruments：\n   ![block_weakSelf](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg)     \n   QRCodeScanner被销毁后：\n   ![block_weakSelf2](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg)     \n\n\n　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了`[self startAnimation];`因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(\n\n　　此文有点晦涩，附上[DEMO地址](https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo)\n\n\n## 总结\n\n1. 关于Block的内存泄漏不只是循环引用会引起。\n2. 不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上\\_\\_weak。你说，在Block被调用的时候self被释放了怎么办？！去看看\\_\\_strong的资料吧。\n3. ~~很多iOS的类方法传入的Block是\\_NSConcreteStackBlock，可见\\_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)~~确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：\n   1.手动调用copy    \n   2.Block是函数的返回值    \n   3.Block被强引用，Block被赋值给__strong或者id类型    \n   4.调用系统API入参中含有usingBlcok的方法    \n   系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。\n4. 关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题[Objective-C Blocks Quiz](http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/)\n\n","slug":"类方法Block内存泄漏","published":1,"updated":"2018-03-07T08:05:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xot000gz4y80avuc72k","content":"<p>Block在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：<br>在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    </p>\n<a id=\"more\"></a>\n<p>　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。<br>　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。<br>　　<br>　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！<br>　　<strong>不是。</strong><br>　　<strong>不是。</strong><br>　　<strong>不是。</strong>    </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>　　平常使用UIView的Animation之时，例如<code>[UIView animateWithDuration:animations:];</code>使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于<code>[UIView animateWithDuration: animations: completion:];</code>除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     </p>\n<pre><code class=\"objectivec\">- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];        // 递归调用，再次执行此函数\n    }];\n}\n</code></pre>\n<p>　　别告诉我你没这样用过，科科。    </p>\n<p>　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    </p>\n<p>　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    </p>\n<ol>\n<li>多次创建QRCodeScanner并销毁：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg\" alt=\"block_self\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg\" alt=\"block_self2\">     </li>\n</ol>\n<ol>\n<li>将上述代码的self改成weakSelf，再来看看Instruments：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg\" alt=\"block_weakSelf\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg\" alt=\"block_weakSelf2\">     </li>\n</ol>\n<p>　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了<code>[self startAnimation];</code>因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(</p>\n<p>　　此文有点晦涩，附上<a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo\" target=\"_blank\" rel=\"external\">DEMO地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>关于Block的内存泄漏不只是循环引用会引起。</li>\n<li>不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上__weak。你说，在Block被调用的时候self被释放了怎么办？！去看看__strong的资料吧。</li>\n<li><del>很多iOS的类方法传入的Block是_NSConcreteStackBlock，可见_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)</del>确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：<br>1.手动调用copy<br>2.Block是函数的返回值<br>3.Block被强引用，Block被赋值给__strong或者id类型<br>4.调用系统API入参中含有usingBlcok的方法<br>系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。</li>\n<li>关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题<a href=\"http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/\" target=\"_blank\" rel=\"external\">Objective-C Blocks Quiz</a></li>\n</ol>\n","excerpt":"<p>Block在很多时候会引起循环引用，已经是老生常谈了。很多文章在讲述Block的时候都会谈及这个问题：<br>在一个对象中有着对Block的强引用，而在该Block中又保留着对该对象的强引用。循环引用所带来的后果相信大家也知道，有一个环存在，就意味着每次创建该对象，就会占据一定的内存不会被释放，等到内存不足以继续维持该App的存在时，就会Crash。    </p>","more":"<p>　　常见的解决方法是使用__weak或将有可能造成循环引用的对象作为Block的参数传入。<br>　　循环引用我不打算在此展开，因为有很多好的文章已经讲得很详细，大家可自行找找。<br>　　<br>　　很多文章提及：循环引用所针对的是对象，能够形成环的是“对象——Block——对象”。换种方式思考，类方法就不会造成相似的内存泄漏。真的是这样吗？！<br>　　<strong>不是。</strong><br>　　<strong>不是。</strong><br>　　<strong>不是。</strong>    </p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p>　　平常使用UIView的Animation之时，例如<code>[UIView animateWithDuration:animations:];</code>使用Block可以方便快捷地将设置需要变换的属性。对于类方法可以放心地写self而不必担心循环引用的问题。但是，对于<code>[UIView animateWithDuration: animations: completion:];</code>除了在动画结束时做一些操作外，当我们需要动画循环播放的时候，很常用的方法类似于：     </p>\n<pre><code class=\"objectivec\">- (void)startAnimation {\n    [UIView animateWithDuration:3.5 animations:^{\n        CGRect frame = self.initFrame;\n        frame.origin.y += 2 * self.initFrame.size.height;\n        self.frame = frame;\n    } completion:^(BOOL finished) {\n        self.frame = self.initFrame;\n        [self startAnimation];        // 递归调用，再次执行此函数\n    }];\n}\n</code></pre>\n<p>　　别告诉我你没这样用过，科科。    </p>\n<p>　　如果你也像我这么写，可能已经埋下了潜在的内存泄漏的危险。    </p>\n<p>　　我们通过Instruments来看看是否真的有内存泄漏(例子中EZScanNetGrid是我自定义的View,View中有执行动画的代码，见上方代码块，QRCodeScanner是对应的Controller)：    </p>\n<ol>\n<li>多次创建QRCodeScanner并销毁：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/g3gqy.jpg\" alt=\"block_self\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/97ewo.jpg\" alt=\"block_self2\">     </li>\n</ol>\n<ol>\n<li>将上述代码的self改成weakSelf，再来看看Instruments：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/jnbwl.jpg\" alt=\"block_weakSelf\"><br>QRCodeScanner被销毁后：<br><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/p1pae.jpg\" alt=\"block_weakSelf2\">     </li>\n</ol>\n<p>　　结果很明显，若是使用self，EZScanNetGrid这个View一直存在于内存中没有被释放，因为UIView Animation对其的强引用使其一直存在于内存中，直至Block里面的代码执行完毕。但是这段代码里可以看到，completion中又继续调用了<code>[self startAnimation];</code>因此，系统会继续保留对EZScanNetGrid的引用，从而即使EZScanNetGrid的SuperView被销毁了，EZScanNetGrid还是没有被销毁，无限地循环调用着动画，占据内存的同时也耗费着CPU。:(</p>\n<p>　　此文有点晦涩，附上<a href=\"https://github.com/objchris/ChrisDerDemos/tree/master/ClassBlockDemo\">DEMO地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>关于Block的内存泄漏不只是循环引用会引起。</li>\n<li>不仅仅是UIView，其他将Block作为参数的类方法，如果在一个Block中递归调用到本Block，记得将引用的对象加上__weak。你说，在Block被调用的时候self被释放了怎么办？！去看看__strong的资料吧。</li>\n<li><del>很多iOS的类方法传入的Block是_NSConcreteStackBlock，可见_NSConcreteStackBlock也会对Block中的对象保持强引用。(待考究)</del>确实，没有强指针引用的block都是StackBlock，表面看起来系统API传入的Block都是StackBlock，但是以下四种情况：<br>1.手动调用copy<br>2.Block是函数的返回值<br>3.Block被强引用，Block被赋值给__strong或者id类型<br>4.调用系统API入参中含有usingBlcok的方法<br>系统都会默认调用copy方法把Block复制到堆中，变成MallocBlock，会对对象进行持有。</li>\n<li>关于ARC和MRC下的三种Block是否能执行，请做做这几道测试题<a href=\"http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/\">Objective-C Blocks Quiz</a></li>\n</ol>"},{"title":"《Beauty》项目小总结","date":"2017-07-17T12:48:15.000Z","id":"FCDAE83256354451","typora-copy-images-to":"ipic","_content":"\n三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    \n\n<!--more-->\n\n2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(\n\n## 所做的事情\n\n总的来说，有这么几个功能：\n\n- 用户端：\n\n  1. 通过Google地图查看当前附近且在线的技师\n\n  2. 添加信用卡等信息，使用Paypal支付\n\n  3. 查看、修改个人信息\n\n  4. 发布公共订单给每个美容技师，技师可以通过竞标得到订单\n\n  5. 查看技师信息，收藏喜爱的技师\n\n  6. 发布私有订单给特定技师\n\n  7. 订单结束评价，打分等\n\n  8. 提供其他用户和技师的电话联系方式\n\n- 技师端：\n\n  1. 竞标用户的公共订单    \n\n  2. 接受或拒绝用户的私有订单\n\n  3. 添加银行卡，得到订单报酬\n\n  4. 查看、修改个人信息，查看收入数据，\n\n  5. 提交封面图片，作品图片\n\n  6. 增删改查服务信息、价格\n\n     ​\n\n## 一些具体实现\n\n　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：\n\n### 项目文件结构\n\n![Beauty_项目大致结构](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png)\n\n　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    \n\n　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的>w<）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      \n\n　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     \n\n\n\n### 地图\n\n![Beauty_Google地图_小](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg)\n\n　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     \n\n\n\n### 左侧滑动菜单\n\n![Beauty_左边栏](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg)\n\n　　图片好像压缩得有点过分了....\n\n　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了...\n\n　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神[《iOS开发进阶》](https://book.douban.com/subject/26287173/)一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：\n\n```objective-c\n- (void)viewDidLoad {\n\t_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t_window.windowLevel = UIWindowLevelNormal;\n\t_window.backgroundColor = [UIColor clearColor];\n\t_window.hidden = YES;\n\tBECDrawerView *view = [BECDrawerView new];\n\t//省略对view的一些初始化代码\n\t_leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n\t_leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n\t_leftView = view;\n\t//一开始先把leftView隐藏\n\t_leftHidden = YES;\n\t_leftView.hidden = _leftHidden;\n\t[_window addSubview:_leftView];\n    \n\tUIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n\tedgeGesture.delegate = self;\n\tedgeGesture.edges = UIRectEdgeLeft;\n\t[self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x > 0 && panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];\t//添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n    \n    _leftHidden = !_leftHidden;\n    \n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@\"removed\");\n        self.navigationController.navigationBar.hidden = NO;\n    }\n    \n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n    \n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@\"%@\",self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n    \n}\n```\n\n\n\n### CHARMER PROFILE\n\n![Beauty_CollectionView](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg)\n\n　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：\n\n1. 最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件[EZRecycleImageView](https://github.com/objchris/EZRecycleImageView)，在开发中边使用边改进是最好不过的事情了。\n2. 第二个Header是技师信息和三个按钮\n3. 最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。\n\n　　View里面嵌入View的复杂结构也是很值得掌握的手法~\n\n\n\n　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     \n\n　　最后附上使用的第三方库：\n\n```\nplatform :ios, \"8.0\"\ntarget :Beauty do\npod 'SVProgressHUD', '~> 2.0.3'\npod 'Masonry', '~> 1.0.2'\npod 'AFNetworking', '~> 3.0'\npod 'SDWebImage', '~>3.8'\npod 'YYModel'\npod 'IQKeyboardManager'\npod 'GoogleMaps'\npod 'MJRefresh'\npod \"MWPhotoBrowser\"\npod 'JPush'\npod 'PayPal-iOS-SDK'\n\nend\n```\n\n\n\n\n\n## 总结与反思\n\n- 好的方面：\n\n  1. 一位好Partner，一位一起奋斗的好朋友。\n\n  2. 很多UI控件和底层实现都接触到了，加深了印象。\n\n  3. 真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。\n\n  4. 积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。\n\n- 不好的方面：\n\n  1. 首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。\n\n  2. 其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。\n\n  3. 客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。\n\n\n","source":"_posts/项目Beauty总结.md","raw":"---\ntitle: 《Beauty》项目小总结\ndate: 2017-07-17 20:48:15\nid: FCDAE83256354451\ntags: \n- Summary\ntypora-copy-images-to: ipic\n---\n\n三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    \n\n<!--more-->\n\n2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(\n\n## 所做的事情\n\n总的来说，有这么几个功能：\n\n- 用户端：\n\n  1. 通过Google地图查看当前附近且在线的技师\n\n  2. 添加信用卡等信息，使用Paypal支付\n\n  3. 查看、修改个人信息\n\n  4. 发布公共订单给每个美容技师，技师可以通过竞标得到订单\n\n  5. 查看技师信息，收藏喜爱的技师\n\n  6. 发布私有订单给特定技师\n\n  7. 订单结束评价，打分等\n\n  8. 提供其他用户和技师的电话联系方式\n\n- 技师端：\n\n  1. 竞标用户的公共订单    \n\n  2. 接受或拒绝用户的私有订单\n\n  3. 添加银行卡，得到订单报酬\n\n  4. 查看、修改个人信息，查看收入数据，\n\n  5. 提交封面图片，作品图片\n\n  6. 增删改查服务信息、价格\n\n     ​\n\n## 一些具体实现\n\n　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：\n\n### 项目文件结构\n\n![Beauty_项目大致结构](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png)\n\n　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    \n\n　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的>w<）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      \n\n　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     \n\n\n\n### 地图\n\n![Beauty_Google地图_小](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg)\n\n　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     \n\n\n\n### 左侧滑动菜单\n\n![Beauty_左边栏](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg)\n\n　　图片好像压缩得有点过分了....\n\n　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了...\n\n　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神[《iOS开发进阶》](https://book.douban.com/subject/26287173/)一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：\n\n```objective-c\n- (void)viewDidLoad {\n\t_window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n\t_window.windowLevel = UIWindowLevelNormal;\n\t_window.backgroundColor = [UIColor clearColor];\n\t_window.hidden = YES;\n\tBECDrawerView *view = [BECDrawerView new];\n\t//省略对view的一些初始化代码\n\t_leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n\t_leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n\t_leftView = view;\n\t//一开始先把leftView隐藏\n\t_leftHidden = YES;\n\t_leftView.hidden = _leftHidden;\n\t[_window addSubview:_leftView];\n    \n\tUIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n\tedgeGesture.delegate = self;\n\tedgeGesture.edges = UIRectEdgeLeft;\n\t[self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x > 0 && panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];\t//添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n    \n    _leftHidden = !_leftHidden;\n    \n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@\"removed\");\n        self.navigationController.navigationBar.hidden = NO;\n    }\n    \n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n    \n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@\"%@\",self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n    \n}\n```\n\n\n\n### CHARMER PROFILE\n\n![Beauty_CollectionView](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg)\n\n　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：\n\n1. 最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件[EZRecycleImageView](https://github.com/objchris/EZRecycleImageView)，在开发中边使用边改进是最好不过的事情了。\n2. 第二个Header是技师信息和三个按钮\n3. 最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。\n\n　　View里面嵌入View的复杂结构也是很值得掌握的手法~\n\n\n\n　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     \n\n　　最后附上使用的第三方库：\n\n```\nplatform :ios, \"8.0\"\ntarget :Beauty do\npod 'SVProgressHUD', '~> 2.0.3'\npod 'Masonry', '~> 1.0.2'\npod 'AFNetworking', '~> 3.0'\npod 'SDWebImage', '~>3.8'\npod 'YYModel'\npod 'IQKeyboardManager'\npod 'GoogleMaps'\npod 'MJRefresh'\npod \"MWPhotoBrowser\"\npod 'JPush'\npod 'PayPal-iOS-SDK'\n\nend\n```\n\n\n\n\n\n## 总结与反思\n\n- 好的方面：\n\n  1. 一位好Partner，一位一起奋斗的好朋友。\n\n  2. 很多UI控件和底层实现都接触到了，加深了印象。\n\n  3. 真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。\n\n  4. 积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。\n\n- 不好的方面：\n\n  1. 首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。\n\n  2. 其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。\n\n  3. 客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。\n\n\n","slug":"项目Beauty总结","published":1,"updated":"2018-03-15T01:32:27.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xou000iz4y8z3x7wqi6","content":"<p>三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    </p>\n<a id=\"more\"></a>\n<p>2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(</p>\n<h2 id=\"所做的事情\"><a href=\"#所做的事情\" class=\"headerlink\" title=\"所做的事情\"></a>所做的事情</h2><p>总的来说，有这么几个功能：</p>\n<ul>\n<li><p>用户端：</p>\n<ol>\n<li><p>通过Google地图查看当前附近且在线的技师</p>\n</li>\n<li><p>添加信用卡等信息，使用Paypal支付</p>\n</li>\n<li><p>查看、修改个人信息</p>\n</li>\n<li><p>发布公共订单给每个美容技师，技师可以通过竞标得到订单</p>\n</li>\n<li><p>查看技师信息，收藏喜爱的技师</p>\n</li>\n<li><p>发布私有订单给特定技师</p>\n</li>\n<li><p>订单结束评价，打分等</p>\n</li>\n<li><p>提供其他用户和技师的电话联系方式</p>\n</li>\n</ol>\n</li>\n<li><p>技师端：</p>\n<ol>\n<li><p>竞标用户的公共订单    </p>\n</li>\n<li><p>接受或拒绝用户的私有订单</p>\n</li>\n<li><p>添加银行卡，得到订单报酬</p>\n</li>\n<li><p>查看、修改个人信息，查看收入数据，</p>\n</li>\n<li><p>提交封面图片，作品图片</p>\n</li>\n<li><p>增删改查服务信息、价格</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一些具体实现\"><a href=\"#一些具体实现\" class=\"headerlink\" title=\"一些具体实现\"></a>一些具体实现</h2><p>　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：</p>\n<h3 id=\"项目文件结构\"><a href=\"#项目文件结构\" class=\"headerlink\" title=\"项目文件结构\"></a>项目文件结构</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png\" alt=\"Beauty_项目大致结构\"></p>\n<p>　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    </p>\n<p>　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的&gt;w&lt;）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      </p>\n<p>　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     </p>\n<h3 id=\"地图\"><a href=\"#地图\" class=\"headerlink\" title=\"地图\"></a>地图</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg\" alt=\"Beauty_Google地图_小\"></p>\n<p>　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     </p>\n<h3 id=\"左侧滑动菜单\"><a href=\"#左侧滑动菜单\" class=\"headerlink\" title=\"左侧滑动菜单\"></a>左侧滑动菜单</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg\" alt=\"Beauty_左边栏\"></p>\n<p>　　图片好像压缩得有点过分了….</p>\n<p>　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了…</p>\n<p>　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神<a href=\"https://book.douban.com/subject/26287173/\" target=\"_blank\" rel=\"external\">《iOS开发进阶》</a>一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：</p>\n<pre><code class=\"objective-c\">- (void)viewDidLoad {\n    _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    _window.windowLevel = UIWindowLevelNormal;\n    _window.backgroundColor = [UIColor clearColor];\n    _window.hidden = YES;\n    BECDrawerView *view = [BECDrawerView new];\n    //省略对view的一些初始化代码\n    _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n    _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n    _leftView = view;\n    //一开始先把leftView隐藏\n    _leftHidden = YES;\n    _leftView.hidden = _leftHidden;\n    [_window addSubview:_leftView];\n\n    UIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n    edgeGesture.delegate = self;\n    edgeGesture.edges = UIRectEdgeLeft;\n    [self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x &gt; 0 &amp;&amp; panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];    //添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n\n    _leftHidden = !_leftHidden;\n\n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@&quot;removed&quot;);\n        self.navigationController.navigationBar.hidden = NO;\n    }\n\n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n\n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@&quot;%@&quot;,self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n\n}\n</code></pre>\n<h3 id=\"CHARMER-PROFILE\"><a href=\"#CHARMER-PROFILE\" class=\"headerlink\" title=\"CHARMER PROFILE\"></a>CHARMER PROFILE</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg\" alt=\"Beauty_CollectionView\"></p>\n<p>　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：</p>\n<ol>\n<li>最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件<a href=\"https://github.com/objchris/EZRecycleImageView\" target=\"_blank\" rel=\"external\">EZRecycleImageView</a>，在开发中边使用边改进是最好不过的事情了。</li>\n<li>第二个Header是技师信息和三个按钮</li>\n<li>最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。</li>\n</ol>\n<p>　　View里面嵌入View的复杂结构也是很值得掌握的手法~</p>\n<p>　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     </p>\n<p>　　最后附上使用的第三方库：</p>\n<pre><code>platform :ios, &quot;8.0&quot;\ntarget :Beauty do\npod &#39;SVProgressHUD&#39;, &#39;~&gt; 2.0.3&#39;\npod &#39;Masonry&#39;, &#39;~&gt; 1.0.2&#39;\npod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39;\npod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;\npod &#39;YYModel&#39;\npod &#39;IQKeyboardManager&#39;\npod &#39;GoogleMaps&#39;\npod &#39;MJRefresh&#39;\npod &quot;MWPhotoBrowser&quot;\npod &#39;JPush&#39;\npod &#39;PayPal-iOS-SDK&#39;\n\nend\n</code></pre><h2 id=\"总结与反思\"><a href=\"#总结与反思\" class=\"headerlink\" title=\"总结与反思\"></a>总结与反思</h2><ul>\n<li><p>好的方面：</p>\n<ol>\n<li><p>一位好Partner，一位一起奋斗的好朋友。</p>\n</li>\n<li><p>很多UI控件和底层实现都接触到了，加深了印象。</p>\n</li>\n<li><p>真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。</p>\n</li>\n<li><p>积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。</p>\n</li>\n</ol>\n</li>\n<li><p>不好的方面：</p>\n<ol>\n<li><p>首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。</p>\n</li>\n<li><p>其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。</p>\n</li>\n<li><p>客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。</p>\n</li>\n</ol>\n</li>\n</ul>\n","excerpt":"<p>三月底开始了自己的第一个外包项目“Beauty”，App的名字是“CHARMER”，是一个促进美容技师和客户之间达成服务协议的App，搭建供求双方沟通和交易的桥梁和平台。在做完第一版之后，几乎每晚都需要修改功能修复Bug，现在突然间一段时间没有了消息，应该算是完结了。    </p>","more":"<p>2017-10-12 更: 项目运营烂尾，最后好像没有上架，难过ing… :(</p>\n<h2 id=\"所做的事情\"><a href=\"#所做的事情\" class=\"headerlink\" title=\"所做的事情\"></a>所做的事情</h2><p>总的来说，有这么几个功能：</p>\n<ul>\n<li><p>用户端：</p>\n<ol>\n<li><p>通过Google地图查看当前附近且在线的技师</p>\n</li>\n<li><p>添加信用卡等信息，使用Paypal支付</p>\n</li>\n<li><p>查看、修改个人信息</p>\n</li>\n<li><p>发布公共订单给每个美容技师，技师可以通过竞标得到订单</p>\n</li>\n<li><p>查看技师信息，收藏喜爱的技师</p>\n</li>\n<li><p>发布私有订单给特定技师</p>\n</li>\n<li><p>订单结束评价，打分等</p>\n</li>\n<li><p>提供其他用户和技师的电话联系方式</p>\n</li>\n</ol>\n</li>\n<li><p>技师端：</p>\n<ol>\n<li><p>竞标用户的公共订单    </p>\n</li>\n<li><p>接受或拒绝用户的私有订单</p>\n</li>\n<li><p>添加银行卡，得到订单报酬</p>\n</li>\n<li><p>查看、修改个人信息，查看收入数据，</p>\n</li>\n<li><p>提交封面图片，作品图片</p>\n</li>\n<li><p>增删改查服务信息、价格</p>\n<p>​</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"一些具体实现\"><a href=\"#一些具体实现\" class=\"headerlink\" title=\"一些具体实现\"></a>一些具体实现</h2><p>　　基本实现下来都不是特别难，所以挑一些值得记录的写下来：</p>\n<h3 id=\"项目文件结构\"><a href=\"#项目文件结构\" class=\"headerlink\" title=\"项目文件结构\"></a>项目文件结构</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/yjc6f.png\" alt=\"Beauty_项目大致结构\"></p>\n<p>　　因为App是用户与技师统一客户端，所以，对于每个Module，都分成Charmer和User分别对应技师和用户，再在其下分为Model、View、Controller，很常见的MVC架构。    </p>\n<p>　　这样做的好处是，文件结构清晰，分类清楚，一下子就能找到需要的文件（虽然搜索才是最快的&gt;w&lt;）。但是有个问题就出现了，前面有提到说：用户与技师统一客户端，那就不免有界面相同的情况出现，这次开发使用的解决方案是复用所有相同的文件，这个错误的决定让后期维护的我一直想狠扇自己嘴巴。毕竟面向不同的使用团体，很多功能需要定制，所以后期加新需求的时候只能一直if-else，if-else，if-else。惨绝人寰～      </p>\n<p>　　觉得，以后再有这样的情况出现，视类的复杂程度和文件的大小而定， 可能会重写一个同样实现的类文件，感觉这条线很难界定，只能靠以后的开发经验去慢慢学。     </p>\n<h3 id=\"地图\"><a href=\"#地图\" class=\"headerlink\" title=\"地图\"></a>地图</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/m8ev4.jpg\" alt=\"Beauty_Google地图_小\"></p>\n<p>　　因为App即将在香港上线，自然地使用Google地图。第一次用Google地图做开发，感觉跟百度、高德没有太大的区别， 有一点就是：文档基本只有官方文档，遇到问题要Google，基本都是讲百度或高德。关于Google地图，后面再重新写篇文章介绍，包括使用，自定义Marker（地图上紫色的标志），PopView（点击Marker弹出的View）     </p>\n<h3 id=\"左侧滑动菜单\"><a href=\"#左侧滑动菜单\" class=\"headerlink\" title=\"左侧滑动菜单\"></a>左侧滑动菜单</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1h42p.jpg\" alt=\"Beauty_左边栏\"></p>\n<p>　　图片好像压缩得有点过分了….</p>\n<p>　　一开始左侧滑动菜单是主界面Controller的一个View，所以滑动的时候会被上方的Navigation Controller（Navigation Bar）遮挡住，可以想象是多么吃藕。后来在滑动的时候动态隐藏和显示Navigation Bar，就出现了诡异的上面一整条高度为64px的空白区域，发现更吃藕了…</p>\n<p>　　所以在AlertController的启发下，决定用UIWindow来解决这个问题，正如巧神<a href=\"https://book.douban.com/subject/26287173/\">《iOS开发进阶》</a>一书的第十二章提及，使用UIWindow在所有View（当然包括当前Window的Navigation Bar）前展示自己想要的内容，所以有了下面的代码：</p>\n<pre><code class=\"objective-c\">- (void)viewDidLoad {\n    _window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    _window.windowLevel = UIWindowLevelNormal;\n    _window.backgroundColor = [UIColor clearColor];\n    _window.hidden = YES;\n    BECDrawerView *view = [BECDrawerView new];\n    //省略对view的一些初始化代码\n    _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n    _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n    _leftView = view;\n    //一开始先把leftView隐藏\n    _leftHidden = YES;\n    _leftView.hidden = _leftHidden;\n    [_window addSubview:_leftView];\n\n    UIScreenEdgePanGestureRecognizer *edgeGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleRightPanGesture:)];\n    edgeGesture.delegate = self;\n    edgeGesture.edges = UIRectEdgeLeft;\n    [self.view addGestureRecognizer:edgeGesture];\n}\n\n// 手势事件\n- (void)handleRightPanGesture:(UIPanGestureRecognizer *)panGesture\n{\n    CGPoint translation = [panGesture translationInView:_window];\n    if (translation.x &gt; 0 &amp;&amp; panGesture.state == UIGestureRecognizerStateEnded) {\n        [self popLeft];\n    }\n}\n\n// 此函数用于弹出左侧滑动菜单\n- (void)popLeft\n{\n    [self addLeftGestures];    //添加滑动手势，这里代码就不贴出了\n    [_window makeKeyWindow];\n    _window.hidden = NO;\n    [_window bringSubviewToFront:_leftView];\n\n    _leftHidden = !_leftHidden;\n\n    if (_leftHidden == YES) {\n        [self removeLeftGestures];\n        [_popview removeFromSuperview];\n        NSLog(@&quot;removed&quot;);\n        self.navigationController.navigationBar.hidden = NO;\n    }\n\n    else {\n        if (!_popview) {\n            self.popview = [UIView new];\n            _popview.backgroundColor = [UIColor clearColor];\n            _popview.frame = _window.frame;\n            [_window addSubview:_popview];\n            [_window insertSubview:_popview belowSubview:_leftView];\n        }\n        _popview.hidden = NO;\n        [_window addSubview:_popview];\n        [_window insertSubview:_popview belowSubview:_leftView];\n    }\n\n    CATransition *animation = [CATransition animation];\n    if (_leftHidden == NO) {\n        _leftView.frame = CGRectMake(0, 0, MYScreenWidth * 0.8, MYScreenHeight);\n        animation.type = kCATransitionMoveIn; // 动画过渡类型\n        animation.subtype = kCATransitionFromLeft; // 动画过渡方向\n        _leftView.hidden = NO;\n    }else{\n        _leftView.center = CGPointMake(- MYScreenWidth * 0.4, _leftView.center.y);\n        animation.type = kCATransitionPush;\n        animation.subtype = kCATransitionFromRight; //动画过渡方向\n        _leftView.hidden = YES;\n        NSLog(@&quot;%@&quot;,self.navigationController.navigationBar);\n    }\n    animation.duration = 0.3; // 动画持续0.3s\n    // 代理，动画执行完毕后会调用delegate的animationDidStop:finished:\n    animation.delegate = self;\n    [_leftView.layer addAnimation:animation forKey:nil];\n\n}\n</code></pre>\n<h3 id=\"CHARMER-PROFILE\"><a href=\"#CHARMER-PROFILE\" class=\"headerlink\" title=\"CHARMER PROFILE\"></a>CHARMER PROFILE</h3><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/f7cwa.jpg\" alt=\"Beauty_CollectionView\"></p>\n<p>　　技师Profile页面，为什么会拿出来写？！是因为Conllection Viewz在日常开发中非常非常非常常见。基本每个App都会用到（TableView是特殊的Conllection View）。这个Collection View分为三部分：</p>\n<ol>\n<li>最上方的HeaderView是一个跑马灯，使用了之前写过的一个小组件<a href=\"https://github.com/objchris/EZRecycleImageView\">EZRecycleImageView</a>，在开发中边使用边改进是最好不过的事情了。</li>\n<li>第二个Header是技师信息和三个按钮</li>\n<li>最后是最下面的View，三个按钮分别对应不同的内容，第一二个使用的是CollectionView，即在CollectionView中再嵌入CollectionView；最后一个是TableView，即在CollectionView中再嵌入CollectionView。</li>\n</ol>\n<p>　　View里面嵌入View的复杂结构也是很值得掌握的手法~</p>\n<p>　　还有很多开发过程中的代码和解决方案，因为是别人的项目，非开源，就不一一列出啦~但是我还是信仰Open Sourcede der~~     </p>\n<p>　　最后附上使用的第三方库：</p>\n<pre><code>platform :ios, &quot;8.0&quot;\ntarget :Beauty do\npod &#39;SVProgressHUD&#39;, &#39;~&gt; 2.0.3&#39;\npod &#39;Masonry&#39;, &#39;~&gt; 1.0.2&#39;\npod &#39;AFNetworking&#39;, &#39;~&gt; 3.0&#39;\npod &#39;SDWebImage&#39;, &#39;~&gt;3.8&#39;\npod &#39;YYModel&#39;\npod &#39;IQKeyboardManager&#39;\npod &#39;GoogleMaps&#39;\npod &#39;MJRefresh&#39;\npod &quot;MWPhotoBrowser&quot;\npod &#39;JPush&#39;\npod &#39;PayPal-iOS-SDK&#39;\n\nend\n</code></pre><h2 id=\"总结与反思\"><a href=\"#总结与反思\" class=\"headerlink\" title=\"总结与反思\"></a>总结与反思</h2><ul>\n<li><p>好的方面：</p>\n<ol>\n<li><p>一位好Partner，一位一起奋斗的好朋友。</p>\n</li>\n<li><p>很多UI控件和底层实现都接触到了，加深了印象。</p>\n</li>\n<li><p>真正接触并使用到优秀的第三方框架，以后在开发过程中如果遇到适用的情况就不会因为无知而重复造轮子（可能还造不好….）。</p>\n</li>\n<li><p>积累了经验，这个App算是自己一个比较完整开发的App。整个开发流程虽然没有公司项目那么正规，但是一些相关的文档、说明还是不缺的。</p>\n</li>\n</ol>\n</li>\n<li><p>不好的方面：</p>\n<ol>\n<li><p>首先在架构上没有考虑好，这个其实也不是可控的。一开始拿到的项目结构已经定好，没办法更改，且时间也紧，无法推翻之前写过的代码重新思考和重建。</p>\n</li>\n<li><p>其次，在和Partner之间的沟通自我觉得不足，我的被动是我这次开发体验一般的重大引子。感觉自己做得不好，有点对不起自己的Partner。</p>\n</li>\n<li><p>客户的有些需求异常反人类，所以很多时候我的意见不能得到很好的反馈和解决。需求经常改动，且我的Partner才是和客户沟通的中间者，不能直面客户我很苦恼。</p>\n</li>\n</ol>\n</li>\n</ul>"},{"title":"简简单单说说PKI On iOS","date":"2016-04-09T12:16:05.000Z","typora-copy-images-to":"ipic","_content":"\n\nHacker,问你惊未Σ( ° △ °|||)︴\n\n<!--more-->\n\n![Crypto_Sherlock](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg) \n\n\n看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··   \n​    \n今天来聊聊阿澤君的故事，顺便谈谈\n\n1. CommonCryto中关于DES、AES的部分内容\n2. iOS的Security框架里关于RSA加密的部分内容....\n\n阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    \n\n![focusOnCom](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg)    \n\n很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。\n\n![bucuowo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg)\n\n\n# 对称加密    \n\n采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。\n\n## DES\nDES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    \n\n![Crypto_DES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg)\n\n### 3DES\n\n3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：  \n3DES加密过程为：C=Ek3(Dk2(Ek1(P)))    \n3DES解密过程为：P=Dk1(EK2(Dk3(C)))    \n若**Ek1 == Ek2 == Ek3**，就是简单的DES了。\n\n## AES\n![Crypto_AES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png)    \n图片来自网络，若有侵犯到权利之处，请告知，谢谢~    \n\nAES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。    \n算法详细已经有其他人写了，我就不再造轮子了。[密码算法详解——AES](http://www.blogfshare.com/aes-rijndael.html)    \n还有算法及解密算法的[模式介绍](http://blog.csdn.net/searchsun/article/details/2516191)，可以了解了解~    \n\n## RC4\n\n不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。\n\n## CommonCrypto\n\n对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    \n\n### CommonCrypto的一些主要的结构体\n\n1. CCOperation：定义操作：加密或解密\n\n``` \nenum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n```\n\n2. CCAlgorithm：加解密算法，很明显就不详细说明了。\n\n``` objc\nenum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n```\n\n3. CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到\n\n``` objc\nenum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n```\n\n4. KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度\n\n``` objc\nenum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n```\n\n### 通过代码实现\n\n#### 导入CommonCrypto的头文件。\n\n``` objc\n#import <CommonCrypto/CommonCrypto.h>\n```\n\n#### symCrypt\n\n``` objc\n/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@\"[ERROR] failed to encrypt|CCCryptoStatus: %d\", *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n```\n\n1. 根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength\n2. 加密后的数据总小于等于数据长度加上block的大小\n3. 申请bufferSize的空间以保存加密或解密后的数据\n4. 调用CCCrypt函数实现加解密。\n``` objc\nCCCryptorStatus CCCrypt(\n    CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n    CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n    const void *key,        /* 密钥 */\n    size_t keyLength,       /* 密钥长度 */\n    const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n    const void *dataIn,     /* 要加密或解密的数据 */\n    size_t dataInLength,    /* 数据长度 */\n    void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n    size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n    size_t *dataOutMoved    /* 结果所占的长度 */\n    )    \n    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n```\n5. 若成功，则将(void *)类型的数据封装到NSData中。\n6. 释放申请的buffer内存\n7. 返回。\n\n#### fixKeyLength\n\n``` objc\n/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength < kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength < kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n```\n\n#### blockSizeByAlgorithm\n\n``` objc \n/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n```\n\n上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：\n　　DESCipherActor.h\n　　``` objc\n    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n　　```\n　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传[Github](https://github.com/objchris/PKIDemo)\n\n\n　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！    \n　　What the ****！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        \n\n![desk](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg)    \n\n　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决...\n\n\n# 非对称加密\n\n对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n如甲乙双方需要加密通信：\n\n1. 乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。\n2. 得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。\n3. 乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。\n\n　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。\n　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。\n　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）\n\n![yaoMing](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png)\n\n## RSA\n\n### 算法原理\n\n1. 选取两个质数p和q, 计算`n = p * q` 。p和q要尽量大\n2. 根据质数`φ(p)=p-1`和欧拉方程满足乘法结合率的规律求出φ(n),即`φ(n)=(p-1)(q-1)`\n3. 选取质数e作为公钥指数, e的范围`1<e<φ(n)`,且 e 与 φ(n) 互质\n4. 出e对φ(n)的模反元素d，求解公式：`ed ≡ 1 (mod φ(n))`即可得出\n   这样计算后(n,e)是公钥，(n,d)是私钥。\n>公钥加密公式    \n>m^e ≡ c (mod n) 即 c = m^e mod n     \n>私钥解密公式    \n>c^d ≡ m (mod n) 即 m = c^d mod n    \n\nRSA加密常用的填充方式有下面3种：    \n\n1. RSA_PKCS1_PADDING 填充模式，最常用的模式    \n   输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n   根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     \n2. RSA_PKCS1_OAEP_PADDING    \n   输入：RSA_size(rsa) – 41    \n   输出：和modulus一样长    \n3. for RSA_NO_PADDING 不填充    \n   输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n\n特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：    \n[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)\n\n### iOS Security.framework\n\n#### encryptWithPublicKey\n\n``` objc\n- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@\"dataLength: %zu\", dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) < dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) < toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n```\n\n1. 根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）\n2. 创建MutableData用以下面操作添加Data\n3. 判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。\n4. while循环多次操作\n5. 使用SecKeyEncrypt进行加解密\n``` objc\nOSStatus SecKeyEncrypt(\n    SecKeyRef           key,                //加解密使用的密钥\n    SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n    const uint8_t       *plainText,          //明文\n    size_t              plainTextLen,        //明文长度\n    uint8_t             *cipherText,        //返回的密文\n    size_t              *cipherTextLen)     //返回的密文长度\n    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n```\n6. 将已经加解密过的数据剔除\n7. 往MutableData中添加数据\n8. 计算总的BufferSize，这里只是做个统计\n9. 将得到的数据进行Base64转码\n10. 记得释放cipherBuffer\n\n\n#### decryptWithPrivateKey\n\n``` objc \n- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer < cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer < toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n```\n\n解密和加密的方式基本一样，此处不多加赘述。\n[Demo](https://github.com/objchris/PKIDemo)\n\n\n**Hacker君，问你惊未，哈哈哈哈哈。**    \n非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    \n\n![hahahahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)    \n从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　\n\n题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。    \n更多的算法，eg：数字摘要、数字签名、口令认证等等都在[Github](https://github.com/objchris/PKIDemo)上了，有兴趣请移步。     \n关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！\n","source":"_posts/简简单单说说PKIOniOS.md","raw":"---\ntitle: 简简单单说说PKI On iOS\ndate: 2016-04-09 20:16:05\ntags: \n- Security\ntypora-copy-images-to: ipic\n---\n\n\nHacker,问你惊未Σ( ° △ °|||)︴\n\n<!--more-->\n\n![Crypto_Sherlock](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg) \n\n\n看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··   \n​    \n今天来聊聊阿澤君的故事，顺便谈谈\n\n1. CommonCryto中关于DES、AES的部分内容\n2. iOS的Security框架里关于RSA加密的部分内容....\n\n阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    \n\n![focusOnCom](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg)    \n\n很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。\n\n![bucuowo](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg)\n\n\n# 对称加密    \n\n采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。\n\n## DES\nDES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    \n\n![Crypto_DES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg)\n\n### 3DES\n\n3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：  \n3DES加密过程为：C=Ek3(Dk2(Ek1(P)))    \n3DES解密过程为：P=Dk1(EK2(Dk3(C)))    \n若**Ek1 == Ek2 == Ek3**，就是简单的DES了。\n\n## AES\n![Crypto_AES](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png)    \n图片来自网络，若有侵犯到权利之处，请告知，谢谢~    \n\nAES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。    \n算法详细已经有其他人写了，我就不再造轮子了。[密码算法详解——AES](http://www.blogfshare.com/aes-rijndael.html)    \n还有算法及解密算法的[模式介绍](http://blog.csdn.net/searchsun/article/details/2516191)，可以了解了解~    \n\n## RC4\n\n不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。\n\n## CommonCrypto\n\n对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    \n\n### CommonCrypto的一些主要的结构体\n\n1. CCOperation：定义操作：加密或解密\n\n``` \nenum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n```\n\n2. CCAlgorithm：加解密算法，很明显就不详细说明了。\n\n``` objc\nenum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n```\n\n3. CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到\n\n``` objc\nenum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n```\n\n4. KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度\n\n``` objc\nenum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n```\n\n### 通过代码实现\n\n#### 导入CommonCrypto的头文件。\n\n``` objc\n#import <CommonCrypto/CommonCrypto.h>\n```\n\n#### symCrypt\n\n``` objc\n/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@\"[ERROR] failed to encrypt|CCCryptoStatus: %d\", *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n```\n\n1. 根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength\n2. 加密后的数据总小于等于数据长度加上block的大小\n3. 申请bufferSize的空间以保存加密或解密后的数据\n4. 调用CCCrypt函数实现加解密。\n``` objc\nCCCryptorStatus CCCrypt(\n    CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n    CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n    const void *key,        /* 密钥 */\n    size_t keyLength,       /* 密钥长度 */\n    const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n    const void *dataIn,     /* 要加密或解密的数据 */\n    size_t dataInLength,    /* 数据长度 */\n    void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n    size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n    size_t *dataOutMoved    /* 结果所占的长度 */\n    )    \n    __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n```\n5. 若成功，则将(void *)类型的数据封装到NSData中。\n6. 释放申请的buffer内存\n7. 返回。\n\n#### fixKeyLength\n\n``` objc\n/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength < kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength < kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n```\n\n#### blockSizeByAlgorithm\n\n``` objc \n/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n```\n\n上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：\n　　DESCipherActor.h\n　　``` objc\n    - (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n    - (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n    - (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n    - (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n　　```\n　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传[Github](https://github.com/objchris/PKIDemo)\n\n\n　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！    \n　　What the ****！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        \n\n![desk](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg)    \n\n　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决...\n\n\n# 非对称加密\n\n对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。\n如甲乙双方需要加密通信：\n\n1. 乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。\n2. 得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。\n3. 乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。\n\n　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。\n　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。\n　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）\n\n![yaoMing](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png)\n\n## RSA\n\n### 算法原理\n\n1. 选取两个质数p和q, 计算`n = p * q` 。p和q要尽量大\n2. 根据质数`φ(p)=p-1`和欧拉方程满足乘法结合率的规律求出φ(n),即`φ(n)=(p-1)(q-1)`\n3. 选取质数e作为公钥指数, e的范围`1<e<φ(n)`,且 e 与 φ(n) 互质\n4. 出e对φ(n)的模反元素d，求解公式：`ed ≡ 1 (mod φ(n))`即可得出\n   这样计算后(n,e)是公钥，(n,d)是私钥。\n>公钥加密公式    \n>m^e ≡ c (mod n) 即 c = m^e mod n     \n>私钥解密公式    \n>c^d ≡ m (mod n) 即 m = c^d mod n    \n\nRSA加密常用的填充方式有下面3种：    \n\n1. RSA_PKCS1_PADDING 填充模式，最常用的模式    \n   输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n   根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     \n2. RSA_PKCS1_OAEP_PADDING    \n   输入：RSA_size(rsa) – 41    \n   输出：和modulus一样长    \n3. for RSA_NO_PADDING 不填充    \n   输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充    \n   输出：和modulus一样长    \n\n特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：    \n[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  \n[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)\n\n### iOS Security.framework\n\n#### encryptWithPublicKey\n\n``` objc\n- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@\"dataLength: %zu\", dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) < dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) < toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n```\n\n1. 根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）\n2. 创建MutableData用以下面操作添加Data\n3. 判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。\n4. while循环多次操作\n5. 使用SecKeyEncrypt进行加解密\n``` objc\nOSStatus SecKeyEncrypt(\n    SecKeyRef           key,                //加解密使用的密钥\n    SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n    const uint8_t       *plainText,          //明文\n    size_t              plainTextLen,        //明文长度\n    uint8_t             *cipherText,        //返回的密文\n    size_t              *cipherTextLen)     //返回的密文长度\n    __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n```\n6. 将已经加解密过的数据剔除\n7. 往MutableData中添加数据\n8. 计算总的BufferSize，这里只是做个统计\n9. 将得到的数据进行Base64转码\n10. 记得释放cipherBuffer\n\n\n#### decryptWithPrivateKey\n\n``` objc \n- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer < cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer < toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n```\n\n解密和加密的方式基本一样，此处不多加赘述。\n[Demo](https://github.com/objchris/PKIDemo)\n\n\n**Hacker君，问你惊未，哈哈哈哈哈。**    \n非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    \n\n![hahahahaha](https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg)    \n从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　\n\n题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。    \n更多的算法，eg：数字摘要、数字签名、口令认证等等都在[Github](https://github.com/objchris/PKIDemo)上了，有兴趣请移步。     \n关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！\n","slug":"简简单单说说PKIOniOS","published":1,"updated":"2018-03-07T08:04:04.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfku9xow000kz4y8wydcglsk","content":"<p>Hacker,问你惊未Σ( ° △ °|||)︴</p>\n<a id=\"more\"></a>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg\" alt=\"Crypto_Sherlock\"> </p>\n<p>看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··<br>​<br>今天来聊聊阿澤君的故事，顺便谈谈</p>\n<ol>\n<li>CommonCryto中关于DES、AES的部分内容</li>\n<li>iOS的Security框架里关于RSA加密的部分内容….</li>\n</ol>\n<p>阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg\" alt=\"focusOnCom\">    </p>\n<p>很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg\" alt=\"bucuowo\"></p>\n<h1 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h1><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。</p>\n<h2 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h2><p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg\" alt=\"Crypto_DES\"></p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：<br>3DES加密过程为：C=Ek3(Dk2(Ek1(P)))<br>3DES解密过程为：P=Dk1(EK2(Dk3(C)))<br>若<strong>Ek1 == Ek2 == Ek3</strong>，就是简单的DES了。</p>\n<h2 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png\" alt=\"Crypto_AES\"><br>图片来自网络，若有侵犯到权利之处，请告知，谢谢~    </p>\n<p>AES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。<br>算法详细已经有其他人写了，我就不再造轮子了。<a href=\"http://www.blogfshare.com/aes-rijndael.html\" target=\"_blank\" rel=\"external\">密码算法详解——AES</a><br>还有算法及解密算法的<a href=\"http://blog.csdn.net/searchsun/article/details/2516191\" target=\"_blank\" rel=\"external\">模式介绍</a>，可以了解了解~    </p>\n<h2 id=\"RC4\"><a href=\"#RC4\" class=\"headerlink\" title=\"RC4\"></a>RC4</h2><p>不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。</p>\n<h2 id=\"CommonCrypto\"><a href=\"#CommonCrypto\" class=\"headerlink\" title=\"CommonCrypto\"></a>CommonCrypto</h2><p>对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    </p>\n<h3 id=\"CommonCrypto的一些主要的结构体\"><a href=\"#CommonCrypto的一些主要的结构体\" class=\"headerlink\" title=\"CommonCrypto的一些主要的结构体\"></a>CommonCrypto的一些主要的结构体</h3><ol>\n<li>CCOperation：定义操作：加密或解密</li>\n</ol>\n<pre><code>enum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n</code></pre><ol>\n<li>CCAlgorithm：加解密算法，很明显就不详细说明了。</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n</code></pre>\n<ol>\n<li>CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n</code></pre>\n<ol>\n<li>KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n</code></pre>\n<h3 id=\"通过代码实现\"><a href=\"#通过代码实现\" class=\"headerlink\" title=\"通过代码实现\"></a>通过代码实现</h3><h4 id=\"导入CommonCrypto的头文件。\"><a href=\"#导入CommonCrypto的头文件。\" class=\"headerlink\" title=\"导入CommonCrypto的头文件。\"></a>导入CommonCrypto的头文件。</h4><pre><code class=\"objc\">#import &lt;CommonCrypto/CommonCrypto.h&gt;\n</code></pre>\n<h4 id=\"symCrypt\"><a href=\"#symCrypt\" class=\"headerlink\" title=\"symCrypt\"></a>symCrypt</h4><pre><code class=\"objc\">/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@&quot;[ERROR] failed to encrypt|CCCryptoStatus: %d&quot;, *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n</code></pre>\n<ol>\n<li>根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength</li>\n<li>加密后的数据总小于等于数据长度加上block的大小</li>\n<li>申请bufferSize的空间以保存加密或解密后的数据</li>\n<li>调用CCCrypt函数实现加解密。<pre><code class=\"objc\">CCCryptorStatus CCCrypt(\n CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n const void *key,        /* 密钥 */\n size_t keyLength,       /* 密钥长度 */\n const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n const void *dataIn,     /* 要加密或解密的数据 */\n size_t dataInLength,    /* 数据长度 */\n void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n size_t *dataOutMoved    /* 结果所占的长度 */\n )    \n __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>若成功，则将(void *)类型的数据封装到NSData中。</li>\n<li>释放申请的buffer内存</li>\n<li>返回。</li>\n</ol>\n<h4 id=\"fixKeyLength\"><a href=\"#fixKeyLength\" class=\"headerlink\" title=\"fixKeyLength\"></a>fixKeyLength</h4><pre><code class=\"objc\">/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength &lt; kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength &lt; kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n</code></pre>\n<h4 id=\"blockSizeByAlgorithm\"><a href=\"#blockSizeByAlgorithm\" class=\"headerlink\" title=\"blockSizeByAlgorithm\"></a>blockSizeByAlgorithm</h4><pre><code class=\"objc\">/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n</code></pre>\n<p>上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：<br>　　DESCipherActor.h<br>　　``` objc</p>\n<pre><code>- (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n- (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n- (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n- (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n</code></pre><p>　　```<br>　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传<a href=\"https://github.com/objchris/PKIDemo\" target=\"_blank\" rel=\"external\">Github</a></p>\n<p>　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！<br>　　What the <em>**</em>！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg\" alt=\"desk\">    </p>\n<p>　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决…</p>\n<h1 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h1><p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>如甲乙双方需要加密通信：</p>\n<ol>\n<li>乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。</li>\n<li>得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。</li>\n<li>乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。</li>\n</ol>\n<p>　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。<br>　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。<br>　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png\" alt=\"yaoMing\"></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><ol>\n<li>选取两个质数p和q, 计算<code>n = p * q</code> 。p和q要尽量大</li>\n<li>根据质数<code>φ(p)=p-1</code>和欧拉方程满足乘法结合率的规律求出φ(n),即<code>φ(n)=(p-1)(q-1)</code></li>\n<li>选取质数e作为公钥指数, e的范围<code>1&lt;e&lt;φ(n)</code>,且 e 与 φ(n) 互质</li>\n<li>出e对φ(n)的模反元素d，求解公式：<code>ed ≡ 1 (mod φ(n))</code>即可得出<br>这样计算后(n,e)是公钥，(n,d)是私钥。<blockquote>\n<p>公钥加密公式<br>m^e ≡ c (mod n) 即 c = m^e mod n<br>私钥解密公式<br>c^d ≡ m (mod n) 即 m = c^d mod n    </p>\n</blockquote>\n</li>\n</ol>\n<p>RSA加密常用的填充方式有下面3种：    </p>\n<ol>\n<li>RSA_PKCS1_PADDING 填充模式，最常用的模式<br>输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长<br>根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     </li>\n<li>RSA_PKCS1_OAEP_PADDING<br>输入：RSA_size(rsa) – 41<br>输出：和modulus一样长    </li>\n<li>for RSA_NO_PADDING 不填充<br>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长    </li>\n</ol>\n<p>特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：<br><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\" target=\"_blank\" rel=\"external\">RSA算法原理（一）</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\" target=\"_blank\" rel=\"external\">RSA算法原理（二）</a></p>\n<h3 id=\"iOS-Security-framework\"><a href=\"#iOS-Security-framework\" class=\"headerlink\" title=\"iOS Security.framework\"></a>iOS Security.framework</h3><h4 id=\"encryptWithPublicKey\"><a href=\"#encryptWithPublicKey\" class=\"headerlink\" title=\"encryptWithPublicKey\"></a>encryptWithPublicKey</h4><pre><code class=\"objc\">- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@&quot;dataLength: %zu&quot;, dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) &lt; dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) &lt; toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &amp;cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n</code></pre>\n<ol>\n<li>根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）</li>\n<li>创建MutableData用以下面操作添加Data</li>\n<li>判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。</li>\n<li>while循环多次操作</li>\n<li>使用SecKeyEncrypt进行加解密<pre><code class=\"objc\">OSStatus SecKeyEncrypt(\n SecKeyRef           key,                //加解密使用的密钥\n SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n const uint8_t       *plainText,          //明文\n size_t              plainTextLen,        //明文长度\n uint8_t             *cipherText,        //返回的密文\n size_t              *cipherTextLen)     //返回的密文长度\n __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>将已经加解密过的数据剔除</li>\n<li>往MutableData中添加数据</li>\n<li>计算总的BufferSize，这里只是做个统计</li>\n<li>将得到的数据进行Base64转码</li>\n<li>记得释放cipherBuffer</li>\n</ol>\n<h4 id=\"decryptWithPrivateKey\"><a href=\"#decryptWithPrivateKey\" class=\"headerlink\" title=\"decryptWithPrivateKey\"></a>decryptWithPrivateKey</h4><pre><code class=\"objc\">- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer &lt; cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer &lt; toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &amp;plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n</code></pre>\n<p>解密和加密的方式基本一样，此处不多加赘述。<br><a href=\"https://github.com/objchris/PKIDemo\" target=\"_blank\" rel=\"external\">Demo</a></p>\n<p><strong>Hacker君，问你惊未，哈哈哈哈哈。</strong><br>非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahahahaha\"><br>从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　</p>\n<p>题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。<br>更多的算法，eg：数字摘要、数字签名、口令认证等等都在<a href=\"https://github.com/objchris/PKIDemo\" target=\"_blank\" rel=\"external\">Github</a>上了，有兴趣请移步。<br>关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！</p>\n","excerpt":"<p>Hacker,问你惊未Σ( ° △ °|||)︴</p>","more":"<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/sijuh.jpg\" alt=\"Crypto_Sherlock\"> </p>\n<p>看了很多侦探片之后，逐渐发现加解密的神奇所在。能够在别人无法察觉的情况下传递信息（我很喜欢看这些片子，哈哈哈）。无论是Morse Code还是对着某本书根据页码行数字数来确定表达信息，都能让我看到前人的智慧。说真的，我特别钟意神探夏洛克，就算英文渣渣也会在更新的时候到Youtube上看看，等翻译完再翻看一次。记得中国剧场那一集最后根据伦敦地图破解了藏在苏州码子里的暗号，So Sexy~··<br>​<br>今天来聊聊阿澤君的故事，顺便谈谈</p>\n<ol>\n<li>CommonCryto中关于DES、AES的部分内容</li>\n<li>iOS的Security框架里关于RSA加密的部分内容….</li>\n</ol>\n<p>阿澤君是个大四🐶，最近在烦毕业论文的事情。辛辛苦苦撸了二十个年(xiao)头(shi)的论文，肯定要第一时间交到老师手里，让他看看，好舒缓阿澤君难产的心情。阿澤君知道有个Hacker君一直在觊觎阿澤君的论文，想拿过来一抄了之。而且Hacker君是一流的网络黑客，盗线偷取别人的信息是最在行的了。因此怎么发给千里之外的老师可难为阿澤君了。。。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/r6p4c.jpg\" alt=\"focusOnCom\">    </p>\n<p>很快，阿澤君想到用加密的方法，利用对称加密的方法给论文加密后发送给老师。</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/i66ud.jpg\" alt=\"bucuowo\"></p>\n<h1 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h1><p>采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密。加密算法中数DES、3DES、AES(块算法)和RC4(流算法)最为常用了。</p>\n<h2 id=\"DES\"><a href=\"#DES\" class=\"headerlink\" title=\"DES\"></a>DES</h2><p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/7o3yv.jpg\" alt=\"Crypto_DES\"></p>\n<h3 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h3><p>3DES是在DES的基础上做了两次加密和一次解密。具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，P代表明文，C代表密文，这样：<br>3DES加密过程为：C=Ek3(Dk2(Ek1(P)))<br>3DES解密过程为：P=Dk1(EK2(Dk3(C)))<br>若<strong>Ek1 == Ek2 == Ek3</strong>，就是简单的DES了。</p>\n<h2 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h2><p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/1lfh4.png\" alt=\"Crypto_AES\"><br>图片来自网络，若有侵犯到权利之处，请告知，谢谢~    </p>\n<p>AES加密过程涉及到4种操作：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）。解密过程分别为对应的逆操作。由于每一步操作都是可逆的，按照相反的顺序进行解密即可恢复明文。加解密中每轮的密钥分别由初始密钥扩展得到。算法中16字节的明文、密文和轮密钥都以一个4x4的矩阵表示。<br>算法详细已经有其他人写了，我就不再造轮子了。<a href=\"http://www.blogfshare.com/aes-rijndael.html\">密码算法详解——AES</a><br>还有算法及解密算法的<a href=\"http://blog.csdn.net/searchsun/article/details/2516191\">模式介绍</a>，可以了解了解~    </p>\n<h2 id=\"RC4\"><a href=\"#RC4\" class=\"headerlink\" title=\"RC4\"></a>RC4</h2><p>不同于块算法的是，RC4等流算法不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。</p>\n<h2 id=\"CommonCrypto\"><a href=\"#CommonCrypto\" class=\"headerlink\" title=\"CommonCrypto\"></a>CommonCrypto</h2><p>对于身为iOS攻城狮的阿澤君来说，感觉还是这一部分比较重要。    </p>\n<h3 id=\"CommonCrypto的一些主要的结构体\"><a href=\"#CommonCrypto的一些主要的结构体\" class=\"headerlink\" title=\"CommonCrypto的一些主要的结构体\"></a>CommonCrypto的一些主要的结构体</h3><ol>\n<li>CCOperation：定义操作：加密或解密</li>\n</ol>\n<pre><code>enum {\n    kCCEncrypt = 0, \n    kCCDecrypt,     \n};\ntypedef uint32_t CCOperation;\n</code></pre><ol>\n<li>CCAlgorithm：加解密算法，很明显就不详细说明了。</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCAlgorithmAES128 = 0,\n    kCCAlgorithmAES = 0,\n    kCCAlgorithmDES,\n    kCCAlgorithm3DES,       \n    kCCAlgorithmCAST,       \n    kCCAlgorithmRC4,\n    kCCAlgorithmRC2,   \n    kCCAlgorithmBlowfish    \n};\ntypedef uint32_t CCAlgorithm;\n</code></pre>\n<ol>\n<li>CCOptions：选项：按照P7补足块算法的块长度或者选择ECB模式，关于模式请看上面AES中介绍的文章。对于RC4等流算法不适用。或者说不需要使用到</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCOptionPKCS7Padding   = 0x0001,\n    kCCOptionECBMode        = 0x0002\n};\n</code></pre>\n<ol>\n<li>KeySize和BlockSize：规定加解密密钥的长度和明文密文块的长度</li>\n</ol>\n<pre><code class=\"objc\">enum {\n    kCCKeySizeAES128          = 16,\n    kCCKeySizeAES192          = 24,\n    kCCKeySizeAES256          = 32,\n    kCCKeySizeDES             = 8,\n    kCCKeySize3DES            = 24,\n    kCCKeySizeMinCAST         = 5,\n    kCCKeySizeMaxCAST         = 16,\n    kCCKeySizeMinRC4          = 1,\n    kCCKeySizeMaxRC4          = 512,\n    kCCKeySizeMinRC2          = 1,\n    kCCKeySizeMaxRC2          = 128,\n    kCCKeySizeMinBlowfish     = 8,\n    kCCKeySizeMaxBlowfish     = 56,\n};\nenum {\n    /* AES */\n    kCCBlockSizeAES128        = 16,\n    /* DES */\n    kCCBlockSizeDES           = 8,\n    /* 3DES */\n    kCCBlockSize3DES          = 8,\n    /* CAST */\n    kCCBlockSizeCAST          = 8,\n    kCCBlockSizeRC2           = 8,\n    kCCBlockSizeBlowfish      = 8,\n};\n</code></pre>\n<h3 id=\"通过代码实现\"><a href=\"#通过代码实现\" class=\"headerlink\" title=\"通过代码实现\"></a>通过代码实现</h3><h4 id=\"导入CommonCrypto的头文件。\"><a href=\"#导入CommonCrypto的头文件。\" class=\"headerlink\" title=\"导入CommonCrypto的头文件。\"></a>导入CommonCrypto的头文件。</h4><pre><code class=\"objc\">#import &lt;CommonCrypto/CommonCrypto.h&gt;\n</code></pre>\n<h4 id=\"symCrypt\"><a href=\"#symCrypt\" class=\"headerlink\" title=\"symCrypt\"></a>symCrypt</h4><pre><code class=\"objc\">/*!\n    @function   symCrypt\n    @abstract   对称解密\n    @param      operation       加密或解密\n    @param      data            需要加解密的数据\n    @param      algorithm       加解密所采用的算法\n    @param      key             加解密时提供的密钥\n    @param      iv              Initialization Vector(CBC模式下需要)\n    @param      options         加密数据字节数不是block的整数倍时需要制定padding\n                                详情参见CommonCryptor头文件\n    @param      status          加解密成功与否所返回的状态\n    @result     解密后得到的结果\n */\n- (NSData *)symCrypt:(CCOperation)operation\n         processData:(NSData *)data\n      UsingAlgorithm:(CCAlgorithm)algorithm\n                 key:(NSData *)key\n initalizationVector:(NSData *)iv\n             options:(CCOptions)options\n              status:(CCCryptorStatus *)status\n{\n    NSData *result = nil;\n    NSMutableData *cKey = [key mutableCopy], *cIV = [iv mutableCopy];\n    [self fixKeyLengthsByAlgorithm:algorithm keyData:cKey ivData:cIV];//1\n    size_t bufferSize = [data length] + [self blockSizeByAlgorithm:algorithm]; // 2\n    void *buffer = malloc(bufferSize); //3\n    size_t encryptedSize = 0;\n    *status = CCCrypt(operation, algorithm, options, [cKey bytes], [cKey length], [cIV bytes], [data bytes], [data length], buffer, bufferSize, &amp;encryptedSize); //4\n    if (*status == kCCSuccess) {\n        result = [NSData dataWithBytes:buffer length:encryptedSize];  //5\n    } else {\n        NSLog(@&quot;[ERROR] failed to encrypt|CCCryptoStatus: %d&quot;, *status);\n    }\n    free(buffer);  //6\n    return result;  //7\n}\n</code></pre>\n<ol>\n<li>根据加解密算法检查Key和iv的长度是否符合要求，详细请看下面列出的函数fixKeyLength</li>\n<li>加密后的数据总小于等于数据长度加上block的大小</li>\n<li>申请bufferSize的空间以保存加密或解密后的数据</li>\n<li>调用CCCrypt函数实现加解密。<pre><code class=\"objc\">CCCryptorStatus CCCrypt(\n CCOperation op,         /* 加密或解密：kCCEncrypt, etc. */\n CCAlgorithm alg,        /* 加解密采用的算法：kCCAlgorithmAES128, etc. */\n CCOptions options,      /* kCCOptionPKCS7Padding, etc. */\n const void *key,        /* 密钥 */\n size_t keyLength,       /* 密钥长度 */\n const void *iv,         /* iv，使用与CBC模式下，明文后32位和iv异或后做为下一阶段的前32位 */\n const void *dataIn,     /* 要加密或解密的数据 */\n size_t dataInLength,    /* 数据长度 */\n void *dataOut,          /* 注意传入的是指针，加解密后的数据将从此处返回 */\n size_t dataOutAvailable,/* 为dataOut申请的可写长度 */\n size_t *dataOutMoved    /* 结果所占的长度 */\n )    \n __OSX_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>若成功，则将(void *)类型的数据封装到NSData中。</li>\n<li>释放申请的buffer内存</li>\n<li>返回。</li>\n</ol>\n<h4 id=\"fixKeyLength\"><a href=\"#fixKeyLength\" class=\"headerlink\" title=\"fixKeyLength\"></a>fixKeyLength</h4><pre><code class=\"objc\">/*!\n    @function   fixKeyLength\n    @abstract   修改密钥长度至与算法匹配\n    @param      algorithm       加解密所采用的算法\n    @param      keyData         密钥\n    @param      ivData          Initialization Vector\n    @result     将密钥长度和iv修改至与算法匹配的长度\n */\n- (void)fixKeyLengthsByAlgorithm:(CCAlgorithm)algorithm\n                         keyData:(NSMutableData *)keyData\n                          ivData:(NSMutableData *)ivData\n{\n    NSUInteger keyLength = [keyData length];\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n        {\n            if (keyLength &lt; kCCKeySizeAES128) {\n                keyData.length = kCCKeySizeAES128;\n            } else if (keyLength &lt; kCCKeySizeAES192) {\n                keyData.length = kCCKeySizeAES192;\n            } else {\n                keyData.length = kCCKeySizeAES256;\n            }\n            break;\n        }\n        case kCCAlgorithmDES:\n        {\n            keyData.length = kCCKeySizeDES;\n            break;\n        }\n        case kCCAlgorithm3DES:\n        {\n            keyData.length = kCCKeySize3DES;\n            break;\n        }\n        case kCCAlgorithmRC4:\n        {\n            keyData.length = kCCKeySizeMaxRC4;\n            break;\n        }\n        default:\n            break;\n    }\n    ivData.length = keyData.length;\n}\n</code></pre>\n<h4 id=\"blockSizeByAlgorithm\"><a href=\"#blockSizeByAlgorithm\" class=\"headerlink\" title=\"blockSizeByAlgorithm\"></a>blockSizeByAlgorithm</h4><pre><code class=\"objc\">/*!\n    @function   blockSizeByAlgorithm\n    @abstract   根据算法获取每个block的大小\n    @param      algorithm       加密所采用的算法\n    @result     该算法对应的block大小\n */\n- (size_t)blockSizeByAlgorithm:(CCAlgorithm)algorithm {\n    switch (algorithm) {\n        case kCCAlgorithmAES:\n            return kCCBlockSizeAES128;\n        case kCCAlgorithmDES:\n        case kCCAlgorithm3DES:\n        case kCCAlgorithmRC4:\n            return kCCBlockSizeDES;\n        default:\n            return 0;\n    }\n}\n</code></pre>\n<p>上述两个函数主要是为了规范密钥的长度和获取明文密文块的长度，很好理解就不详细介绍了。这样还是不能傻瓜式地调用，因此阿澤君创建了DESCipherActor继承于SymCipherActor，进一步进行封装：<br>　　DESCipherActor.h<br>　　``` objc</p>\n<pre><code>- (NSString *)encryptInCBC:(NSString *)plainText key:(NSString *)key iv:(NSData *)iv;\n- (NSString *)decryptInCBC:(NSString *)cipherText key:(NSString *)key iv:(NSData *)iv;\n- (NSString *)encryptInEBC:(NSString *)plainText key:(NSString *)key;\n- (NSString *)decryptInEBC:(NSString *)cipherText key:(NSString *)key;\n</code></pre><p>　　```<br>　　还有AES、RC4的实现大致相同，具体可参考Demo，已经上传<a href=\"https://github.com/objchris/PKIDemo\">Github</a></p>\n<p>　　果然，采用加密算法加密后的论文顺利发到老师那里，问题是解密用密钥还在阿澤君手上，老师还是无法看到论文内容，密钥不能通过网络传输给老师，因为Hacker君还在监听着阿澤君和老师的通讯。难道要阿澤君不惧千里（其实不是很远，哈哈哈。我就夸张那么一点点~）去到老师那边，那为何不直接将论文交给老师呢？！！！<br>　　What the <em>**</em>！！！💔💔阿澤君此时心里千万只草泥马在奔腾。        </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/9hwet.jpg\" alt=\"desk\">    </p>\n<p>　　但是阿澤君不会这样轻易地狗带，因为还可以通过非对称加密来解决…</p>\n<h1 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h1><p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>如甲乙双方需要加密通信：</p>\n<ol>\n<li>乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。</li>\n<li>得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。</li>\n<li>乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。</li>\n</ol>\n<p>　　在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。<br>　　同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。<br>　　说到非对称加密，不得不说RSA（其实是阿澤君只接触过这个。。。）</p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/6tgz2.png\" alt=\"yaoMing\"></p>\n<h2 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h2><h3 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h3><ol>\n<li>选取两个质数p和q, 计算<code>n = p * q</code> 。p和q要尽量大</li>\n<li>根据质数<code>φ(p)=p-1</code>和欧拉方程满足乘法结合率的规律求出φ(n),即<code>φ(n)=(p-1)(q-1)</code></li>\n<li>选取质数e作为公钥指数, e的范围<code>1&lt;e&lt;φ(n)</code>,且 e 与 φ(n) 互质</li>\n<li>出e对φ(n)的模反元素d，求解公式：<code>ed ≡ 1 (mod φ(n))</code>即可得出<br>这样计算后(n,e)是公钥，(n,d)是私钥。<blockquote>\n<p>公钥加密公式<br>m^e ≡ c (mod n) 即 c = m^e mod n<br>私钥解密公式<br>c^d ≡ m (mod n) 即 m = c^d mod n    </p>\n</blockquote>\n</li>\n</ol>\n<p>RSA加密常用的填充方式有下面3种：    </p>\n<ol>\n<li>RSA_PKCS1_PADDING 填充模式，最常用的模式<br>输入：必须 比RSA钥模长(modulus)短至少11个字节，也就是RSA_size(rsa) – 11。如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长<br>根据这个要求，对于1024bit的密钥，block length = 1024/8 – 11 = 117 字节     </li>\n<li>RSA_PKCS1_OAEP_PADDING<br>输入：RSA_size(rsa) – 41<br>输出：和modulus一样长    </li>\n<li>for RSA_NO_PADDING 不填充<br>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充<br>输出：和modulus一样长    </li>\n</ol>\n<p>特别推荐的是阮一峰的日志两篇日志，写得非常好，我也是参考这个写的：<br><a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\">RSA算法原理（一）</a><br><a href=\"http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html\">RSA算法原理（二）</a></p>\n<h3 id=\"iOS-Security-framework\"><a href=\"#iOS-Security-framework\" class=\"headerlink\" title=\"iOS Security.framework\"></a>iOS Security.framework</h3><h4 id=\"encryptWithPublicKey\"><a href=\"#encryptWithPublicKey\" class=\"headerlink\" title=\"encryptWithPublicKey\"></a>encryptWithPublicKey</h4><pre><code class=\"objc\">- (NSString *)encrypt:(NSString *)stringToEncrypt withPublicKey:(SecKeyRef)publicKey{\n    OSStatus status = noErr;\n    size_t cipherBufferSize;\n    uint8_t *cipherBuffer;\n    uint8_t *dataToEncrypt = (uint8_t *)[stringToEncrypt cStringUsingEncoding:NSUTF8StringEncoding];\n    size_t dataLength = stringToEncrypt.length;\n    NSLog(@&quot;dataLength: %zu&quot;, dataLength);\n    cipherBufferSize = SecKeyGetBlockSize(publicKey);       // 1\n    cipherBuffer = malloc(cipherBufferSize);\n    size_t totalBufferSize = 0;\n    NSMutableData *data = [[NSMutableData alloc] init];    // 2\n    //使用kSecPaddingPKCS1作为加密的padding\n    if ((cipherBufferSize - 11) &lt; dataLength) {            // 3\n        //若需要加密的数据长度过长，需要分块加密\n        size_t toEncryptDataLength = dataLength;\n        while ((cipherBufferSize - 11) &lt; toEncryptDataLength) { // 4\n            status = SecKeyEncrypt(publicKey,\n                                   kSecPaddingPKCS1,\n                                   dataToEncrypt + (dataLength - toEncryptDataLength),\n                                   cipherBufferSize - 11,\n                                   cipherBuffer,\n                                   &amp;cipherBufferSize);          // 5\n            toEncryptDataLength = toEncryptDataLength - (cipherBufferSize - 11);        //6\n            //CipherBuffer是通过malloc创建，没有对内存空间进行初始化，有很多其他数据\n            //转储成NSData，确保对正确长度的cipherBuffer的获取\n            [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];    //7\n            totalBufferSize += cipherBufferSize;    //8\n        }\n        //对剩余的数据进行加密\n        status = SecKeyEncrypt(publicKey,\n                               kSecPaddingPKCS1,\n                               dataToEncrypt + (dataLength - toEncryptDataLength),\n                               toEncryptDataLength,\n                               cipherBuffer,\n                               &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];               \n        totalBufferSize += cipherBufferSize;\n    } else {\n        //需要加密的数据长度小于SecKeyGetBlockSize(publicKey)－11，直接加密\n        status = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, dataToEncrypt, dataLength, cipherBuffer, &amp;cipherBufferSize);\n        [data appendData:[NSData dataWithBytes:cipherBuffer length:cipherBufferSize]];\n    }\n    if (publicKey) {\n        CFRelease(publicKey);\n    }\n    NSString *encryptedString = [GTMBase64 stringByEncodingData:[data copy]];            //9\n    free(cipherBuffer);            //10\n    return encryptedString;\n}\n</code></pre>\n<ol>\n<li>根据Key判断加解密块大小（若使用kSecPaddingPKCS1，需要手动调整块大小小于这个返回值 - 11）</li>\n<li>创建MutableData用以下面操作添加Data</li>\n<li>判断数据总大小是否大于SecKeyGetBlockSize(publicKey) - 11，是则拆分成多个块加解密，否则直接加解密。</li>\n<li>while循环多次操作</li>\n<li>使用SecKeyEncrypt进行加解密<pre><code class=\"objc\">OSStatus SecKeyEncrypt(\n SecKeyRef           key,                //加解密使用的密钥\n SecPadding          padding,            //padding，一般为kSecPaddingPKCS1，需要注意数据块的大小问题\n const uint8_t       *plainText,          //明文\n size_t              plainTextLen,        //明文长度\n uint8_t             *cipherText,        //返回的密文\n size_t              *cipherTextLen)     //返回的密文长度\n __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);\n</code></pre>\n</li>\n<li>将已经加解密过的数据剔除</li>\n<li>往MutableData中添加数据</li>\n<li>计算总的BufferSize，这里只是做个统计</li>\n<li>将得到的数据进行Base64转码</li>\n<li>记得释放cipherBuffer</li>\n</ol>\n<h4 id=\"decryptWithPrivateKey\"><a href=\"#decryptWithPrivateKey\" class=\"headerlink\" title=\"decryptWithPrivateKey\"></a>decryptWithPrivateKey</h4><pre><code class=\"objc\">- (NSString *)decrypt: (NSString *)stringToDecrypt withPrivateKey:(SecKeyRef)privateKey {\n    NSData *dataToDecrypt = [GTMBase64 decodeString:stringToDecrypt];\n    OSStatus status = noErr;\n    size_t cipherBufferSize = [dataToDecrypt length];\n    uint8_t *cipherBuffer = (uint8_t *)[dataToDecrypt bytes];\n    size_t plainBufferSize;\n    uint8_t *plainBuffer;\n    plainBufferSize = SecKeyGetBlockSize(privateKey);\n    plainBuffer = malloc(plainBufferSize);\n    NSMutableData *data = [[NSMutableData alloc] init];\n    size_t decryptLengthPer = SecKeyGetBlockSize(privateKey);\n    if (decryptLengthPer &lt; cipherBufferSize) {\n        size_t toDecryptDataLength = cipherBufferSize;\n        size_t totalBufferSize = 0;\n        while (decryptLengthPer &lt; toDecryptDataLength) {\n            status = SecKeyDecrypt(privateKey,\n                                   kSecPaddingPKCS1,\n                                   cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                                   decryptLengthPer,\n                                   plainBuffer,\n                                   &amp;plainBufferSize);\n            toDecryptDataLength = toDecryptDataLength - decryptLengthPer;\n            if (status == noErr) {\n                [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n            }\n            totalBufferSize += plainBufferSize;\n        }\n        status = SecKeyDecrypt(privateKey,\n                               kSecPaddingPKCS1,\n                               cipherBuffer + (cipherBufferSize - toDecryptDataLength),\n                               decryptLengthPer,\n                               plainBuffer,\n                               &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n        totalBufferSize += plainBufferSize;\n    } else {\n        status = SecKeyDecrypt(privateKey, kSecPaddingPKCS1, cipherBuffer, cipherBufferSize, plainBuffer, &amp;plainBufferSize);\n        if (status == noErr) {\n            [data appendData:[NSData dataWithBytes:plainBuffer length:plainBufferSize]];\n        }\n    }\n    if (privateKey) {\n        CFRelease(privateKey);\n    }\n    NSString *decryptedString = [[NSString alloc] initWithData:[data copy] encoding:NSUTF8StringEncoding];\n    free(plainBuffer);\n    return decryptedString;\n}\n</code></pre>\n<p>解密和加密的方式基本一样，此处不多加赘述。<br><a href=\"https://github.com/objchris/PKIDemo\">Demo</a></p>\n<p><strong>Hacker君，问你惊未，哈哈哈哈哈。</strong><br>非对称加密对阿澤君来说完全解决了问题(づ￣ 3￣)づ，使用老师的公钥加密论文后发送回给他。Hacker君就算截取到也无济于事，因为Hacker君没有老师的私钥，无法获取到其中的内容。老师获取到阿澤君发送的论文后自然可以解密查看。    </p>\n<p><img src=\"https://oaoa-1256157051.cos.ap-guangzhou.myqcloud.com/blog/pivxc.jpg\" alt=\"hahahahaha\"><br>从中阿澤君也学到了很多，所以分享给大家❤️。故事有(fei)点(chang)弱智，希望大家不要在意，关注加解密算法就好了~\n　　</p>\n<p>题外话：PKI基础最近才接触，学得不深，有些东西写错请大家见谅。<br>更多的算法，eg：数字摘要、数字签名、口令认证等等都在<a href=\"https://github.com/objchris/PKIDemo\">Github</a>上了，有兴趣请移步。<br>关于加解密，貌似OpenSSL会经常用，具体阿澤君也不清楚，还需要更加深入的学习，共勉吧！！！！</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjfku9xnz0000z4y8a919o8t0","tag_id":"cjfku9xod0003z4y8s22udyt1","_id":"cjfku9xom0008z4y8pg1shmu1"},{"post_id":"cjfku9xob0002z4y8i0kd4esk","tag_id":"cjfku9xod0003z4y8s22udyt1","_id":"cjfku9xor000cz4y8pwfkqh9n"},{"post_id":"cjfku9xog0004z4y8o04c4pzf","tag_id":"cjfku9xoq000bz4y8kok6p62w","_id":"cjfku9xou000hz4y81fv06tru"},{"post_id":"cjfku9xoj0005z4y80nj5swkb","tag_id":"cjfku9xot000fz4y8gpo5y1b9","_id":"cjfku9xox000lz4y841f8n27t"},{"post_id":"cjfku9xok0006z4y8tpawopwz","tag_id":"cjfku9xov000jz4y8ngwzx1rb","_id":"cjfku9xoy000nz4y8804x3rrz"},{"post_id":"cjfku9xom0009z4y8azxp31gx","tag_id":"cjfku9xox000mz4y83nn9zgsz","_id":"cjfku9xoz000pz4y89vm7dh7j"},{"post_id":"cjfku9xop000az4y8zsbt73d5","tag_id":"cjfku9xov000jz4y8ngwzx1rb","_id":"cjfku9xoz000rz4y8rqtwcf0k"},{"post_id":"cjfku9xor000dz4y8zfhph87v","tag_id":"cjfku9xot000fz4y8gpo5y1b9","_id":"cjfku9xp0000tz4y8bym7ry4h"},{"post_id":"cjfku9xos000ez4y81g3ewzgw","tag_id":"cjfku9xot000fz4y8gpo5y1b9","_id":"cjfku9xp0000vz4y8ls15oj4t"},{"post_id":"cjfku9xot000gz4y80avuc72k","tag_id":"cjfku9xp0000uz4y8kdirtzuu","_id":"cjfku9xp0000xz4y8i8y4wxrs"},{"post_id":"cjfku9xou000iz4y8z3x7wqi6","tag_id":"cjfku9xp0000wz4y82nmwxt0f","_id":"cjfku9xp1000zz4y8gwh7a7vb"},{"post_id":"cjfku9xow000kz4y8wydcglsk","tag_id":"cjfku9xp0000yz4y8fls2r3ly","_id":"cjfku9xp10010z4y8cakf8vol"}],"Tag":[{"name":"UIView","_id":"cjfku9xod0003z4y8s22udyt1"},{"name":"Animation","_id":"cjfku9xoq000bz4y8kok6p62w"},{"name":"Mood","_id":"cjfku9xot000fz4y8gpo5y1b9"},{"name":"Thread","_id":"cjfku9xov000jz4y8ngwzx1rb"},{"name":"Library","_id":"cjfku9xox000mz4y83nn9zgsz"},{"name":"Block","_id":"cjfku9xp0000uz4y8kdirtzuu"},{"name":"Summary","_id":"cjfku9xp0000wz4y82nmwxt0f"},{"name":"Security","_id":"cjfku9xp0000yz4y8fls2r3ly"}]}}